// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api/trading.proto
#ifndef GRPC_api_2ftrading_2eproto__INCLUDED
#define GRPC_api_2ftrading_2eproto__INCLUDED

#include "api/trading.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace api {
namespace v1 {

class TradingService final {
 public:
  static constexpr char const* service_full_name() {
    return "api.v1.TradingService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Prepare a submit order request
    virtual ::grpc::Status PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::api::v1::PrepareSubmitOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>> AsyncPrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>>(AsyncPrepareSubmitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>> PrepareAsyncPrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>>(PrepareAsyncPrepareSubmitOrderRaw(context, request, cq));
    }
    // Prepare a cancel order request
    virtual ::grpc::Status PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::api::v1::PrepareCancelOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>> AsyncPrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>>(AsyncPrepareCancelOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>> PrepareAsyncPrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>>(PrepareAsyncPrepareCancelOrderRaw(context, request, cq));
    }
    // Prepare an amend order request
    virtual ::grpc::Status PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::api::v1::PrepareAmendOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>> AsyncPrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>>(AsyncPrepareAmendOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>> PrepareAsyncPrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>>(PrepareAsyncPrepareAmendOrderRaw(context, request, cq));
    }
    // Request a withdrawal
    virtual ::grpc::Status PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::api::v1::PrepareWithdrawResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>> AsyncPrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>>(AsyncPrepareWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>> PrepareAsyncPrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>>(PrepareAsyncPrepareWithdrawRaw(context, request, cq));
    }
    // Submit a signed transaction
    virtual ::grpc::Status SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::api::v1::SubmitTransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>> AsyncSubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>>(AsyncSubmitTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>> PrepareAsyncSubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>>(PrepareAsyncSubmitTransactionRaw(context, request, cq));
    }
    // Submit a signed transaction (v2)
    virtual ::grpc::Status SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::api::v1::SubmitTransactionV2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>> AsyncSubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>>(AsyncSubmitTransactionV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>> PrepareAsyncSubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>>(PrepareAsyncSubmitTransactionV2Raw(context, request, cq));
    }
    // Prepare a governance proposal
    virtual ::grpc::Status PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::api::v1::PrepareProposalSubmissionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>> AsyncPrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>>(AsyncPrepareProposalSubmissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>> PrepareAsyncPrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>>(PrepareAsyncPrepareProposalSubmissionRaw(context, request, cq));
    }
    // Prepare a governance vote
    virtual ::grpc::Status PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::api::v1::PrepareVoteSubmissionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>> AsyncPrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>>(AsyncPrepareVoteSubmissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>> PrepareAsyncPrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>>(PrepareAsyncPrepareVoteSubmissionRaw(context, request, cq));
    }
    // Propagate a chain event
    virtual ::grpc::Status PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::api::v1::PropagateChainEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>> AsyncPropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>>(AsyncPropagateChainEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>> PrepareAsyncPropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>>(PrepareAsyncPropagateChainEventRaw(context, request, cq));
    }
    // Prepare a liquidity provision request
    virtual ::grpc::Status PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::api::v1::PrepareLiquidityProvisionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>> AsyncPrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>>(AsyncPrepareLiquidityProvisionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>> PrepareAsyncPrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>>(PrepareAsyncPrepareLiquidityProvisionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Prepare a submit order request
      virtual void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Prepare a cancel order request
      virtual void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Prepare an amend order request
      virtual void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Request a withdrawal
      virtual void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Submit a signed transaction
      virtual void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Submit a signed transaction (v2)
      virtual void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Prepare a governance proposal
      virtual void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Prepare a governance vote
      virtual void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Propagate a chain event
      virtual void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Prepare a liquidity provision request
      virtual void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>* AsyncPrepareSubmitOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareSubmitOrderResponse>* PrepareAsyncPrepareSubmitOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>* AsyncPrepareCancelOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareCancelOrderResponse>* PrepareAsyncPrepareCancelOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>* AsyncPrepareAmendOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareAmendOrderResponse>* PrepareAsyncPrepareAmendOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>* AsyncPrepareWithdrawRaw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareWithdrawResponse>* PrepareAsyncPrepareWithdrawRaw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>* AsyncSubmitTransactionRaw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionResponse>* PrepareAsyncSubmitTransactionRaw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>* AsyncSubmitTransactionV2Raw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::SubmitTransactionV2Response>* PrepareAsyncSubmitTransactionV2Raw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>* AsyncPrepareProposalSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareProposalSubmissionResponse>* PrepareAsyncPrepareProposalSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>* AsyncPrepareVoteSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareVoteSubmissionResponse>* PrepareAsyncPrepareVoteSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>* AsyncPropagateChainEventRaw(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PropagateChainEventResponse>* PrepareAsyncPropagateChainEventRaw(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>* AsyncPrepareLiquidityProvisionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PrepareLiquidityProvisionResponse>* PrepareAsyncPrepareLiquidityProvisionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::api::v1::PrepareSubmitOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>> AsyncPrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>>(AsyncPrepareSubmitOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>> PrepareAsyncPrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>>(PrepareAsyncPrepareSubmitOrderRaw(context, request, cq));
    }
    ::grpc::Status PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::api::v1::PrepareCancelOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>> AsyncPrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>>(AsyncPrepareCancelOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>> PrepareAsyncPrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>>(PrepareAsyncPrepareCancelOrderRaw(context, request, cq));
    }
    ::grpc::Status PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::api::v1::PrepareAmendOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>> AsyncPrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>>(AsyncPrepareAmendOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>> PrepareAsyncPrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>>(PrepareAsyncPrepareAmendOrderRaw(context, request, cq));
    }
    ::grpc::Status PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::api::v1::PrepareWithdrawResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>> AsyncPrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>>(AsyncPrepareWithdrawRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>> PrepareAsyncPrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>>(PrepareAsyncPrepareWithdrawRaw(context, request, cq));
    }
    ::grpc::Status SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::api::v1::SubmitTransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>> AsyncSubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>>(AsyncSubmitTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>> PrepareAsyncSubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>>(PrepareAsyncSubmitTransactionRaw(context, request, cq));
    }
    ::grpc::Status SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::api::v1::SubmitTransactionV2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>> AsyncSubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>>(AsyncSubmitTransactionV2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>> PrepareAsyncSubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>>(PrepareAsyncSubmitTransactionV2Raw(context, request, cq));
    }
    ::grpc::Status PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::api::v1::PrepareProposalSubmissionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>> AsyncPrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>>(AsyncPrepareProposalSubmissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>> PrepareAsyncPrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>>(PrepareAsyncPrepareProposalSubmissionRaw(context, request, cq));
    }
    ::grpc::Status PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::api::v1::PrepareVoteSubmissionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>> AsyncPrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>>(AsyncPrepareVoteSubmissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>> PrepareAsyncPrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>>(PrepareAsyncPrepareVoteSubmissionRaw(context, request, cq));
    }
    ::grpc::Status PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::api::v1::PropagateChainEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>> AsyncPropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>>(AsyncPropagateChainEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>> PrepareAsyncPropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>>(PrepareAsyncPropagateChainEventRaw(context, request, cq));
    }
    ::grpc::Status PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::api::v1::PrepareLiquidityProvisionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>> AsyncPrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>>(AsyncPrepareLiquidityProvisionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>> PrepareAsyncPrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>>(PrepareAsyncPrepareLiquidityProvisionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareSubmitOrder(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareCancelOrder(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareAmendOrder(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareWithdraw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SubmitTransaction(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SubmitTransactionV2(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareProposalSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareVoteSubmission(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PropagateChainEvent(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareLiquidityProvision(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>* AsyncPrepareSubmitOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareSubmitOrderResponse>* PrepareAsyncPrepareSubmitOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareSubmitOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>* AsyncPrepareCancelOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareCancelOrderResponse>* PrepareAsyncPrepareCancelOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareCancelOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>* AsyncPrepareAmendOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareAmendOrderResponse>* PrepareAsyncPrepareAmendOrderRaw(::grpc::ClientContext* context, const ::api::v1::PrepareAmendOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>* AsyncPrepareWithdrawRaw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareWithdrawResponse>* PrepareAsyncPrepareWithdrawRaw(::grpc::ClientContext* context, const ::api::v1::PrepareWithdrawRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>* AsyncSubmitTransactionRaw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionResponse>* PrepareAsyncSubmitTransactionRaw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>* AsyncSubmitTransactionV2Raw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::SubmitTransactionV2Response>* PrepareAsyncSubmitTransactionV2Raw(::grpc::ClientContext* context, const ::api::v1::SubmitTransactionV2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>* AsyncPrepareProposalSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareProposalSubmissionResponse>* PrepareAsyncPrepareProposalSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareProposalSubmissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>* AsyncPrepareVoteSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareVoteSubmissionResponse>* PrepareAsyncPrepareVoteSubmissionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareVoteSubmissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>* AsyncPropagateChainEventRaw(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PropagateChainEventResponse>* PrepareAsyncPropagateChainEventRaw(::grpc::ClientContext* context, const ::api::v1::PropagateChainEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>* AsyncPrepareLiquidityProvisionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PrepareLiquidityProvisionResponse>* PrepareAsyncPrepareLiquidityProvisionRaw(::grpc::ClientContext* context, const ::api::v1::PrepareLiquidityProvisionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareSubmitOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareCancelOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareAmendOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareWithdraw_;
    const ::grpc::internal::RpcMethod rpcmethod_SubmitTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_SubmitTransactionV2_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareProposalSubmission_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareVoteSubmission_;
    const ::grpc::internal::RpcMethod rpcmethod_PropagateChainEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareLiquidityProvision_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Prepare a submit order request
    virtual ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response);
    // Prepare a cancel order request
    virtual ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response);
    // Prepare an amend order request
    virtual ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response);
    // Request a withdrawal
    virtual ::grpc::Status PrepareWithdraw(::grpc::ServerContext* context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response);
    // Submit a signed transaction
    virtual ::grpc::Status SubmitTransaction(::grpc::ServerContext* context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response);
    // Submit a signed transaction (v2)
    virtual ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response);
    // Prepare a governance proposal
    virtual ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response);
    // Prepare a governance vote
    virtual ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response);
    // Propagate a chain event
    virtual ::grpc::Status PropagateChainEvent(::grpc::ServerContext* context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response);
    // Prepare a liquidity provision request
    virtual ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareSubmitOrder() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareSubmitOrder(::grpc::ServerContext* context, ::api::v1::PrepareSubmitOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareSubmitOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareCancelOrder() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareCancelOrder(::grpc::ServerContext* context, ::api::v1::PrepareCancelOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareCancelOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareAmendOrder() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareAmendOrder(::grpc::ServerContext* context, ::api::v1::PrepareAmendOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareAmendOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareWithdraw() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareWithdraw(::grpc::ServerContext* context, ::api::v1::PrepareWithdrawRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareWithdrawResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubmitTransaction() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitTransaction(::grpc::ServerContext* context, ::api::v1::SubmitTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::SubmitTransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubmitTransactionV2() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitTransactionV2(::grpc::ServerContext* context, ::api::v1::SubmitTransactionV2Request* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::SubmitTransactionV2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareProposalSubmission() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareProposalSubmission(::grpc::ServerContext* context, ::api::v1::PrepareProposalSubmissionRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareProposalSubmissionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareVoteSubmission() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareVoteSubmission(::grpc::ServerContext* context, ::api::v1::PrepareVoteSubmissionRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareVoteSubmissionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PropagateChainEvent() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPropagateChainEvent(::grpc::ServerContext* context, ::api::v1::PropagateChainEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PropagateChainEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareLiquidityProvision() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareLiquidityProvision(::grpc::ServerContext* context, ::api::v1::PrepareLiquidityProvisionRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PrepareLiquidityProvisionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PrepareSubmitOrder<WithAsyncMethod_PrepareCancelOrder<WithAsyncMethod_PrepareAmendOrder<WithAsyncMethod_PrepareWithdraw<WithAsyncMethod_SubmitTransaction<WithAsyncMethod_SubmitTransactionV2<WithAsyncMethod_PrepareProposalSubmission<WithAsyncMethod_PrepareVoteSubmission<WithAsyncMethod_PropagateChainEvent<WithAsyncMethod_PrepareLiquidityProvision<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareSubmitOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareSubmitOrderRequest, ::api::v1::PrepareSubmitOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareSubmitOrderRequest* request, ::api::v1::PrepareSubmitOrderResponse* response) { return this->PrepareSubmitOrder(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareSubmitOrder(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareSubmitOrderRequest, ::api::v1::PrepareSubmitOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareSubmitOrderRequest, ::api::v1::PrepareSubmitOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareSubmitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareSubmitOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareCancelOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareCancelOrderRequest, ::api::v1::PrepareCancelOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareCancelOrderRequest* request, ::api::v1::PrepareCancelOrderResponse* response) { return this->PrepareCancelOrder(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareCancelOrder(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareCancelOrderRequest, ::api::v1::PrepareCancelOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareCancelOrderRequest, ::api::v1::PrepareCancelOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareCancelOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareCancelOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareAmendOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareAmendOrderRequest, ::api::v1::PrepareAmendOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareAmendOrderRequest* request, ::api::v1::PrepareAmendOrderResponse* response) { return this->PrepareAmendOrder(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareAmendOrder(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareAmendOrderRequest, ::api::v1::PrepareAmendOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareAmendOrderRequest, ::api::v1::PrepareAmendOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareAmendOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareAmendOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareWithdrawRequest, ::api::v1::PrepareWithdrawResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareWithdrawRequest* request, ::api::v1::PrepareWithdrawResponse* response) { return this->PrepareWithdraw(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareWithdraw(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareWithdrawRequest, ::api::v1::PrepareWithdrawResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareWithdrawRequest, ::api::v1::PrepareWithdrawResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubmitTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::SubmitTransactionRequest, ::api::v1::SubmitTransactionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::SubmitTransactionRequest* request, ::api::v1::SubmitTransactionResponse* response) { return this->SubmitTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_SubmitTransaction(
        ::grpc::experimental::MessageAllocator< ::api::v1::SubmitTransactionRequest, ::api::v1::SubmitTransactionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::SubmitTransactionRequest, ::api::v1::SubmitTransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SubmitTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SubmitTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubmitTransactionV2() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::SubmitTransactionV2Request, ::api::v1::SubmitTransactionV2Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::SubmitTransactionV2Request* request, ::api::v1::SubmitTransactionV2Response* response) { return this->SubmitTransactionV2(context, request, response); }));}
    void SetMessageAllocatorFor_SubmitTransactionV2(
        ::grpc::experimental::MessageAllocator< ::api::v1::SubmitTransactionV2Request, ::api::v1::SubmitTransactionV2Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::SubmitTransactionV2Request, ::api::v1::SubmitTransactionV2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SubmitTransactionV2(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SubmitTransactionV2(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareProposalSubmission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareProposalSubmissionRequest, ::api::v1::PrepareProposalSubmissionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareProposalSubmissionRequest* request, ::api::v1::PrepareProposalSubmissionResponse* response) { return this->PrepareProposalSubmission(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareProposalSubmission(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareProposalSubmissionRequest, ::api::v1::PrepareProposalSubmissionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareProposalSubmissionRequest, ::api::v1::PrepareProposalSubmissionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareProposalSubmission(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareProposalSubmission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareVoteSubmission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareVoteSubmissionRequest, ::api::v1::PrepareVoteSubmissionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareVoteSubmissionRequest* request, ::api::v1::PrepareVoteSubmissionResponse* response) { return this->PrepareVoteSubmission(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareVoteSubmission(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareVoteSubmissionRequest, ::api::v1::PrepareVoteSubmissionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareVoteSubmissionRequest, ::api::v1::PrepareVoteSubmissionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareVoteSubmission(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareVoteSubmission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PropagateChainEvent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PropagateChainEventRequest, ::api::v1::PropagateChainEventResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PropagateChainEventRequest* request, ::api::v1::PropagateChainEventResponse* response) { return this->PropagateChainEvent(context, request, response); }));}
    void SetMessageAllocatorFor_PropagateChainEvent(
        ::grpc::experimental::MessageAllocator< ::api::v1::PropagateChainEventRequest, ::api::v1::PropagateChainEventResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PropagateChainEventRequest, ::api::v1::PropagateChainEventResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PropagateChainEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PropagateChainEvent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareLiquidityProvision() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareLiquidityProvisionRequest, ::api::v1::PrepareLiquidityProvisionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PrepareLiquidityProvisionRequest* request, ::api::v1::PrepareLiquidityProvisionResponse* response) { return this->PrepareLiquidityProvision(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareLiquidityProvision(
        ::grpc::experimental::MessageAllocator< ::api::v1::PrepareLiquidityProvisionRequest, ::api::v1::PrepareLiquidityProvisionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PrepareLiquidityProvisionRequest, ::api::v1::PrepareLiquidityProvisionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareLiquidityProvision(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareLiquidityProvision(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_PrepareSubmitOrder<ExperimentalWithCallbackMethod_PrepareCancelOrder<ExperimentalWithCallbackMethod_PrepareAmendOrder<ExperimentalWithCallbackMethod_PrepareWithdraw<ExperimentalWithCallbackMethod_SubmitTransaction<ExperimentalWithCallbackMethod_SubmitTransactionV2<ExperimentalWithCallbackMethod_PrepareProposalSubmission<ExperimentalWithCallbackMethod_PrepareVoteSubmission<ExperimentalWithCallbackMethod_PropagateChainEvent<ExperimentalWithCallbackMethod_PrepareLiquidityProvision<Service > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_PrepareSubmitOrder<ExperimentalWithCallbackMethod_PrepareCancelOrder<ExperimentalWithCallbackMethod_PrepareAmendOrder<ExperimentalWithCallbackMethod_PrepareWithdraw<ExperimentalWithCallbackMethod_SubmitTransaction<ExperimentalWithCallbackMethod_SubmitTransactionV2<ExperimentalWithCallbackMethod_PrepareProposalSubmission<ExperimentalWithCallbackMethod_PrepareVoteSubmission<ExperimentalWithCallbackMethod_PropagateChainEvent<ExperimentalWithCallbackMethod_PrepareLiquidityProvision<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareSubmitOrder() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareCancelOrder() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareAmendOrder() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareWithdraw() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubmitTransaction() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubmitTransactionV2() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareProposalSubmission() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareVoteSubmission() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PropagateChainEvent() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareLiquidityProvision() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareSubmitOrder() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareSubmitOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareCancelOrder() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareCancelOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareAmendOrder() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareAmendOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareWithdraw() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareWithdraw(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubmitTransaction() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubmitTransactionV2() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubmitTransactionV2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareProposalSubmission() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareProposalSubmission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareVoteSubmission() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareVoteSubmission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PropagateChainEvent() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPropagateChainEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareLiquidityProvision() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareLiquidityProvision(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareSubmitOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareSubmitOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareSubmitOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareSubmitOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareCancelOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareCancelOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareCancelOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareCancelOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareAmendOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareAmendOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareAmendOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareAmendOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareWithdraw() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareWithdraw(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareWithdraw(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareWithdraw(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubmitTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubmitTransaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SubmitTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SubmitTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubmitTransactionV2() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SubmitTransactionV2(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SubmitTransactionV2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SubmitTransactionV2(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareProposalSubmission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareProposalSubmission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareProposalSubmission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareProposalSubmission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareVoteSubmission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareVoteSubmission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareVoteSubmission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareVoteSubmission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PropagateChainEvent() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PropagateChainEvent(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PropagateChainEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PropagateChainEvent(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareLiquidityProvision() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareLiquidityProvision(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareLiquidityProvision(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareLiquidityProvision(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareSubmitOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareSubmitOrder() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareSubmitOrderRequest, ::api::v1::PrepareSubmitOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareSubmitOrderRequest, ::api::v1::PrepareSubmitOrderResponse>* streamer) {
                       return this->StreamedPrepareSubmitOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareSubmitOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareSubmitOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareSubmitOrderRequest* /*request*/, ::api::v1::PrepareSubmitOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareSubmitOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareSubmitOrderRequest,::api::v1::PrepareSubmitOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareCancelOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareCancelOrder() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareCancelOrderRequest, ::api::v1::PrepareCancelOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareCancelOrderRequest, ::api::v1::PrepareCancelOrderResponse>* streamer) {
                       return this->StreamedPrepareCancelOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareCancelOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareCancelOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareCancelOrderRequest* /*request*/, ::api::v1::PrepareCancelOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareCancelOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareCancelOrderRequest,::api::v1::PrepareCancelOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareAmendOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareAmendOrder() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareAmendOrderRequest, ::api::v1::PrepareAmendOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareAmendOrderRequest, ::api::v1::PrepareAmendOrderResponse>* streamer) {
                       return this->StreamedPrepareAmendOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareAmendOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareAmendOrder(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareAmendOrderRequest* /*request*/, ::api::v1::PrepareAmendOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareAmendOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareAmendOrderRequest,::api::v1::PrepareAmendOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareWithdraw : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareWithdraw() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareWithdrawRequest, ::api::v1::PrepareWithdrawResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareWithdrawRequest, ::api::v1::PrepareWithdrawResponse>* streamer) {
                       return this->StreamedPrepareWithdraw(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareWithdraw() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareWithdraw(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareWithdrawRequest* /*request*/, ::api::v1::PrepareWithdrawResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareWithdraw(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareWithdrawRequest,::api::v1::PrepareWithdrawResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubmitTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubmitTransaction() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::SubmitTransactionRequest, ::api::v1::SubmitTransactionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::SubmitTransactionRequest, ::api::v1::SubmitTransactionResponse>* streamer) {
                       return this->StreamedSubmitTransaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubmitTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubmitTransaction(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionRequest* /*request*/, ::api::v1::SubmitTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubmitTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::SubmitTransactionRequest,::api::v1::SubmitTransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SubmitTransactionV2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SubmitTransactionV2() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::SubmitTransactionV2Request, ::api::v1::SubmitTransactionV2Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::SubmitTransactionV2Request, ::api::v1::SubmitTransactionV2Response>* streamer) {
                       return this->StreamedSubmitTransactionV2(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SubmitTransactionV2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubmitTransactionV2(::grpc::ServerContext* /*context*/, const ::api::v1::SubmitTransactionV2Request* /*request*/, ::api::v1::SubmitTransactionV2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSubmitTransactionV2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::SubmitTransactionV2Request,::api::v1::SubmitTransactionV2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareProposalSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareProposalSubmission() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareProposalSubmissionRequest, ::api::v1::PrepareProposalSubmissionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareProposalSubmissionRequest, ::api::v1::PrepareProposalSubmissionResponse>* streamer) {
                       return this->StreamedPrepareProposalSubmission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareProposalSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareProposalSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareProposalSubmissionRequest* /*request*/, ::api::v1::PrepareProposalSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareProposalSubmission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareProposalSubmissionRequest,::api::v1::PrepareProposalSubmissionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareVoteSubmission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareVoteSubmission() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareVoteSubmissionRequest, ::api::v1::PrepareVoteSubmissionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareVoteSubmissionRequest, ::api::v1::PrepareVoteSubmissionResponse>* streamer) {
                       return this->StreamedPrepareVoteSubmission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareVoteSubmission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareVoteSubmission(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareVoteSubmissionRequest* /*request*/, ::api::v1::PrepareVoteSubmissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareVoteSubmission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareVoteSubmissionRequest,::api::v1::PrepareVoteSubmissionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PropagateChainEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PropagateChainEvent() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PropagateChainEventRequest, ::api::v1::PropagateChainEventResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PropagateChainEventRequest, ::api::v1::PropagateChainEventResponse>* streamer) {
                       return this->StreamedPropagateChainEvent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PropagateChainEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PropagateChainEvent(::grpc::ServerContext* /*context*/, const ::api::v1::PropagateChainEventRequest* /*request*/, ::api::v1::PropagateChainEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPropagateChainEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PropagateChainEventRequest,::api::v1::PropagateChainEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareLiquidityProvision : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareLiquidityProvision() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PrepareLiquidityProvisionRequest, ::api::v1::PrepareLiquidityProvisionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PrepareLiquidityProvisionRequest, ::api::v1::PrepareLiquidityProvisionResponse>* streamer) {
                       return this->StreamedPrepareLiquidityProvision(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareLiquidityProvision() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareLiquidityProvision(::grpc::ServerContext* /*context*/, const ::api::v1::PrepareLiquidityProvisionRequest* /*request*/, ::api::v1::PrepareLiquidityProvisionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareLiquidityProvision(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PrepareLiquidityProvisionRequest,::api::v1::PrepareLiquidityProvisionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PrepareSubmitOrder<WithStreamedUnaryMethod_PrepareCancelOrder<WithStreamedUnaryMethod_PrepareAmendOrder<WithStreamedUnaryMethod_PrepareWithdraw<WithStreamedUnaryMethod_SubmitTransaction<WithStreamedUnaryMethod_SubmitTransactionV2<WithStreamedUnaryMethod_PrepareProposalSubmission<WithStreamedUnaryMethod_PrepareVoteSubmission<WithStreamedUnaryMethod_PropagateChainEvent<WithStreamedUnaryMethod_PrepareLiquidityProvision<Service > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PrepareSubmitOrder<WithStreamedUnaryMethod_PrepareCancelOrder<WithStreamedUnaryMethod_PrepareAmendOrder<WithStreamedUnaryMethod_PrepareWithdraw<WithStreamedUnaryMethod_SubmitTransaction<WithStreamedUnaryMethod_SubmitTransactionV2<WithStreamedUnaryMethod_PrepareProposalSubmission<WithStreamedUnaryMethod_PrepareVoteSubmission<WithStreamedUnaryMethod_PropagateChainEvent<WithStreamedUnaryMethod_PrepareLiquidityProvision<Service > > > > > > > > > > StreamedService;
};

class TradingDataService final {
 public:
  static constexpr char const* service_full_name() {
    return "api.v1.TradingDataService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // -- Accounts --
    //
    // Get a list of Accounts by Market
    virtual ::grpc::Status MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::api::v1::MarketAccountsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>> AsyncMarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>>(AsyncMarketAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>> PrepareAsyncMarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>>(PrepareAsyncMarketAccountsRaw(context, request, cq));
    }
    // Get a list of Accounts by Party
    virtual ::grpc::Status PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::api::v1::PartyAccountsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>> AsyncPartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>>(AsyncPartyAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>> PrepareAsyncPartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>>(PrepareAsyncPartyAccountsRaw(context, request, cq));
    }
    // Get a list of accounts holding infrastructure fees.
    // Can be filtered by asset, there will be 1 infrastructure fee account per
    // asset in the network.
    virtual ::grpc::Status FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::api::v1::FeeInfrastructureAccountsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>> AsyncFeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>>(AsyncFeeInfrastructureAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>> PrepareAsyncFeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>>(PrepareAsyncFeeInfrastructureAccountsRaw(context, request, cq));
    }
    // -- Candles --
    //
    // Get a list of Candles by Market
    virtual ::grpc::Status Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::api::v1::CandlesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>> AsyncCandles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>>(AsyncCandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>> PrepareAsyncCandles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>>(PrepareAsyncCandlesRaw(context, request, cq));
    }
    // -- Market Data --
    //
    // Get Market Data by Market ID
    virtual ::grpc::Status MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::api::v1::MarketDataByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>> AsyncMarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>>(AsyncMarketDataByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>> PrepareAsyncMarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>>(PrepareAsyncMarketDataByIDRaw(context, request, cq));
    }
    // Get a list of Market Data
    virtual ::grpc::Status MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::api::v1::MarketsDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>> AsyncMarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>>(AsyncMarketsDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>> PrepareAsyncMarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>>(PrepareAsyncMarketsDataRaw(context, request, cq));
    }
    // -- Markets --
    //
    // Get a Market by ID
    virtual ::grpc::Status MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::api::v1::MarketByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>> AsyncMarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>>(AsyncMarketByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>> PrepareAsyncMarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>>(PrepareAsyncMarketByIDRaw(context, request, cq));
    }
    // Get Market Depth
    virtual ::grpc::Status MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::api::v1::MarketDepthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>> AsyncMarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>>(AsyncMarketDepthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>> PrepareAsyncMarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>>(PrepareAsyncMarketDepthRaw(context, request, cq));
    }
    // Get a list of Markets
    virtual ::grpc::Status Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::api::v1::MarketsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>> AsyncMarkets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>>(AsyncMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>> PrepareAsyncMarkets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>>(PrepareAsyncMarketsRaw(context, request, cq));
    }
    // -- Orders --
    //
    // Get an Order by Market and Order ID
    virtual ::grpc::Status OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::api::v1::OrderByMarketAndIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>> AsyncOrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>>(AsyncOrderByMarketAndIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>> PrepareAsyncOrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>>(PrepareAsyncOrderByMarketAndIDRaw(context, request, cq));
    }
    // Get an Order by Pending Order reference (UUID)
    virtual ::grpc::Status OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::api::v1::OrderByReferenceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>> AsyncOrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>>(AsyncOrderByReferenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>> PrepareAsyncOrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>>(PrepareAsyncOrderByReferenceRaw(context, request, cq));
    }
    // Get a list of Orders by Market
    virtual ::grpc::Status OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::api::v1::OrdersByMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>> AsyncOrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>>(AsyncOrdersByMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>> PrepareAsyncOrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>>(PrepareAsyncOrdersByMarketRaw(context, request, cq));
    }
    // Get a list of Orders by Party
    virtual ::grpc::Status OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::api::v1::OrdersByPartyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>> AsyncOrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>>(AsyncOrdersByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>> PrepareAsyncOrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>>(PrepareAsyncOrdersByPartyRaw(context, request, cq));
    }
    // Get a specific order by order ID
    virtual ::grpc::Status OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::api::v1::OrderByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>> AsyncOrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>>(AsyncOrderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>> PrepareAsyncOrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>>(PrepareAsyncOrderByIDRaw(context, request, cq));
    }
    // Get all versions of the order by its orderID
    virtual ::grpc::Status OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::api::v1::OrderVersionsByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>> AsyncOrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>>(AsyncOrderVersionsByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>> PrepareAsyncOrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>>(PrepareAsyncOrderVersionsByIDRaw(context, request, cq));
    }
    // -- Parties --
    //
    // Get Margin Levels by Party ID
    virtual ::grpc::Status MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::api::v1::MarginLevelsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>> AsyncMarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>>(AsyncMarginLevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>> PrepareAsyncMarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>>(PrepareAsyncMarginLevelsRaw(context, request, cq));
    }
    // Get a list of Parties
    virtual ::grpc::Status Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::api::v1::PartiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>> AsyncParties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>>(AsyncPartiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>> PrepareAsyncParties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>>(PrepareAsyncPartiesRaw(context, request, cq));
    }
    // Get a Party by ID
    virtual ::grpc::Status PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::api::v1::PartyByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>> AsyncPartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>>(AsyncPartyByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>> PrepareAsyncPartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>>(PrepareAsyncPartyByIDRaw(context, request, cq));
    }
    // -- Positions --
    //
    // Get a list of Positions by Party
    virtual ::grpc::Status PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::api::v1::PositionsByPartyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>> AsyncPositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>>(AsyncPositionsByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>> PrepareAsyncPositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>>(PrepareAsyncPositionsByPartyRaw(context, request, cq));
    }
    // -- Trades --
    //
    // Get latest Trade
    virtual ::grpc::Status LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::api::v1::LastTradeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>> AsyncLastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>>(AsyncLastTradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>> PrepareAsyncLastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>>(PrepareAsyncLastTradeRaw(context, request, cq));
    }
    // Get a list of Trades by Market
    virtual ::grpc::Status TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::api::v1::TradesByMarketResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>> AsyncTradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>>(AsyncTradesByMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>> PrepareAsyncTradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>>(PrepareAsyncTradesByMarketRaw(context, request, cq));
    }
    // Get a list of Trades by Order
    virtual ::grpc::Status TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::api::v1::TradesByOrderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>> AsyncTradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>>(AsyncTradesByOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>> PrepareAsyncTradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>>(PrepareAsyncTradesByOrderRaw(context, request, cq));
    }
    // Get a list of Trades by Party
    virtual ::grpc::Status TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::api::v1::TradesByPartyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>> AsyncTradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>>(AsyncTradesByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>> PrepareAsyncTradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>>(PrepareAsyncTradesByPartyRaw(context, request, cq));
    }
    // -- Governance --
    //
    // Get governance data (proposals and votes) for all proposals
    virtual ::grpc::Status GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::api::v1::GetProposalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>> AsyncGetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>>(AsyncGetProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>> PrepareAsyncGetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>>(PrepareAsyncGetProposalsRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for proposals by party authoring them
    virtual ::grpc::Status GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::api::v1::GetProposalsByPartyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>> AsyncGetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>>(AsyncGetProposalsByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>> PrepareAsyncGetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>>(PrepareAsyncGetProposalsByPartyRaw(context, request, cq));
    }
    // Get votes by party casting them
    virtual ::grpc::Status GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::api::v1::GetVotesByPartyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>> AsyncGetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>>(AsyncGetVotesByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>> PrepareAsyncGetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>>(PrepareAsyncGetVotesByPartyRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for proposals that aim creating new markets
    virtual ::grpc::Status GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::api::v1::GetNewMarketProposalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>> AsyncGetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>>(AsyncGetNewMarketProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>> PrepareAsyncGetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>>(PrepareAsyncGetNewMarketProposalsRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for proposals that aim updating markets
    virtual ::grpc::Status GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::api::v1::GetUpdateMarketProposalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>> AsyncGetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>>(AsyncGetUpdateMarketProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>> PrepareAsyncGetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>>(PrepareAsyncGetUpdateMarketProposalsRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
    virtual ::grpc::Status GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::api::v1::GetNetworkParametersProposalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>> AsyncGetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>>(AsyncGetNetworkParametersProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>> PrepareAsyncGetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>>(PrepareAsyncGetNetworkParametersProposalsRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for proposals aiming to create new assets
    virtual ::grpc::Status GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::api::v1::GetNewAssetProposalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>> AsyncGetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>>(AsyncGetNewAssetProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>> PrepareAsyncGetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>>(PrepareAsyncGetNewAssetProposalsRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for a proposal located by ID
    virtual ::grpc::Status GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::api::v1::GetProposalByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>> AsyncGetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>>(AsyncGetProposalByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>> PrepareAsyncGetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>>(PrepareAsyncGetProposalByIDRaw(context, request, cq));
    }
    // Get governance data (proposals and votes) for a proposal located by reference
    virtual ::grpc::Status GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::api::v1::GetProposalByReferenceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>> AsyncGetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>>(AsyncGetProposalByReferenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>> PrepareAsyncGetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>>(PrepareAsyncGetProposalByReferenceRaw(context, request, cq));
    }
    // Subscribe to a stream of all governance updates
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObserveGovernanceResponse>> ObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObserveGovernanceResponse>>(ObserveGovernanceRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>> AsyncObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>>(AsyncObserveGovernanceRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>> PrepareAsyncObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>>(PrepareAsyncObserveGovernanceRaw(context, request, cq));
    }
    // Subscribe to a stream of proposal updates
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObservePartyProposalsResponse>> ObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObservePartyProposalsResponse>>(ObservePartyProposalsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>> AsyncObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>>(AsyncObservePartyProposalsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>> PrepareAsyncObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>>(PrepareAsyncObservePartyProposalsRaw(context, request, cq));
    }
    // Subscribe to a stream of votes cast by a specific party
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObservePartyVotesResponse>> ObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObservePartyVotesResponse>>(ObservePartyVotesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>> AsyncObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>>(AsyncObservePartyVotesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>> PrepareAsyncObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>>(PrepareAsyncObservePartyVotesRaw(context, request, cq));
    }
    // Subscribe to a stream of proposal votes
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObserveProposalVotesResponse>> ObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::ObserveProposalVotesResponse>>(ObserveProposalVotesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>> AsyncObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>>(AsyncObserveProposalVotesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>> PrepareAsyncObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>>(PrepareAsyncObserveProposalVotesRaw(context, request, cq));
    }
    // Subscribe to a stream of events from the core
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> ObserveEventBus(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(ObserveEventBusRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> AsyncObserveEventBus(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(AsyncObserveEventBusRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> PrepareAsyncObserveEventBus(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(PrepareAsyncObserveEventBusRaw(context, cq));
    }
    // -- Misc --
    //
    // Get Statistics on Vega
    virtual ::grpc::Status Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::api::v1::StatisticsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>> AsyncStatistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>>(AsyncStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>> PrepareAsyncStatistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>>(PrepareAsyncStatisticsRaw(context, request, cq));
    }
    virtual ::grpc::Status LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::api::v1::LastBlockHeightResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>> AsyncLastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>>(AsyncLastBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>> PrepareAsyncLastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>>(PrepareAsyncLastBlockHeightRaw(context, request, cq));
    }
    // Get Time
    virtual ::grpc::Status GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::api::v1::GetVegaTimeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>> AsyncGetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>>(AsyncGetVegaTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>> PrepareAsyncGetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>>(PrepareAsyncGetVegaTimeRaw(context, request, cq));
    }
    // Subscribe to a stream of Accounts
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::AccountsSubscribeResponse>> AccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::AccountsSubscribeResponse>>(AccountsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>> AsyncAccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>>(AsyncAccountsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>> PrepareAsyncAccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>>(PrepareAsyncAccountsSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Candles
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::CandlesSubscribeResponse>> CandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::CandlesSubscribeResponse>>(CandlesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>> AsyncCandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>>(AsyncCandlesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>> PrepareAsyncCandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>>(PrepareAsyncCandlesSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Margin Levels
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>> MarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>>(MarginLevelsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>> AsyncMarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>>(AsyncMarginLevelsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>> PrepareAsyncMarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>>(PrepareAsyncMarginLevelsSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Market Depth
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketDepthSubscribeResponse>> MarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketDepthSubscribeResponse>>(MarketDepthSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>> AsyncMarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>>(AsyncMarketDepthSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>> PrepareAsyncMarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>>(PrepareAsyncMarketDepthSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Market Depth Price Level Updates
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>> MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(MarketDepthUpdatesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>> AsyncMarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(AsyncMarketDepthUpdatesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>> PrepareAsyncMarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(PrepareAsyncMarketDepthUpdatesSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Markets Data
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketsDataSubscribeResponse>> MarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::MarketsDataSubscribeResponse>>(MarketsDataSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>> AsyncMarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>>(AsyncMarketsDataSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>> PrepareAsyncMarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>>(PrepareAsyncMarketsDataSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Orders
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::OrdersSubscribeResponse>> OrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::OrdersSubscribeResponse>>(OrdersSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>> AsyncOrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>>(AsyncOrdersSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>> PrepareAsyncOrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>>(PrepareAsyncOrdersSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Positions
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::PositionsSubscribeResponse>> PositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::PositionsSubscribeResponse>>(PositionsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>> AsyncPositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>>(AsyncPositionsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>> PrepareAsyncPositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>>(PrepareAsyncPositionsSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Trades
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::TradesSubscribeResponse>> TradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::TradesSubscribeResponse>>(TradesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>> AsyncTradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>>(AsyncTradesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>> PrepareAsyncTradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>>(PrepareAsyncTradesSubscribeRaw(context, request, cq));
    }
    // Subscribe to a stream of Transfer Responses
    std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>> TransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>>(TransferResponsesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>> AsyncTransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>>(AsyncTransferResponsesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>> PrepareAsyncTransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>>(PrepareAsyncTransferResponsesSubscribeRaw(context, request, cq));
    }
    // Get an aggregate of signatures from all the nodes of the network
    virtual ::grpc::Status GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::api::v1::GetNodeSignaturesAggregateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>> AsyncGetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>>(AsyncGetNodeSignaturesAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>> PrepareAsyncGetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>>(PrepareAsyncGetNodeSignaturesAggregateRaw(context, request, cq));
    }
    // Get an asset by its identifier
    virtual ::grpc::Status AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::api::v1::AssetByIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>> AsyncAssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>>(AsyncAssetByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>> PrepareAsyncAssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>>(PrepareAsyncAssetByIDRaw(context, request, cq));
    }
    // Get a list of all assets on Vega
    virtual ::grpc::Status Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::api::v1::AssetsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>> AsyncAssets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>>(AsyncAssetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>> PrepareAsyncAssets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>>(PrepareAsyncAssetsRaw(context, request, cq));
    }
    // Get an estimate for the fee to be paid for a given order
    virtual ::grpc::Status EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::api::v1::EstimateFeeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>> AsyncEstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>>(AsyncEstimateFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>> PrepareAsyncEstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>>(PrepareAsyncEstimateFeeRaw(context, request, cq));
    }
    // Get an estimate for the margin required for a new order
    virtual ::grpc::Status EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::api::v1::EstimateMarginResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>> AsyncEstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>>(AsyncEstimateMarginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>> PrepareAsyncEstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>>(PrepareAsyncEstimateMarginRaw(context, request, cq));
    }
    // Get the bundle approval for an ERC20 withdrawal,
    // these data are being used to bundle the call to the smart contract on the ethereum bridge
    virtual ::grpc::Status ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::api::v1::ERC20WithdrawalApprovalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>> AsyncERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>>(AsyncERC20WithdrawalApprovalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>> PrepareAsyncERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>>(PrepareAsyncERC20WithdrawalApprovalRaw(context, request, cq));
    }
    // Get a withdrawal by its identifier
    virtual ::grpc::Status Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::api::v1::WithdrawalResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>> AsyncWithdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>>(AsyncWithdrawalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>> PrepareAsyncWithdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>>(PrepareAsyncWithdrawalRaw(context, request, cq));
    }
    // Get withdrawals for a party
    virtual ::grpc::Status Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::api::v1::WithdrawalsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>> AsyncWithdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>>(AsyncWithdrawalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>> PrepareAsyncWithdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>>(PrepareAsyncWithdrawalsRaw(context, request, cq));
    }
    // Get a deposit by its identifier
    virtual ::grpc::Status Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::api::v1::DepositResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>> AsyncDeposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>>(AsyncDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>> PrepareAsyncDeposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>>(PrepareAsyncDepositRaw(context, request, cq));
    }
    // Get deposits for a party
    virtual ::grpc::Status Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::api::v1::DepositsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>> AsyncDeposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>>(AsyncDepositsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>> PrepareAsyncDeposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>>(PrepareAsyncDepositsRaw(context, request, cq));
    }
    // Get the network parameters
    virtual ::grpc::Status NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::api::v1::NetworkParametersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>> AsyncNetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>>(AsyncNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>> PrepareAsyncNetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>>(PrepareAsyncNetworkParametersRaw(context, request, cq));
    }
    // Get the liquidity provision orders
    virtual ::grpc::Status LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::api::v1::LiquidityProvisionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>> AsyncLiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>>(AsyncLiquidityProvisionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>> PrepareAsyncLiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>>(PrepareAsyncLiquidityProvisionsRaw(context, request, cq));
    }
    // Get an oracle spec by ID
    virtual ::grpc::Status OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::api::v1::OracleSpecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>> AsyncOracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>>(AsyncOracleSpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>> PrepareAsyncOracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>>(PrepareAsyncOracleSpecRaw(context, request, cq));
    }
    // Get the oracle specs
    virtual ::grpc::Status OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::api::v1::OracleSpecsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>> AsyncOracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>>(AsyncOracleSpecsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>> PrepareAsyncOracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>>(PrepareAsyncOracleSpecsRaw(context, request, cq));
    }
    // Get all oracle data
    virtual ::grpc::Status OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::api::v1::OracleDataBySpecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>> AsyncOracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>>(AsyncOracleDataBySpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>> PrepareAsyncOracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>>(PrepareAsyncOracleDataBySpecRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // -- Accounts --
      //
      // Get a list of Accounts by Market
      virtual void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Accounts by Party
      virtual void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of accounts holding infrastructure fees.
      // Can be filtered by asset, there will be 1 infrastructure fee account per
      // asset in the network.
      virtual void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Candles --
      //
      // Get a list of Candles by Market
      virtual void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Market Data --
      //
      // Get Market Data by Market ID
      virtual void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Market Data
      virtual void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Markets --
      //
      // Get a Market by ID
      virtual void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get Market Depth
      virtual void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Markets
      virtual void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Orders --
      //
      // Get an Order by Market and Order ID
      virtual void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get an Order by Pending Order reference (UUID)
      virtual void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Orders by Market
      virtual void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Orders by Party
      virtual void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a specific order by order ID
      virtual void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all versions of the order by its orderID
      virtual void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Parties --
      //
      // Get Margin Levels by Party ID
      virtual void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Parties
      virtual void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a Party by ID
      virtual void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Positions --
      //
      // Get a list of Positions by Party
      virtual void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Trades --
      //
      // Get latest Trade
      virtual void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Trades by Market
      virtual void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Trades by Order
      virtual void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of Trades by Party
      virtual void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // -- Governance --
      //
      // Get governance data (proposals and votes) for all proposals
      virtual void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for proposals by party authoring them
      virtual void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get votes by party casting them
      virtual void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for proposals that aim creating new markets
      virtual void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for proposals that aim updating markets
      virtual void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
      virtual void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for proposals aiming to create new assets
      virtual void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for a proposal located by ID
      virtual void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get governance data (proposals and votes) for a proposal located by reference
      virtual void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to a stream of all governance updates
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ObserveGovernance(::grpc::ClientContext* context, ::api::v1::ObserveGovernanceRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObserveGovernanceResponse>* reactor) = 0;
      #else
      virtual void ObserveGovernance(::grpc::ClientContext* context, ::api::v1::ObserveGovernanceRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObserveGovernanceResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of proposal updates
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ObservePartyProposals(::grpc::ClientContext* context, ::api::v1::ObservePartyProposalsRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObservePartyProposalsResponse>* reactor) = 0;
      #else
      virtual void ObservePartyProposals(::grpc::ClientContext* context, ::api::v1::ObservePartyProposalsRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObservePartyProposalsResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of votes cast by a specific party
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ObservePartyVotes(::grpc::ClientContext* context, ::api::v1::ObservePartyVotesRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObservePartyVotesResponse>* reactor) = 0;
      #else
      virtual void ObservePartyVotes(::grpc::ClientContext* context, ::api::v1::ObservePartyVotesRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObservePartyVotesResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of proposal votes
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ObserveProposalVotes(::grpc::ClientContext* context, ::api::v1::ObserveProposalVotesRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObserveProposalVotesResponse>* reactor) = 0;
      #else
      virtual void ObserveProposalVotes(::grpc::ClientContext* context, ::api::v1::ObserveProposalVotesRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObserveProposalVotesResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of events from the core
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ObserveEventBus(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::api::v1::ObserveEventBusRequest,::api::v1::ObserveEventBusResponse>* reactor) = 0;
      #else
      virtual void ObserveEventBus(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::api::v1::ObserveEventBusRequest,::api::v1::ObserveEventBusResponse>* reactor) = 0;
      #endif
      // -- Misc --
      //
      // Get Statistics on Vega
      virtual void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get Time
      virtual void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Subscribe to a stream of Accounts
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AccountsSubscribe(::grpc::ClientContext* context, ::api::v1::AccountsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::AccountsSubscribeResponse>* reactor) = 0;
      #else
      virtual void AccountsSubscribe(::grpc::ClientContext* context, ::api::v1::AccountsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::AccountsSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Candles
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CandlesSubscribe(::grpc::ClientContext* context, ::api::v1::CandlesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::CandlesSubscribeResponse>* reactor) = 0;
      #else
      virtual void CandlesSubscribe(::grpc::ClientContext* context, ::api::v1::CandlesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::CandlesSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Margin Levels
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarginLevelsSubscribe(::grpc::ClientContext* context, ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarginLevelsSubscribeResponse>* reactor) = 0;
      #else
      virtual void MarginLevelsSubscribe(::grpc::ClientContext* context, ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarginLevelsSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Market Depth
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketDepthSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketDepthSubscribeResponse>* reactor) = 0;
      #else
      virtual void MarketDepthSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketDepthSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Market Depth Price Level Updates
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* reactor) = 0;
      #else
      virtual void MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Markets Data
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MarketsDataSubscribe(::grpc::ClientContext* context, ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketsDataSubscribeResponse>* reactor) = 0;
      #else
      virtual void MarketsDataSubscribe(::grpc::ClientContext* context, ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketsDataSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Orders
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OrdersSubscribe(::grpc::ClientContext* context, ::api::v1::OrdersSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::OrdersSubscribeResponse>* reactor) = 0;
      #else
      virtual void OrdersSubscribe(::grpc::ClientContext* context, ::api::v1::OrdersSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::OrdersSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Positions
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PositionsSubscribe(::grpc::ClientContext* context, ::api::v1::PositionsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::PositionsSubscribeResponse>* reactor) = 0;
      #else
      virtual void PositionsSubscribe(::grpc::ClientContext* context, ::api::v1::PositionsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::PositionsSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Trades
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TradesSubscribe(::grpc::ClientContext* context, ::api::v1::TradesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::TradesSubscribeResponse>* reactor) = 0;
      #else
      virtual void TradesSubscribe(::grpc::ClientContext* context, ::api::v1::TradesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::TradesSubscribeResponse>* reactor) = 0;
      #endif
      // Subscribe to a stream of Transfer Responses
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TransferResponsesSubscribe(::grpc::ClientContext* context, ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::TransferResponsesSubscribeResponse>* reactor) = 0;
      #else
      virtual void TransferResponsesSubscribe(::grpc::ClientContext* context, ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::TransferResponsesSubscribeResponse>* reactor) = 0;
      #endif
      // Get an aggregate of signatures from all the nodes of the network
      virtual void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get an asset by its identifier
      virtual void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a list of all assets on Vega
      virtual void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get an estimate for the fee to be paid for a given order
      virtual void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get an estimate for the margin required for a new order
      virtual void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the bundle approval for an ERC20 withdrawal,
      // these data are being used to bundle the call to the smart contract on the ethereum bridge
      virtual void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a withdrawal by its identifier
      virtual void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get withdrawals for a party
      virtual void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get a deposit by its identifier
      virtual void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get deposits for a party
      virtual void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the network parameters
      virtual void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the liquidity provision orders
      virtual void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get an oracle spec by ID
      virtual void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the oracle specs
      virtual void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get all oracle data
      virtual void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>* AsyncMarketAccountsRaw(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketAccountsResponse>* PrepareAsyncMarketAccountsRaw(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>* AsyncPartyAccountsRaw(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyAccountsResponse>* PrepareAsyncPartyAccountsRaw(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>* AsyncFeeInfrastructureAccountsRaw(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::FeeInfrastructureAccountsResponse>* PrepareAsyncFeeInfrastructureAccountsRaw(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>* AsyncCandlesRaw(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::CandlesResponse>* PrepareAsyncCandlesRaw(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>* AsyncMarketDataByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDataByIDResponse>* PrepareAsyncMarketDataByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>* AsyncMarketsDataRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsDataResponse>* PrepareAsyncMarketsDataRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>* AsyncMarketByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketByIDResponse>* PrepareAsyncMarketByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>* AsyncMarketDepthRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketDepthResponse>* PrepareAsyncMarketDepthRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>* AsyncMarketsRaw(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarketsResponse>* PrepareAsyncMarketsRaw(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>* AsyncOrderByMarketAndIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByMarketAndIDResponse>* PrepareAsyncOrderByMarketAndIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>* AsyncOrderByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByReferenceResponse>* PrepareAsyncOrderByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>* AsyncOrdersByMarketRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByMarketResponse>* PrepareAsyncOrdersByMarketRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>* AsyncOrdersByPartyRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrdersByPartyResponse>* PrepareAsyncOrdersByPartyRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>* AsyncOrderByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderByIDResponse>* PrepareAsyncOrderByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>* AsyncOrderVersionsByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OrderVersionsByIDResponse>* PrepareAsyncOrderVersionsByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>* AsyncMarginLevelsRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::MarginLevelsResponse>* PrepareAsyncMarginLevelsRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>* AsyncPartiesRaw(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartiesResponse>* PrepareAsyncPartiesRaw(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>* AsyncPartyByIDRaw(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PartyByIDResponse>* PrepareAsyncPartyByIDRaw(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>* AsyncPositionsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::PositionsByPartyResponse>* PrepareAsyncPositionsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>* AsyncLastTradeRaw(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastTradeResponse>* PrepareAsyncLastTradeRaw(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>* AsyncTradesByMarketRaw(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByMarketResponse>* PrepareAsyncTradesByMarketRaw(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>* AsyncTradesByOrderRaw(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByOrderResponse>* PrepareAsyncTradesByOrderRaw(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>* AsyncTradesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::TradesByPartyResponse>* PrepareAsyncTradesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>* AsyncGetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsResponse>* PrepareAsyncGetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>* AsyncGetProposalsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalsByPartyResponse>* PrepareAsyncGetProposalsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>* AsyncGetVotesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVotesByPartyResponse>* PrepareAsyncGetVotesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>* AsyncGetNewMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewMarketProposalsResponse>* PrepareAsyncGetNewMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>* AsyncGetUpdateMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetUpdateMarketProposalsResponse>* PrepareAsyncGetUpdateMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>* AsyncGetNetworkParametersProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNetworkParametersProposalsResponse>* PrepareAsyncGetNetworkParametersProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>* AsyncGetNewAssetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNewAssetProposalsResponse>* PrepareAsyncGetNewAssetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>* AsyncGetProposalByIDRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByIDResponse>* PrepareAsyncGetProposalByIDRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>* AsyncGetProposalByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetProposalByReferenceResponse>* PrepareAsyncGetProposalByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::ObserveGovernanceResponse>* ObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>* AsyncObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveGovernanceResponse>* PrepareAsyncObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::ObservePartyProposalsResponse>* ObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>* AsyncObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyProposalsResponse>* PrepareAsyncObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::ObservePartyVotesResponse>* ObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>* AsyncObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObservePartyVotesResponse>* PrepareAsyncObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::ObserveProposalVotesResponse>* ObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>* AsyncObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::ObserveProposalVotesResponse>* PrepareAsyncObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* ObserveEventBusRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* AsyncObserveEventBusRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* PrepareAsyncObserveEventBusRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>* AsyncStatisticsRaw(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::StatisticsResponse>* PrepareAsyncStatisticsRaw(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>* AsyncLastBlockHeightRaw(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LastBlockHeightResponse>* PrepareAsyncLastBlockHeightRaw(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>* AsyncGetVegaTimeRaw(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetVegaTimeResponse>* PrepareAsyncGetVegaTimeRaw(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::AccountsSubscribeResponse>* AccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>* AsyncAccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::AccountsSubscribeResponse>* PrepareAsyncAccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::CandlesSubscribeResponse>* CandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>* AsyncCandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::CandlesSubscribeResponse>* PrepareAsyncCandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>* MarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>* AsyncMarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarginLevelsSubscribeResponse>* PrepareAsyncMarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::MarketDepthSubscribeResponse>* MarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>* AsyncMarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthSubscribeResponse>* PrepareAsyncMarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>* MarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>* AsyncMarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketDepthUpdatesSubscribeResponse>* PrepareAsyncMarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::MarketsDataSubscribeResponse>* MarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>* AsyncMarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::MarketsDataSubscribeResponse>* PrepareAsyncMarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::OrdersSubscribeResponse>* OrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>* AsyncOrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::OrdersSubscribeResponse>* PrepareAsyncOrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::PositionsSubscribeResponse>* PositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>* AsyncPositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::PositionsSubscribeResponse>* PrepareAsyncPositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::TradesSubscribeResponse>* TradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>* AsyncTradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::TradesSubscribeResponse>* PrepareAsyncTradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>* TransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>* AsyncTransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::api::v1::TransferResponsesSubscribeResponse>* PrepareAsyncTransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>* AsyncGetNodeSignaturesAggregateRaw(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::GetNodeSignaturesAggregateResponse>* PrepareAsyncGetNodeSignaturesAggregateRaw(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>* AsyncAssetByIDRaw(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetByIDResponse>* PrepareAsyncAssetByIDRaw(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>* AsyncAssetsRaw(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::AssetsResponse>* PrepareAsyncAssetsRaw(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>* AsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateFeeResponse>* PrepareAsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>* AsyncEstimateMarginRaw(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::EstimateMarginResponse>* PrepareAsyncEstimateMarginRaw(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>* AsyncERC20WithdrawalApprovalRaw(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::ERC20WithdrawalApprovalResponse>* PrepareAsyncERC20WithdrawalApprovalRaw(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>* AsyncWithdrawalRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalResponse>* PrepareAsyncWithdrawalRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>* AsyncWithdrawalsRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::WithdrawalsResponse>* PrepareAsyncWithdrawalsRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>* AsyncDepositRaw(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositResponse>* PrepareAsyncDepositRaw(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>* AsyncDepositsRaw(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::DepositsResponse>* PrepareAsyncDepositsRaw(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>* AsyncNetworkParametersRaw(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::NetworkParametersResponse>* PrepareAsyncNetworkParametersRaw(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>* AsyncLiquidityProvisionsRaw(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::LiquidityProvisionsResponse>* PrepareAsyncLiquidityProvisionsRaw(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>* AsyncOracleSpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecResponse>* PrepareAsyncOracleSpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>* AsyncOracleSpecsRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleSpecsResponse>* PrepareAsyncOracleSpecsRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>* AsyncOracleDataBySpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::api::v1::OracleDataBySpecResponse>* PrepareAsyncOracleDataBySpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::api::v1::MarketAccountsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>> AsyncMarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>>(AsyncMarketAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>> PrepareAsyncMarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>>(PrepareAsyncMarketAccountsRaw(context, request, cq));
    }
    ::grpc::Status PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::api::v1::PartyAccountsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>> AsyncPartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>>(AsyncPartyAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>> PrepareAsyncPartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>>(PrepareAsyncPartyAccountsRaw(context, request, cq));
    }
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::api::v1::FeeInfrastructureAccountsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>> AsyncFeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>>(AsyncFeeInfrastructureAccountsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>> PrepareAsyncFeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>>(PrepareAsyncFeeInfrastructureAccountsRaw(context, request, cq));
    }
    ::grpc::Status Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::api::v1::CandlesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>> AsyncCandles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>>(AsyncCandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>> PrepareAsyncCandles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>>(PrepareAsyncCandlesRaw(context, request, cq));
    }
    ::grpc::Status MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::api::v1::MarketDataByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>> AsyncMarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>>(AsyncMarketDataByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>> PrepareAsyncMarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>>(PrepareAsyncMarketDataByIDRaw(context, request, cq));
    }
    ::grpc::Status MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::api::v1::MarketsDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>> AsyncMarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>>(AsyncMarketsDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>> PrepareAsyncMarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>>(PrepareAsyncMarketsDataRaw(context, request, cq));
    }
    ::grpc::Status MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::api::v1::MarketByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>> AsyncMarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>>(AsyncMarketByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>> PrepareAsyncMarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>>(PrepareAsyncMarketByIDRaw(context, request, cq));
    }
    ::grpc::Status MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::api::v1::MarketDepthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>> AsyncMarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>>(AsyncMarketDepthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>> PrepareAsyncMarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>>(PrepareAsyncMarketDepthRaw(context, request, cq));
    }
    ::grpc::Status Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::api::v1::MarketsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>> AsyncMarkets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>>(AsyncMarketsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>> PrepareAsyncMarkets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>>(PrepareAsyncMarketsRaw(context, request, cq));
    }
    ::grpc::Status OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::api::v1::OrderByMarketAndIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>> AsyncOrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>>(AsyncOrderByMarketAndIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>> PrepareAsyncOrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>>(PrepareAsyncOrderByMarketAndIDRaw(context, request, cq));
    }
    ::grpc::Status OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::api::v1::OrderByReferenceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>> AsyncOrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>>(AsyncOrderByReferenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>> PrepareAsyncOrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>>(PrepareAsyncOrderByReferenceRaw(context, request, cq));
    }
    ::grpc::Status OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::api::v1::OrdersByMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>> AsyncOrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>>(AsyncOrdersByMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>> PrepareAsyncOrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>>(PrepareAsyncOrdersByMarketRaw(context, request, cq));
    }
    ::grpc::Status OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::api::v1::OrdersByPartyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>> AsyncOrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>>(AsyncOrdersByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>> PrepareAsyncOrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>>(PrepareAsyncOrdersByPartyRaw(context, request, cq));
    }
    ::grpc::Status OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::api::v1::OrderByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>> AsyncOrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>>(AsyncOrderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>> PrepareAsyncOrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>>(PrepareAsyncOrderByIDRaw(context, request, cq));
    }
    ::grpc::Status OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::api::v1::OrderVersionsByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>> AsyncOrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>>(AsyncOrderVersionsByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>> PrepareAsyncOrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>>(PrepareAsyncOrderVersionsByIDRaw(context, request, cq));
    }
    ::grpc::Status MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::api::v1::MarginLevelsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>> AsyncMarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>>(AsyncMarginLevelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>> PrepareAsyncMarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>>(PrepareAsyncMarginLevelsRaw(context, request, cq));
    }
    ::grpc::Status Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::api::v1::PartiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>> AsyncParties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>>(AsyncPartiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>> PrepareAsyncParties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>>(PrepareAsyncPartiesRaw(context, request, cq));
    }
    ::grpc::Status PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::api::v1::PartyByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>> AsyncPartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>>(AsyncPartyByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>> PrepareAsyncPartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>>(PrepareAsyncPartyByIDRaw(context, request, cq));
    }
    ::grpc::Status PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::api::v1::PositionsByPartyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>> AsyncPositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>>(AsyncPositionsByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>> PrepareAsyncPositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>>(PrepareAsyncPositionsByPartyRaw(context, request, cq));
    }
    ::grpc::Status LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::api::v1::LastTradeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>> AsyncLastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>>(AsyncLastTradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>> PrepareAsyncLastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>>(PrepareAsyncLastTradeRaw(context, request, cq));
    }
    ::grpc::Status TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::api::v1::TradesByMarketResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>> AsyncTradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>>(AsyncTradesByMarketRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>> PrepareAsyncTradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>>(PrepareAsyncTradesByMarketRaw(context, request, cq));
    }
    ::grpc::Status TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::api::v1::TradesByOrderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>> AsyncTradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>>(AsyncTradesByOrderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>> PrepareAsyncTradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>>(PrepareAsyncTradesByOrderRaw(context, request, cq));
    }
    ::grpc::Status TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::api::v1::TradesByPartyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>> AsyncTradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>>(AsyncTradesByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>> PrepareAsyncTradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>>(PrepareAsyncTradesByPartyRaw(context, request, cq));
    }
    ::grpc::Status GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::api::v1::GetProposalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>> AsyncGetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>>(AsyncGetProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>> PrepareAsyncGetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>>(PrepareAsyncGetProposalsRaw(context, request, cq));
    }
    ::grpc::Status GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::api::v1::GetProposalsByPartyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>> AsyncGetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>>(AsyncGetProposalsByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>> PrepareAsyncGetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>>(PrepareAsyncGetProposalsByPartyRaw(context, request, cq));
    }
    ::grpc::Status GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::api::v1::GetVotesByPartyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>> AsyncGetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>>(AsyncGetVotesByPartyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>> PrepareAsyncGetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>>(PrepareAsyncGetVotesByPartyRaw(context, request, cq));
    }
    ::grpc::Status GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::api::v1::GetNewMarketProposalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>> AsyncGetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>>(AsyncGetNewMarketProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>> PrepareAsyncGetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>>(PrepareAsyncGetNewMarketProposalsRaw(context, request, cq));
    }
    ::grpc::Status GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::api::v1::GetUpdateMarketProposalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>> AsyncGetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>>(AsyncGetUpdateMarketProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>> PrepareAsyncGetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>>(PrepareAsyncGetUpdateMarketProposalsRaw(context, request, cq));
    }
    ::grpc::Status GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::api::v1::GetNetworkParametersProposalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>> AsyncGetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>>(AsyncGetNetworkParametersProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>> PrepareAsyncGetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>>(PrepareAsyncGetNetworkParametersProposalsRaw(context, request, cq));
    }
    ::grpc::Status GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::api::v1::GetNewAssetProposalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>> AsyncGetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>>(AsyncGetNewAssetProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>> PrepareAsyncGetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>>(PrepareAsyncGetNewAssetProposalsRaw(context, request, cq));
    }
    ::grpc::Status GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::api::v1::GetProposalByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>> AsyncGetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>>(AsyncGetProposalByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>> PrepareAsyncGetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>>(PrepareAsyncGetProposalByIDRaw(context, request, cq));
    }
    ::grpc::Status GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::api::v1::GetProposalByReferenceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>> AsyncGetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>>(AsyncGetProposalByReferenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>> PrepareAsyncGetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>>(PrepareAsyncGetProposalByReferenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObserveGovernanceResponse>> ObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObserveGovernanceResponse>>(ObserveGovernanceRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>> AsyncObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>>(AsyncObserveGovernanceRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>> PrepareAsyncObserveGovernance(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>>(PrepareAsyncObserveGovernanceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObservePartyProposalsResponse>> ObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObservePartyProposalsResponse>>(ObservePartyProposalsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>> AsyncObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>>(AsyncObservePartyProposalsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>> PrepareAsyncObservePartyProposals(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>>(PrepareAsyncObservePartyProposalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObservePartyVotesResponse>> ObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObservePartyVotesResponse>>(ObservePartyVotesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>> AsyncObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>>(AsyncObservePartyVotesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>> PrepareAsyncObservePartyVotes(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>>(PrepareAsyncObservePartyVotesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObserveProposalVotesResponse>> ObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::ObserveProposalVotesResponse>>(ObserveProposalVotesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>> AsyncObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>>(AsyncObserveProposalVotesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>> PrepareAsyncObserveProposalVotes(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>>(PrepareAsyncObserveProposalVotesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> ObserveEventBus(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(ObserveEventBusRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> AsyncObserveEventBus(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(AsyncObserveEventBusRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>> PrepareAsyncObserveEventBus(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>>(PrepareAsyncObserveEventBusRaw(context, cq));
    }
    ::grpc::Status Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::api::v1::StatisticsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>> AsyncStatistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>>(AsyncStatisticsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>> PrepareAsyncStatistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>>(PrepareAsyncStatisticsRaw(context, request, cq));
    }
    ::grpc::Status LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::api::v1::LastBlockHeightResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>> AsyncLastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>>(AsyncLastBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>> PrepareAsyncLastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>>(PrepareAsyncLastBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::api::v1::GetVegaTimeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>> AsyncGetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>>(AsyncGetVegaTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>> PrepareAsyncGetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>>(PrepareAsyncGetVegaTimeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::AccountsSubscribeResponse>> AccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::AccountsSubscribeResponse>>(AccountsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>> AsyncAccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>>(AsyncAccountsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>> PrepareAsyncAccountsSubscribe(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>>(PrepareAsyncAccountsSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::CandlesSubscribeResponse>> CandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::CandlesSubscribeResponse>>(CandlesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>> AsyncCandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>>(AsyncCandlesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>> PrepareAsyncCandlesSubscribe(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>>(PrepareAsyncCandlesSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarginLevelsSubscribeResponse>> MarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarginLevelsSubscribeResponse>>(MarginLevelsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>> AsyncMarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>>(AsyncMarginLevelsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>> PrepareAsyncMarginLevelsSubscribe(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>>(PrepareAsyncMarginLevelsSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketDepthSubscribeResponse>> MarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketDepthSubscribeResponse>>(MarketDepthSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>> AsyncMarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>>(AsyncMarketDepthSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>> PrepareAsyncMarketDepthSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>>(PrepareAsyncMarketDepthSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>> MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(MarketDepthUpdatesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>> AsyncMarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(AsyncMarketDepthUpdatesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>> PrepareAsyncMarketDepthUpdatesSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>>(PrepareAsyncMarketDepthUpdatesSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketsDataSubscribeResponse>> MarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::MarketsDataSubscribeResponse>>(MarketsDataSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>> AsyncMarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>>(AsyncMarketsDataSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>> PrepareAsyncMarketsDataSubscribe(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>>(PrepareAsyncMarketsDataSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::OrdersSubscribeResponse>> OrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::OrdersSubscribeResponse>>(OrdersSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>> AsyncOrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>>(AsyncOrdersSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>> PrepareAsyncOrdersSubscribe(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>>(PrepareAsyncOrdersSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::PositionsSubscribeResponse>> PositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::PositionsSubscribeResponse>>(PositionsSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>> AsyncPositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>>(AsyncPositionsSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>> PrepareAsyncPositionsSubscribe(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>>(PrepareAsyncPositionsSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::TradesSubscribeResponse>> TradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::TradesSubscribeResponse>>(TradesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>> AsyncTradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>>(AsyncTradesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>> PrepareAsyncTradesSubscribe(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>>(PrepareAsyncTradesSubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::api::v1::TransferResponsesSubscribeResponse>> TransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::api::v1::TransferResponsesSubscribeResponse>>(TransferResponsesSubscribeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>> AsyncTransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>>(AsyncTransferResponsesSubscribeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>> PrepareAsyncTransferResponsesSubscribe(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>>(PrepareAsyncTransferResponsesSubscribeRaw(context, request, cq));
    }
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::api::v1::GetNodeSignaturesAggregateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>> AsyncGetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>>(AsyncGetNodeSignaturesAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>> PrepareAsyncGetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>>(PrepareAsyncGetNodeSignaturesAggregateRaw(context, request, cq));
    }
    ::grpc::Status AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::api::v1::AssetByIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>> AsyncAssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>>(AsyncAssetByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>> PrepareAsyncAssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>>(PrepareAsyncAssetByIDRaw(context, request, cq));
    }
    ::grpc::Status Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::api::v1::AssetsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>> AsyncAssets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>>(AsyncAssetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>> PrepareAsyncAssets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>>(PrepareAsyncAssetsRaw(context, request, cq));
    }
    ::grpc::Status EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::api::v1::EstimateFeeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>> AsyncEstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>>(AsyncEstimateFeeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>> PrepareAsyncEstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>>(PrepareAsyncEstimateFeeRaw(context, request, cq));
    }
    ::grpc::Status EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::api::v1::EstimateMarginResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>> AsyncEstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>>(AsyncEstimateMarginRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>> PrepareAsyncEstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>>(PrepareAsyncEstimateMarginRaw(context, request, cq));
    }
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::api::v1::ERC20WithdrawalApprovalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>> AsyncERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>>(AsyncERC20WithdrawalApprovalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>> PrepareAsyncERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>>(PrepareAsyncERC20WithdrawalApprovalRaw(context, request, cq));
    }
    ::grpc::Status Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::api::v1::WithdrawalResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>> AsyncWithdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>>(AsyncWithdrawalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>> PrepareAsyncWithdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>>(PrepareAsyncWithdrawalRaw(context, request, cq));
    }
    ::grpc::Status Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::api::v1::WithdrawalsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>> AsyncWithdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>>(AsyncWithdrawalsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>> PrepareAsyncWithdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>>(PrepareAsyncWithdrawalsRaw(context, request, cq));
    }
    ::grpc::Status Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::api::v1::DepositResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>> AsyncDeposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>>(AsyncDepositRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>> PrepareAsyncDeposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>>(PrepareAsyncDepositRaw(context, request, cq));
    }
    ::grpc::Status Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::api::v1::DepositsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>> AsyncDeposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>>(AsyncDepositsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>> PrepareAsyncDeposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>>(PrepareAsyncDepositsRaw(context, request, cq));
    }
    ::grpc::Status NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::api::v1::NetworkParametersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>> AsyncNetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>>(AsyncNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>> PrepareAsyncNetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>>(PrepareAsyncNetworkParametersRaw(context, request, cq));
    }
    ::grpc::Status LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::api::v1::LiquidityProvisionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>> AsyncLiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>>(AsyncLiquidityProvisionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>> PrepareAsyncLiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>>(PrepareAsyncLiquidityProvisionsRaw(context, request, cq));
    }
    ::grpc::Status OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::api::v1::OracleSpecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>> AsyncOracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>>(AsyncOracleSpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>> PrepareAsyncOracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>>(PrepareAsyncOracleSpecRaw(context, request, cq));
    }
    ::grpc::Status OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::api::v1::OracleSpecsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>> AsyncOracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>>(AsyncOracleSpecsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>> PrepareAsyncOracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>>(PrepareAsyncOracleSpecsRaw(context, request, cq));
    }
    ::grpc::Status OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::api::v1::OracleDataBySpecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>> AsyncOracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>>(AsyncOracleDataBySpecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>> PrepareAsyncOracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>>(PrepareAsyncOracleDataBySpecRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarketAccounts(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PartyAccounts(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FeeInfrastructureAccounts(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Candles(::grpc::ClientContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarketDataByID(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarketsData(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarketByID(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarketDepth(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Markets(::grpc::ClientContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrderByMarketAndID(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrderByReference(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrdersByMarket(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrdersByParty(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrderByID(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OrderVersionsByID(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MarginLevels(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Parties(::grpc::ClientContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PartyByID(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PositionsByParty(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LastTrade(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TradesByMarket(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TradesByOrder(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TradesByParty(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetProposals(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetProposalsByParty(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVotesByParty(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNewMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetUpdateMarketProposals(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNetworkParametersProposals(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNewAssetProposals(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetProposalByID(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetProposalByReference(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ObserveGovernance(::grpc::ClientContext* context, ::api::v1::ObserveGovernanceRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObserveGovernanceResponse>* reactor) override;
      #else
      void ObserveGovernance(::grpc::ClientContext* context, ::api::v1::ObserveGovernanceRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObserveGovernanceResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ObservePartyProposals(::grpc::ClientContext* context, ::api::v1::ObservePartyProposalsRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObservePartyProposalsResponse>* reactor) override;
      #else
      void ObservePartyProposals(::grpc::ClientContext* context, ::api::v1::ObservePartyProposalsRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObservePartyProposalsResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ObservePartyVotes(::grpc::ClientContext* context, ::api::v1::ObservePartyVotesRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObservePartyVotesResponse>* reactor) override;
      #else
      void ObservePartyVotes(::grpc::ClientContext* context, ::api::v1::ObservePartyVotesRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObservePartyVotesResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ObserveProposalVotes(::grpc::ClientContext* context, ::api::v1::ObserveProposalVotesRequest* request, ::grpc::ClientReadReactor< ::api::v1::ObserveProposalVotesResponse>* reactor) override;
      #else
      void ObserveProposalVotes(::grpc::ClientContext* context, ::api::v1::ObserveProposalVotesRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::ObserveProposalVotesResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ObserveEventBus(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::api::v1::ObserveEventBusRequest,::api::v1::ObserveEventBusResponse>* reactor) override;
      #else
      void ObserveEventBus(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::api::v1::ObserveEventBusRequest,::api::v1::ObserveEventBusResponse>* reactor) override;
      #endif
      void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Statistics(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LastBlockHeight(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVegaTime(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AccountsSubscribe(::grpc::ClientContext* context, ::api::v1::AccountsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::AccountsSubscribeResponse>* reactor) override;
      #else
      void AccountsSubscribe(::grpc::ClientContext* context, ::api::v1::AccountsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::AccountsSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CandlesSubscribe(::grpc::ClientContext* context, ::api::v1::CandlesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::CandlesSubscribeResponse>* reactor) override;
      #else
      void CandlesSubscribe(::grpc::ClientContext* context, ::api::v1::CandlesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::CandlesSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarginLevelsSubscribe(::grpc::ClientContext* context, ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarginLevelsSubscribeResponse>* reactor) override;
      #else
      void MarginLevelsSubscribe(::grpc::ClientContext* context, ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarginLevelsSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketDepthSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketDepthSubscribeResponse>* reactor) override;
      #else
      void MarketDepthSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketDepthSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* reactor) override;
      #else
      void MarketDepthUpdatesSubscribe(::grpc::ClientContext* context, ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MarketsDataSubscribe(::grpc::ClientContext* context, ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::MarketsDataSubscribeResponse>* reactor) override;
      #else
      void MarketsDataSubscribe(::grpc::ClientContext* context, ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::MarketsDataSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OrdersSubscribe(::grpc::ClientContext* context, ::api::v1::OrdersSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::OrdersSubscribeResponse>* reactor) override;
      #else
      void OrdersSubscribe(::grpc::ClientContext* context, ::api::v1::OrdersSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::OrdersSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PositionsSubscribe(::grpc::ClientContext* context, ::api::v1::PositionsSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::PositionsSubscribeResponse>* reactor) override;
      #else
      void PositionsSubscribe(::grpc::ClientContext* context, ::api::v1::PositionsSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::PositionsSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TradesSubscribe(::grpc::ClientContext* context, ::api::v1::TradesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::TradesSubscribeResponse>* reactor) override;
      #else
      void TradesSubscribe(::grpc::ClientContext* context, ::api::v1::TradesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::TradesSubscribeResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TransferResponsesSubscribe(::grpc::ClientContext* context, ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::ClientReadReactor< ::api::v1::TransferResponsesSubscribeResponse>* reactor) override;
      #else
      void TransferResponsesSubscribe(::grpc::ClientContext* context, ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::experimental::ClientReadReactor< ::api::v1::TransferResponsesSubscribeResponse>* reactor) override;
      #endif
      void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNodeSignaturesAggregate(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AssetByID(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Assets(::grpc::ClientContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateFee(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EstimateMargin(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ERC20WithdrawalApproval(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Withdrawal(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Withdrawals(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Deposit(::grpc::ClientContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Deposits(::grpc::ClientContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NetworkParameters(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LiquidityProvisions(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OracleSpec(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OracleSpecs(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void OracleDataBySpec(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>* AsyncMarketAccountsRaw(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketAccountsResponse>* PrepareAsyncMarketAccountsRaw(::grpc::ClientContext* context, const ::api::v1::MarketAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>* AsyncPartyAccountsRaw(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartyAccountsResponse>* PrepareAsyncPartyAccountsRaw(::grpc::ClientContext* context, const ::api::v1::PartyAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>* AsyncFeeInfrastructureAccountsRaw(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::FeeInfrastructureAccountsResponse>* PrepareAsyncFeeInfrastructureAccountsRaw(::grpc::ClientContext* context, const ::api::v1::FeeInfrastructureAccountsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>* AsyncCandlesRaw(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::CandlesResponse>* PrepareAsyncCandlesRaw(::grpc::ClientContext* context, const ::api::v1::CandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>* AsyncMarketDataByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDataByIDResponse>* PrepareAsyncMarketDataByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketDataByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>* AsyncMarketsDataRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsDataResponse>* PrepareAsyncMarketsDataRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>* AsyncMarketByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketByIDResponse>* PrepareAsyncMarketByIDRaw(::grpc::ClientContext* context, const ::api::v1::MarketByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>* AsyncMarketDepthRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketDepthResponse>* PrepareAsyncMarketDepthRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>* AsyncMarketsRaw(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarketsResponse>* PrepareAsyncMarketsRaw(::grpc::ClientContext* context, const ::api::v1::MarketsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>* AsyncOrderByMarketAndIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByMarketAndIDResponse>* PrepareAsyncOrderByMarketAndIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByMarketAndIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>* AsyncOrderByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByReferenceResponse>* PrepareAsyncOrderByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::OrderByReferenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>* AsyncOrdersByMarketRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByMarketResponse>* PrepareAsyncOrdersByMarketRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>* AsyncOrdersByPartyRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrdersByPartyResponse>* PrepareAsyncOrdersByPartyRaw(::grpc::ClientContext* context, const ::api::v1::OrdersByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>* AsyncOrderByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderByIDResponse>* PrepareAsyncOrderByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>* AsyncOrderVersionsByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OrderVersionsByIDResponse>* PrepareAsyncOrderVersionsByIDRaw(::grpc::ClientContext* context, const ::api::v1::OrderVersionsByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>* AsyncMarginLevelsRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::MarginLevelsResponse>* PrepareAsyncMarginLevelsRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>* AsyncPartiesRaw(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartiesResponse>* PrepareAsyncPartiesRaw(::grpc::ClientContext* context, const ::api::v1::PartiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>* AsyncPartyByIDRaw(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PartyByIDResponse>* PrepareAsyncPartyByIDRaw(::grpc::ClientContext* context, const ::api::v1::PartyByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>* AsyncPositionsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::PositionsByPartyResponse>* PrepareAsyncPositionsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::PositionsByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>* AsyncLastTradeRaw(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LastTradeResponse>* PrepareAsyncLastTradeRaw(::grpc::ClientContext* context, const ::api::v1::LastTradeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>* AsyncTradesByMarketRaw(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByMarketResponse>* PrepareAsyncTradesByMarketRaw(::grpc::ClientContext* context, const ::api::v1::TradesByMarketRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>* AsyncTradesByOrderRaw(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByOrderResponse>* PrepareAsyncTradesByOrderRaw(::grpc::ClientContext* context, const ::api::v1::TradesByOrderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>* AsyncTradesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::TradesByPartyResponse>* PrepareAsyncTradesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::TradesByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>* AsyncGetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsResponse>* PrepareAsyncGetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>* AsyncGetProposalsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalsByPartyResponse>* PrepareAsyncGetProposalsByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalsByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>* AsyncGetVotesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetVotesByPartyResponse>* PrepareAsyncGetVotesByPartyRaw(::grpc::ClientContext* context, const ::api::v1::GetVotesByPartyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>* AsyncGetNewMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewMarketProposalsResponse>* PrepareAsyncGetNewMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>* AsyncGetUpdateMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetUpdateMarketProposalsResponse>* PrepareAsyncGetUpdateMarketProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetUpdateMarketProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>* AsyncGetNetworkParametersProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNetworkParametersProposalsResponse>* PrepareAsyncGetNetworkParametersProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNetworkParametersProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>* AsyncGetNewAssetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNewAssetProposalsResponse>* PrepareAsyncGetNewAssetProposalsRaw(::grpc::ClientContext* context, const ::api::v1::GetNewAssetProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>* AsyncGetProposalByIDRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByIDResponse>* PrepareAsyncGetProposalByIDRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>* AsyncGetProposalByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetProposalByReferenceResponse>* PrepareAsyncGetProposalByReferenceRaw(::grpc::ClientContext* context, const ::api::v1::GetProposalByReferenceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::ObserveGovernanceResponse>* ObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>* AsyncObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObserveGovernanceResponse>* PrepareAsyncObserveGovernanceRaw(::grpc::ClientContext* context, const ::api::v1::ObserveGovernanceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::ObservePartyProposalsResponse>* ObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>* AsyncObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObservePartyProposalsResponse>* PrepareAsyncObservePartyProposalsRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyProposalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::ObservePartyVotesResponse>* ObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>* AsyncObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObservePartyVotesResponse>* PrepareAsyncObservePartyVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObservePartyVotesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::ObserveProposalVotesResponse>* ObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>* AsyncObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::ObserveProposalVotesResponse>* PrepareAsyncObserveProposalVotesRaw(::grpc::ClientContext* context, const ::api::v1::ObserveProposalVotesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* ObserveEventBusRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* AsyncObserveEventBusRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* PrepareAsyncObserveEventBusRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>* AsyncStatisticsRaw(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::StatisticsResponse>* PrepareAsyncStatisticsRaw(::grpc::ClientContext* context, const ::api::v1::StatisticsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>* AsyncLastBlockHeightRaw(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LastBlockHeightResponse>* PrepareAsyncLastBlockHeightRaw(::grpc::ClientContext* context, const ::api::v1::LastBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>* AsyncGetVegaTimeRaw(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetVegaTimeResponse>* PrepareAsyncGetVegaTimeRaw(::grpc::ClientContext* context, const ::api::v1::GetVegaTimeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::AccountsSubscribeResponse>* AccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>* AsyncAccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::AccountsSubscribeResponse>* PrepareAsyncAccountsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::AccountsSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::CandlesSubscribeResponse>* CandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>* AsyncCandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::CandlesSubscribeResponse>* PrepareAsyncCandlesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::CandlesSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::MarginLevelsSubscribeResponse>* MarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>* AsyncMarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarginLevelsSubscribeResponse>* PrepareAsyncMarginLevelsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarginLevelsSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::MarketDepthSubscribeResponse>* MarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>* AsyncMarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketDepthSubscribeResponse>* PrepareAsyncMarketDepthSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>* MarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>* AsyncMarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketDepthUpdatesSubscribeResponse>* PrepareAsyncMarketDepthUpdatesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::MarketsDataSubscribeResponse>* MarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>* AsyncMarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::MarketsDataSubscribeResponse>* PrepareAsyncMarketsDataSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::MarketsDataSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::OrdersSubscribeResponse>* OrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>* AsyncOrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::OrdersSubscribeResponse>* PrepareAsyncOrdersSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::OrdersSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::PositionsSubscribeResponse>* PositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>* AsyncPositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::PositionsSubscribeResponse>* PrepareAsyncPositionsSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::PositionsSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::TradesSubscribeResponse>* TradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>* AsyncTradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::TradesSubscribeResponse>* PrepareAsyncTradesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TradesSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::api::v1::TransferResponsesSubscribeResponse>* TransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>* AsyncTransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::api::v1::TransferResponsesSubscribeResponse>* PrepareAsyncTransferResponsesSubscribeRaw(::grpc::ClientContext* context, const ::api::v1::TransferResponsesSubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>* AsyncGetNodeSignaturesAggregateRaw(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::GetNodeSignaturesAggregateResponse>* PrepareAsyncGetNodeSignaturesAggregateRaw(::grpc::ClientContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>* AsyncAssetByIDRaw(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::AssetByIDResponse>* PrepareAsyncAssetByIDRaw(::grpc::ClientContext* context, const ::api::v1::AssetByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>* AsyncAssetsRaw(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::AssetsResponse>* PrepareAsyncAssetsRaw(::grpc::ClientContext* context, const ::api::v1::AssetsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>* AsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateFeeResponse>* PrepareAsyncEstimateFeeRaw(::grpc::ClientContext* context, const ::api::v1::EstimateFeeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>* AsyncEstimateMarginRaw(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::EstimateMarginResponse>* PrepareAsyncEstimateMarginRaw(::grpc::ClientContext* context, const ::api::v1::EstimateMarginRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>* AsyncERC20WithdrawalApprovalRaw(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::ERC20WithdrawalApprovalResponse>* PrepareAsyncERC20WithdrawalApprovalRaw(::grpc::ClientContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>* AsyncWithdrawalRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalResponse>* PrepareAsyncWithdrawalRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>* AsyncWithdrawalsRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::WithdrawalsResponse>* PrepareAsyncWithdrawalsRaw(::grpc::ClientContext* context, const ::api::v1::WithdrawalsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>* AsyncDepositRaw(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::DepositResponse>* PrepareAsyncDepositRaw(::grpc::ClientContext* context, const ::api::v1::DepositRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>* AsyncDepositsRaw(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::DepositsResponse>* PrepareAsyncDepositsRaw(::grpc::ClientContext* context, const ::api::v1::DepositsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>* AsyncNetworkParametersRaw(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::NetworkParametersResponse>* PrepareAsyncNetworkParametersRaw(::grpc::ClientContext* context, const ::api::v1::NetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>* AsyncLiquidityProvisionsRaw(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::LiquidityProvisionsResponse>* PrepareAsyncLiquidityProvisionsRaw(::grpc::ClientContext* context, const ::api::v1::LiquidityProvisionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>* AsyncOracleSpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecResponse>* PrepareAsyncOracleSpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>* AsyncOracleSpecsRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleSpecsResponse>* PrepareAsyncOracleSpecsRaw(::grpc::ClientContext* context, const ::api::v1::OracleSpecsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>* AsyncOracleDataBySpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::api::v1::OracleDataBySpecResponse>* PrepareAsyncOracleDataBySpecRaw(::grpc::ClientContext* context, const ::api::v1::OracleDataBySpecRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_MarketAccounts_;
    const ::grpc::internal::RpcMethod rpcmethod_PartyAccounts_;
    const ::grpc::internal::RpcMethod rpcmethod_FeeInfrastructureAccounts_;
    const ::grpc::internal::RpcMethod rpcmethod_Candles_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketDataByID_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketsData_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketByID_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketDepth_;
    const ::grpc::internal::RpcMethod rpcmethod_Markets_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderByMarketAndID_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderByReference_;
    const ::grpc::internal::RpcMethod rpcmethod_OrdersByMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_OrdersByParty_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderByID_;
    const ::grpc::internal::RpcMethod rpcmethod_OrderVersionsByID_;
    const ::grpc::internal::RpcMethod rpcmethod_MarginLevels_;
    const ::grpc::internal::RpcMethod rpcmethod_Parties_;
    const ::grpc::internal::RpcMethod rpcmethod_PartyByID_;
    const ::grpc::internal::RpcMethod rpcmethod_PositionsByParty_;
    const ::grpc::internal::RpcMethod rpcmethod_LastTrade_;
    const ::grpc::internal::RpcMethod rpcmethod_TradesByMarket_;
    const ::grpc::internal::RpcMethod rpcmethod_TradesByOrder_;
    const ::grpc::internal::RpcMethod rpcmethod_TradesByParty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProposalsByParty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVotesByParty_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNewMarketProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_GetUpdateMarketProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNetworkParametersProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNewAssetProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProposalByID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProposalByReference_;
    const ::grpc::internal::RpcMethod rpcmethod_ObserveGovernance_;
    const ::grpc::internal::RpcMethod rpcmethod_ObservePartyProposals_;
    const ::grpc::internal::RpcMethod rpcmethod_ObservePartyVotes_;
    const ::grpc::internal::RpcMethod rpcmethod_ObserveProposalVotes_;
    const ::grpc::internal::RpcMethod rpcmethod_ObserveEventBus_;
    const ::grpc::internal::RpcMethod rpcmethod_Statistics_;
    const ::grpc::internal::RpcMethod rpcmethod_LastBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVegaTime_;
    const ::grpc::internal::RpcMethod rpcmethod_AccountsSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_CandlesSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_MarginLevelsSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketDepthSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketDepthUpdatesSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_MarketsDataSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_OrdersSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_PositionsSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_TradesSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferResponsesSubscribe_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNodeSignaturesAggregate_;
    const ::grpc::internal::RpcMethod rpcmethod_AssetByID_;
    const ::grpc::internal::RpcMethod rpcmethod_Assets_;
    const ::grpc::internal::RpcMethod rpcmethod_EstimateFee_;
    const ::grpc::internal::RpcMethod rpcmethod_EstimateMargin_;
    const ::grpc::internal::RpcMethod rpcmethod_ERC20WithdrawalApproval_;
    const ::grpc::internal::RpcMethod rpcmethod_Withdrawal_;
    const ::grpc::internal::RpcMethod rpcmethod_Withdrawals_;
    const ::grpc::internal::RpcMethod rpcmethod_Deposit_;
    const ::grpc::internal::RpcMethod rpcmethod_Deposits_;
    const ::grpc::internal::RpcMethod rpcmethod_NetworkParameters_;
    const ::grpc::internal::RpcMethod rpcmethod_LiquidityProvisions_;
    const ::grpc::internal::RpcMethod rpcmethod_OracleSpec_;
    const ::grpc::internal::RpcMethod rpcmethod_OracleSpecs_;
    const ::grpc::internal::RpcMethod rpcmethod_OracleDataBySpec_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // -- Accounts --
    //
    // Get a list of Accounts by Market
    virtual ::grpc::Status MarketAccounts(::grpc::ServerContext* context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response);
    // Get a list of Accounts by Party
    virtual ::grpc::Status PartyAccounts(::grpc::ServerContext* context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response);
    // Get a list of accounts holding infrastructure fees.
    // Can be filtered by asset, there will be 1 infrastructure fee account per
    // asset in the network.
    virtual ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response);
    // -- Candles --
    //
    // Get a list of Candles by Market
    virtual ::grpc::Status Candles(::grpc::ServerContext* context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response);
    // -- Market Data --
    //
    // Get Market Data by Market ID
    virtual ::grpc::Status MarketDataByID(::grpc::ServerContext* context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response);
    // Get a list of Market Data
    virtual ::grpc::Status MarketsData(::grpc::ServerContext* context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response);
    // -- Markets --
    //
    // Get a Market by ID
    virtual ::grpc::Status MarketByID(::grpc::ServerContext* context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response);
    // Get Market Depth
    virtual ::grpc::Status MarketDepth(::grpc::ServerContext* context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response);
    // Get a list of Markets
    virtual ::grpc::Status Markets(::grpc::ServerContext* context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response);
    // -- Orders --
    //
    // Get an Order by Market and Order ID
    virtual ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response);
    // Get an Order by Pending Order reference (UUID)
    virtual ::grpc::Status OrderByReference(::grpc::ServerContext* context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response);
    // Get a list of Orders by Market
    virtual ::grpc::Status OrdersByMarket(::grpc::ServerContext* context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response);
    // Get a list of Orders by Party
    virtual ::grpc::Status OrdersByParty(::grpc::ServerContext* context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response);
    // Get a specific order by order ID
    virtual ::grpc::Status OrderByID(::grpc::ServerContext* context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response);
    // Get all versions of the order by its orderID
    virtual ::grpc::Status OrderVersionsByID(::grpc::ServerContext* context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response);
    // -- Parties --
    //
    // Get Margin Levels by Party ID
    virtual ::grpc::Status MarginLevels(::grpc::ServerContext* context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response);
    // Get a list of Parties
    virtual ::grpc::Status Parties(::grpc::ServerContext* context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response);
    // Get a Party by ID
    virtual ::grpc::Status PartyByID(::grpc::ServerContext* context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response);
    // -- Positions --
    //
    // Get a list of Positions by Party
    virtual ::grpc::Status PositionsByParty(::grpc::ServerContext* context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response);
    // -- Trades --
    //
    // Get latest Trade
    virtual ::grpc::Status LastTrade(::grpc::ServerContext* context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response);
    // Get a list of Trades by Market
    virtual ::grpc::Status TradesByMarket(::grpc::ServerContext* context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response);
    // Get a list of Trades by Order
    virtual ::grpc::Status TradesByOrder(::grpc::ServerContext* context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response);
    // Get a list of Trades by Party
    virtual ::grpc::Status TradesByParty(::grpc::ServerContext* context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response);
    // -- Governance --
    //
    // Get governance data (proposals and votes) for all proposals
    virtual ::grpc::Status GetProposals(::grpc::ServerContext* context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response);
    // Get governance data (proposals and votes) for proposals by party authoring them
    virtual ::grpc::Status GetProposalsByParty(::grpc::ServerContext* context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response);
    // Get votes by party casting them
    virtual ::grpc::Status GetVotesByParty(::grpc::ServerContext* context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response);
    // Get governance data (proposals and votes) for proposals that aim creating new markets
    virtual ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response);
    // Get governance data (proposals and votes) for proposals that aim updating markets
    virtual ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response);
    // Get governance data (proposals and votes) for proposals that aim updating Vega network parameters
    virtual ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response);
    // Get governance data (proposals and votes) for proposals aiming to create new assets
    virtual ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response);
    // Get governance data (proposals and votes) for a proposal located by ID
    virtual ::grpc::Status GetProposalByID(::grpc::ServerContext* context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response);
    // Get governance data (proposals and votes) for a proposal located by reference
    virtual ::grpc::Status GetProposalByReference(::grpc::ServerContext* context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response);
    // Subscribe to a stream of all governance updates
    virtual ::grpc::Status ObserveGovernance(::grpc::ServerContext* context, const ::api::v1::ObserveGovernanceRequest* request, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* writer);
    // Subscribe to a stream of proposal updates
    virtual ::grpc::Status ObservePartyProposals(::grpc::ServerContext* context, const ::api::v1::ObservePartyProposalsRequest* request, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* writer);
    // Subscribe to a stream of votes cast by a specific party
    virtual ::grpc::Status ObservePartyVotes(::grpc::ServerContext* context, const ::api::v1::ObservePartyVotesRequest* request, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* writer);
    // Subscribe to a stream of proposal votes
    virtual ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* context, const ::api::v1::ObserveProposalVotesRequest* request, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* writer);
    // Subscribe to a stream of events from the core
    virtual ::grpc::Status ObserveEventBus(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* stream);
    // -- Misc --
    //
    // Get Statistics on Vega
    virtual ::grpc::Status Statistics(::grpc::ServerContext* context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response);
    virtual ::grpc::Status LastBlockHeight(::grpc::ServerContext* context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response);
    // Get Time
    virtual ::grpc::Status GetVegaTime(::grpc::ServerContext* context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response);
    // Subscribe to a stream of Accounts
    virtual ::grpc::Status AccountsSubscribe(::grpc::ServerContext* context, const ::api::v1::AccountsSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* writer);
    // Subscribe to a stream of Candles
    virtual ::grpc::Status CandlesSubscribe(::grpc::ServerContext* context, const ::api::v1::CandlesSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* writer);
    // Subscribe to a stream of Margin Levels
    virtual ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* context, const ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* writer);
    // Subscribe to a stream of Market Depth
    virtual ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* context, const ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* writer);
    // Subscribe to a stream of Market Depth Price Level Updates
    virtual ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* context, const ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* writer);
    // Subscribe to a stream of Markets Data
    virtual ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* context, const ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* writer);
    // Subscribe to a stream of Orders
    virtual ::grpc::Status OrdersSubscribe(::grpc::ServerContext* context, const ::api::v1::OrdersSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* writer);
    // Subscribe to a stream of Positions
    virtual ::grpc::Status PositionsSubscribe(::grpc::ServerContext* context, const ::api::v1::PositionsSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* writer);
    // Subscribe to a stream of Trades
    virtual ::grpc::Status TradesSubscribe(::grpc::ServerContext* context, const ::api::v1::TradesSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* writer);
    // Subscribe to a stream of Transfer Responses
    virtual ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* context, const ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* writer);
    // Get an aggregate of signatures from all the nodes of the network
    virtual ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response);
    // Get an asset by its identifier
    virtual ::grpc::Status AssetByID(::grpc::ServerContext* context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response);
    // Get a list of all assets on Vega
    virtual ::grpc::Status Assets(::grpc::ServerContext* context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response);
    // Get an estimate for the fee to be paid for a given order
    virtual ::grpc::Status EstimateFee(::grpc::ServerContext* context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response);
    // Get an estimate for the margin required for a new order
    virtual ::grpc::Status EstimateMargin(::grpc::ServerContext* context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response);
    // Get the bundle approval for an ERC20 withdrawal,
    // these data are being used to bundle the call to the smart contract on the ethereum bridge
    virtual ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response);
    // Get a withdrawal by its identifier
    virtual ::grpc::Status Withdrawal(::grpc::ServerContext* context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response);
    // Get withdrawals for a party
    virtual ::grpc::Status Withdrawals(::grpc::ServerContext* context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response);
    // Get a deposit by its identifier
    virtual ::grpc::Status Deposit(::grpc::ServerContext* context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response);
    // Get deposits for a party
    virtual ::grpc::Status Deposits(::grpc::ServerContext* context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response);
    // Get the network parameters
    virtual ::grpc::Status NetworkParameters(::grpc::ServerContext* context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response);
    // Get the liquidity provision orders
    virtual ::grpc::Status LiquidityProvisions(::grpc::ServerContext* context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response);
    // Get an oracle spec by ID
    virtual ::grpc::Status OracleSpec(::grpc::ServerContext* context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response);
    // Get the oracle specs
    virtual ::grpc::Status OracleSpecs(::grpc::ServerContext* context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response);
    // Get all oracle data
    virtual ::grpc::Status OracleDataBySpec(::grpc::ServerContext* context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketAccounts() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketAccounts(::grpc::ServerContext* context, ::api::v1::MarketAccountsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketAccountsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PartyAccounts() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPartyAccounts(::grpc::ServerContext* context, ::api::v1::PartyAccountsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PartyAccountsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FeeInfrastructureAccounts() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeInfrastructureAccounts(::grpc::ServerContext* context, ::api::v1::FeeInfrastructureAccountsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::FeeInfrastructureAccountsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Candles() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCandles(::grpc::ServerContext* context, ::api::v1::CandlesRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::CandlesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketDataByID() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDataByID(::grpc::ServerContext* context, ::api::v1::MarketDataByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketDataByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketsData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketsData(::grpc::ServerContext* context, ::api::v1::MarketsDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketsDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketByID() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketByID(::grpc::ServerContext* context, ::api::v1::MarketByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketDepth() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepth(::grpc::ServerContext* context, ::api::v1::MarketDepthRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketDepthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Markets() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarkets(::grpc::ServerContext* context, ::api::v1::MarketsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarketsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderByMarketAndID() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByMarketAndID(::grpc::ServerContext* context, ::api::v1::OrderByMarketAndIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrderByMarketAndIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderByReference() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByReference(::grpc::ServerContext* context, ::api::v1::OrderByReferenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrderByReferenceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrdersByMarket() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersByMarket(::grpc::ServerContext* context, ::api::v1::OrdersByMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrdersByMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrdersByParty() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersByParty(::grpc::ServerContext* context, ::api::v1::OrdersByPartyRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrdersByPartyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderByID() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByID(::grpc::ServerContext* context, ::api::v1::OrderByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrderByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrderVersionsByID() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderVersionsByID(::grpc::ServerContext* context, ::api::v1::OrderVersionsByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OrderVersionsByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarginLevels() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarginLevels(::grpc::ServerContext* context, ::api::v1::MarginLevelsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::MarginLevelsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Parties() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestParties(::grpc::ServerContext* context, ::api::v1::PartiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PartiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PartyByID() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPartyByID(::grpc::ServerContext* context, ::api::v1::PartyByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PartyByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PositionsByParty() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositionsByParty(::grpc::ServerContext* context, ::api::v1::PositionsByPartyRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::PositionsByPartyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LastTrade() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLastTrade(::grpc::ServerContext* context, ::api::v1::LastTradeRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::LastTradeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradesByMarket() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByMarket(::grpc::ServerContext* context, ::api::v1::TradesByMarketRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::TradesByMarketResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradesByOrder() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByOrder(::grpc::ServerContext* context, ::api::v1::TradesByOrderRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::TradesByOrderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradesByParty() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByParty(::grpc::ServerContext* context, ::api::v1::TradesByPartyRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::TradesByPartyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProposals() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposals(::grpc::ServerContext* context, ::api::v1::GetProposalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetProposalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProposalsByParty() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalsByParty(::grpc::ServerContext* context, ::api::v1::GetProposalsByPartyRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetProposalsByPartyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVotesByParty() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVotesByParty(::grpc::ServerContext* context, ::api::v1::GetVotesByPartyRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetVotesByPartyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNewMarketProposals() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNewMarketProposals(::grpc::ServerContext* context, ::api::v1::GetNewMarketProposalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetNewMarketProposalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetUpdateMarketProposals() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUpdateMarketProposals(::grpc::ServerContext* context, ::api::v1::GetUpdateMarketProposalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetUpdateMarketProposalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNetworkParametersProposals() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParametersProposals(::grpc::ServerContext* context, ::api::v1::GetNetworkParametersProposalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetNetworkParametersProposalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNewAssetProposals() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNewAssetProposals(::grpc::ServerContext* context, ::api::v1::GetNewAssetProposalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetNewAssetProposalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProposalByID() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalByID(::grpc::ServerContext* context, ::api::v1::GetProposalByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetProposalByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetProposalByReference() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalByReference(::grpc::ServerContext* context, ::api::v1::GetProposalByReferenceRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetProposalByReferenceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ObserveGovernance() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveGovernance(::grpc::ServerContext* context, ::api::v1::ObserveGovernanceRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::ObserveGovernanceResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ObservePartyProposals() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObservePartyProposals(::grpc::ServerContext* context, ::api::v1::ObservePartyProposalsRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::ObservePartyProposalsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(33, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ObservePartyVotes() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObservePartyVotes(::grpc::ServerContext* context, ::api::v1::ObservePartyVotesRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::ObservePartyVotesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ObserveProposalVotes() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveProposalVotes(::grpc::ServerContext* context, ::api::v1::ObserveProposalVotesRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::ObserveProposalVotesResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ObserveEventBus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ObserveEventBus() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_ObserveEventBus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveEventBus(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveEventBus(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(36, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Statistics() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatistics(::grpc::ServerContext* context, ::api::v1::StatisticsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::StatisticsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LastBlockHeight() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLastBlockHeight(::grpc::ServerContext* context, ::api::v1::LastBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::LastBlockHeightResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVegaTime() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVegaTime(::grpc::ServerContext* context, ::api::v1::GetVegaTimeRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetVegaTimeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AccountsSubscribe() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountsSubscribe(::grpc::ServerContext* context, ::api::v1::AccountsSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::AccountsSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(40, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CandlesSubscribe() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCandlesSubscribe(::grpc::ServerContext* context, ::api::v1::CandlesSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::CandlesSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(41, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarginLevelsSubscribe() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarginLevelsSubscribe(::grpc::ServerContext* context, ::api::v1::MarginLevelsSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::MarginLevelsSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketDepthSubscribe() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepthSubscribe(::grpc::ServerContext* context, ::api::v1::MarketDepthSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::MarketDepthSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketDepthUpdatesSubscribe() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepthUpdatesSubscribe(::grpc::ServerContext* context, ::api::v1::MarketDepthUpdatesSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MarketsDataSubscribe() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketsDataSubscribe(::grpc::ServerContext* context, ::api::v1::MarketsDataSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::MarketsDataSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OrdersSubscribe() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersSubscribe(::grpc::ServerContext* context, ::api::v1::OrdersSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::OrdersSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PositionsSubscribe() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositionsSubscribe(::grpc::ServerContext* context, ::api::v1::PositionsSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::PositionsSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(47, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TradesSubscribe() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesSubscribe(::grpc::ServerContext* context, ::api::v1::TradesSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::TradesSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(48, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TransferResponsesSubscribe() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferResponsesSubscribe(::grpc::ServerContext* context, ::api::v1::TransferResponsesSubscribeRequest* request, ::grpc::ServerAsyncWriter< ::api::v1::TransferResponsesSubscribeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(49, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNodeSignaturesAggregate() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeSignaturesAggregate(::grpc::ServerContext* context, ::api::v1::GetNodeSignaturesAggregateRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::GetNodeSignaturesAggregateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AssetByID() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssetByID(::grpc::ServerContext* context, ::api::v1::AssetByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::AssetByIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Assets() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssets(::grpc::ServerContext* context, ::api::v1::AssetsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::AssetsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EstimateFee() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateFee(::grpc::ServerContext* context, ::api::v1::EstimateFeeRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::EstimateFeeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EstimateMargin() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateMargin(::grpc::ServerContext* context, ::api::v1::EstimateMarginRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::EstimateMarginResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ERC20WithdrawalApproval() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestERC20WithdrawalApproval(::grpc::ServerContext* context, ::api::v1::ERC20WithdrawalApprovalRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::ERC20WithdrawalApprovalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Withdrawal() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdrawal(::grpc::ServerContext* context, ::api::v1::WithdrawalRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::WithdrawalResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Withdrawals() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdrawals(::grpc::ServerContext* context, ::api::v1::WithdrawalsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::WithdrawalsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deposit() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposit(::grpc::ServerContext* context, ::api::v1::DepositRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::DepositResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deposits() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposits(::grpc::ServerContext* context, ::api::v1::DepositsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::DepositsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NetworkParameters() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetworkParameters(::grpc::ServerContext* context, ::api::v1::NetworkParametersRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::NetworkParametersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LiquidityProvisions() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidityProvisions(::grpc::ServerContext* context, ::api::v1::LiquidityProvisionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::LiquidityProvisionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OracleSpec() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleSpec(::grpc::ServerContext* context, ::api::v1::OracleSpecRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OracleSpecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OracleSpecs() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleSpecs(::grpc::ServerContext* context, ::api::v1::OracleSpecsRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OracleSpecsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_OracleDataBySpec() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleDataBySpec(::grpc::ServerContext* context, ::api::v1::OracleDataBySpecRequest* request, ::grpc::ServerAsyncResponseWriter< ::api::v1::OracleDataBySpecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_MarketAccounts<WithAsyncMethod_PartyAccounts<WithAsyncMethod_FeeInfrastructureAccounts<WithAsyncMethod_Candles<WithAsyncMethod_MarketDataByID<WithAsyncMethod_MarketsData<WithAsyncMethod_MarketByID<WithAsyncMethod_MarketDepth<WithAsyncMethod_Markets<WithAsyncMethod_OrderByMarketAndID<WithAsyncMethod_OrderByReference<WithAsyncMethod_OrdersByMarket<WithAsyncMethod_OrdersByParty<WithAsyncMethod_OrderByID<WithAsyncMethod_OrderVersionsByID<WithAsyncMethod_MarginLevels<WithAsyncMethod_Parties<WithAsyncMethod_PartyByID<WithAsyncMethod_PositionsByParty<WithAsyncMethod_LastTrade<WithAsyncMethod_TradesByMarket<WithAsyncMethod_TradesByOrder<WithAsyncMethod_TradesByParty<WithAsyncMethod_GetProposals<WithAsyncMethod_GetProposalsByParty<WithAsyncMethod_GetVotesByParty<WithAsyncMethod_GetNewMarketProposals<WithAsyncMethod_GetUpdateMarketProposals<WithAsyncMethod_GetNetworkParametersProposals<WithAsyncMethod_GetNewAssetProposals<WithAsyncMethod_GetProposalByID<WithAsyncMethod_GetProposalByReference<WithAsyncMethod_ObserveGovernance<WithAsyncMethod_ObservePartyProposals<WithAsyncMethod_ObservePartyVotes<WithAsyncMethod_ObserveProposalVotes<WithAsyncMethod_ObserveEventBus<WithAsyncMethod_Statistics<WithAsyncMethod_LastBlockHeight<WithAsyncMethod_GetVegaTime<WithAsyncMethod_AccountsSubscribe<WithAsyncMethod_CandlesSubscribe<WithAsyncMethod_MarginLevelsSubscribe<WithAsyncMethod_MarketDepthSubscribe<WithAsyncMethod_MarketDepthUpdatesSubscribe<WithAsyncMethod_MarketsDataSubscribe<WithAsyncMethod_OrdersSubscribe<WithAsyncMethod_PositionsSubscribe<WithAsyncMethod_TradesSubscribe<WithAsyncMethod_TransferResponsesSubscribe<WithAsyncMethod_GetNodeSignaturesAggregate<WithAsyncMethod_AssetByID<WithAsyncMethod_Assets<WithAsyncMethod_EstimateFee<WithAsyncMethod_EstimateMargin<WithAsyncMethod_ERC20WithdrawalApproval<WithAsyncMethod_Withdrawal<WithAsyncMethod_Withdrawals<WithAsyncMethod_Deposit<WithAsyncMethod_Deposits<WithAsyncMethod_NetworkParameters<WithAsyncMethod_LiquidityProvisions<WithAsyncMethod_OracleSpec<WithAsyncMethod_OracleSpecs<WithAsyncMethod_OracleDataBySpec<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketAccountsRequest, ::api::v1::MarketAccountsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketAccountsRequest* request, ::api::v1::MarketAccountsResponse* response) { return this->MarketAccounts(context, request, response); }));}
    void SetMessageAllocatorFor_MarketAccounts(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketAccountsRequest, ::api::v1::MarketAccountsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketAccountsRequest, ::api::v1::MarketAccountsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PartyAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PartyAccountsRequest, ::api::v1::PartyAccountsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PartyAccountsRequest* request, ::api::v1::PartyAccountsResponse* response) { return this->PartyAccounts(context, request, response); }));}
    void SetMessageAllocatorFor_PartyAccounts(
        ::grpc::experimental::MessageAllocator< ::api::v1::PartyAccountsRequest, ::api::v1::PartyAccountsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PartyAccountsRequest, ::api::v1::PartyAccountsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PartyAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PartyAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FeeInfrastructureAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::FeeInfrastructureAccountsRequest, ::api::v1::FeeInfrastructureAccountsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::FeeInfrastructureAccountsRequest* request, ::api::v1::FeeInfrastructureAccountsResponse* response) { return this->FeeInfrastructureAccounts(context, request, response); }));}
    void SetMessageAllocatorFor_FeeInfrastructureAccounts(
        ::grpc::experimental::MessageAllocator< ::api::v1::FeeInfrastructureAccountsRequest, ::api::v1::FeeInfrastructureAccountsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::FeeInfrastructureAccountsRequest, ::api::v1::FeeInfrastructureAccountsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FeeInfrastructureAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FeeInfrastructureAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Candles() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::CandlesRequest, ::api::v1::CandlesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::CandlesRequest* request, ::api::v1::CandlesResponse* response) { return this->Candles(context, request, response); }));}
    void SetMessageAllocatorFor_Candles(
        ::grpc::experimental::MessageAllocator< ::api::v1::CandlesRequest, ::api::v1::CandlesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::CandlesRequest, ::api::v1::CandlesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Candles(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Candles(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketDataByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketDataByIDRequest, ::api::v1::MarketDataByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketDataByIDRequest* request, ::api::v1::MarketDataByIDResponse* response) { return this->MarketDataByID(context, request, response); }));}
    void SetMessageAllocatorFor_MarketDataByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketDataByIDRequest, ::api::v1::MarketDataByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketDataByIDRequest, ::api::v1::MarketDataByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketDataByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketDataByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketsData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketsDataRequest, ::api::v1::MarketsDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketsDataRequest* request, ::api::v1::MarketsDataResponse* response) { return this->MarketsData(context, request, response); }));}
    void SetMessageAllocatorFor_MarketsData(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketsDataRequest, ::api::v1::MarketsDataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketsDataRequest, ::api::v1::MarketsDataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketsData(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketsData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketByIDRequest, ::api::v1::MarketByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketByIDRequest* request, ::api::v1::MarketByIDResponse* response) { return this->MarketByID(context, request, response); }));}
    void SetMessageAllocatorFor_MarketByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketByIDRequest, ::api::v1::MarketByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketByIDRequest, ::api::v1::MarketByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketDepth() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketDepthRequest, ::api::v1::MarketDepthResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketDepthRequest* request, ::api::v1::MarketDepthResponse* response) { return this->MarketDepth(context, request, response); }));}
    void SetMessageAllocatorFor_MarketDepth(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketDepthRequest, ::api::v1::MarketDepthResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketDepthRequest, ::api::v1::MarketDepthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketDepth(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketDepth(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Markets() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketsRequest, ::api::v1::MarketsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketsRequest* request, ::api::v1::MarketsResponse* response) { return this->Markets(context, request, response); }));}
    void SetMessageAllocatorFor_Markets(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarketsRequest, ::api::v1::MarketsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarketsRequest, ::api::v1::MarketsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Markets(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Markets(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrderByMarketAndID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByMarketAndIDRequest, ::api::v1::OrderByMarketAndIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrderByMarketAndIDRequest* request, ::api::v1::OrderByMarketAndIDResponse* response) { return this->OrderByMarketAndID(context, request, response); }));}
    void SetMessageAllocatorFor_OrderByMarketAndID(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrderByMarketAndIDRequest, ::api::v1::OrderByMarketAndIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByMarketAndIDRequest, ::api::v1::OrderByMarketAndIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByMarketAndID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByMarketAndID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrderByReference() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByReferenceRequest, ::api::v1::OrderByReferenceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrderByReferenceRequest* request, ::api::v1::OrderByReferenceResponse* response) { return this->OrderByReference(context, request, response); }));}
    void SetMessageAllocatorFor_OrderByReference(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrderByReferenceRequest, ::api::v1::OrderByReferenceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByReferenceRequest, ::api::v1::OrderByReferenceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByReference(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByReference(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrdersByMarket() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrdersByMarketRequest, ::api::v1::OrdersByMarketResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrdersByMarketRequest* request, ::api::v1::OrdersByMarketResponse* response) { return this->OrdersByMarket(context, request, response); }));}
    void SetMessageAllocatorFor_OrdersByMarket(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrdersByMarketRequest, ::api::v1::OrdersByMarketResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrdersByMarketRequest, ::api::v1::OrdersByMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrdersByMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrdersByMarket(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrdersByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrdersByPartyRequest, ::api::v1::OrdersByPartyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrdersByPartyRequest* request, ::api::v1::OrdersByPartyResponse* response) { return this->OrdersByParty(context, request, response); }));}
    void SetMessageAllocatorFor_OrdersByParty(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrdersByPartyRequest, ::api::v1::OrdersByPartyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrdersByPartyRequest, ::api::v1::OrdersByPartyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrdersByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrdersByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrderByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByIDRequest, ::api::v1::OrderByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrderByIDRequest* request, ::api::v1::OrderByIDResponse* response) { return this->OrderByID(context, request, response); }));}
    void SetMessageAllocatorFor_OrderByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrderByIDRequest, ::api::v1::OrderByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderByIDRequest, ::api::v1::OrderByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrderVersionsByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderVersionsByIDRequest, ::api::v1::OrderVersionsByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrderVersionsByIDRequest* request, ::api::v1::OrderVersionsByIDResponse* response) { return this->OrderVersionsByID(context, request, response); }));}
    void SetMessageAllocatorFor_OrderVersionsByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::OrderVersionsByIDRequest, ::api::v1::OrderVersionsByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OrderVersionsByIDRequest, ::api::v1::OrderVersionsByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderVersionsByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderVersionsByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarginLevels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::MarginLevelsRequest, ::api::v1::MarginLevelsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarginLevelsRequest* request, ::api::v1::MarginLevelsResponse* response) { return this->MarginLevels(context, request, response); }));}
    void SetMessageAllocatorFor_MarginLevels(
        ::grpc::experimental::MessageAllocator< ::api::v1::MarginLevelsRequest, ::api::v1::MarginLevelsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::MarginLevelsRequest, ::api::v1::MarginLevelsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarginLevels(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarginLevels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Parties() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PartiesRequest, ::api::v1::PartiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PartiesRequest* request, ::api::v1::PartiesResponse* response) { return this->Parties(context, request, response); }));}
    void SetMessageAllocatorFor_Parties(
        ::grpc::experimental::MessageAllocator< ::api::v1::PartiesRequest, ::api::v1::PartiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PartiesRequest, ::api::v1::PartiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Parties(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Parties(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PartyByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PartyByIDRequest, ::api::v1::PartyByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PartyByIDRequest* request, ::api::v1::PartyByIDResponse* response) { return this->PartyByID(context, request, response); }));}
    void SetMessageAllocatorFor_PartyByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::PartyByIDRequest, ::api::v1::PartyByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PartyByIDRequest, ::api::v1::PartyByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PartyByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PartyByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PositionsByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::PositionsByPartyRequest, ::api::v1::PositionsByPartyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PositionsByPartyRequest* request, ::api::v1::PositionsByPartyResponse* response) { return this->PositionsByParty(context, request, response); }));}
    void SetMessageAllocatorFor_PositionsByParty(
        ::grpc::experimental::MessageAllocator< ::api::v1::PositionsByPartyRequest, ::api::v1::PositionsByPartyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::PositionsByPartyRequest, ::api::v1::PositionsByPartyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PositionsByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PositionsByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LastTrade() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::LastTradeRequest, ::api::v1::LastTradeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::LastTradeRequest* request, ::api::v1::LastTradeResponse* response) { return this->LastTrade(context, request, response); }));}
    void SetMessageAllocatorFor_LastTrade(
        ::grpc::experimental::MessageAllocator< ::api::v1::LastTradeRequest, ::api::v1::LastTradeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::LastTradeRequest, ::api::v1::LastTradeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LastTrade(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LastTrade(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TradesByMarket() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByMarketRequest, ::api::v1::TradesByMarketResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::TradesByMarketRequest* request, ::api::v1::TradesByMarketResponse* response) { return this->TradesByMarket(context, request, response); }));}
    void SetMessageAllocatorFor_TradesByMarket(
        ::grpc::experimental::MessageAllocator< ::api::v1::TradesByMarketRequest, ::api::v1::TradesByMarketResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByMarketRequest, ::api::v1::TradesByMarketResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByMarket(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TradesByOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByOrderRequest, ::api::v1::TradesByOrderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::TradesByOrderRequest* request, ::api::v1::TradesByOrderResponse* response) { return this->TradesByOrder(context, request, response); }));}
    void SetMessageAllocatorFor_TradesByOrder(
        ::grpc::experimental::MessageAllocator< ::api::v1::TradesByOrderRequest, ::api::v1::TradesByOrderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByOrderRequest, ::api::v1::TradesByOrderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TradesByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByPartyRequest, ::api::v1::TradesByPartyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::TradesByPartyRequest* request, ::api::v1::TradesByPartyResponse* response) { return this->TradesByParty(context, request, response); }));}
    void SetMessageAllocatorFor_TradesByParty(
        ::grpc::experimental::MessageAllocator< ::api::v1::TradesByPartyRequest, ::api::v1::TradesByPartyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::TradesByPartyRequest, ::api::v1::TradesByPartyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalsRequest, ::api::v1::GetProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetProposalsRequest* request, ::api::v1::GetProposalsResponse* response) { return this->GetProposals(context, request, response); }));}
    void SetMessageAllocatorFor_GetProposals(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetProposalsRequest, ::api::v1::GetProposalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalsRequest, ::api::v1::GetProposalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetProposalsByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalsByPartyRequest, ::api::v1::GetProposalsByPartyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetProposalsByPartyRequest* request, ::api::v1::GetProposalsByPartyResponse* response) { return this->GetProposalsByParty(context, request, response); }));}
    void SetMessageAllocatorFor_GetProposalsByParty(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetProposalsByPartyRequest, ::api::v1::GetProposalsByPartyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalsByPartyRequest, ::api::v1::GetProposalsByPartyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalsByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalsByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVotesByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetVotesByPartyRequest, ::api::v1::GetVotesByPartyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetVotesByPartyRequest* request, ::api::v1::GetVotesByPartyResponse* response) { return this->GetVotesByParty(context, request, response); }));}
    void SetMessageAllocatorFor_GetVotesByParty(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetVotesByPartyRequest, ::api::v1::GetVotesByPartyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetVotesByPartyRequest, ::api::v1::GetVotesByPartyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVotesByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVotesByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNewMarketProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNewMarketProposalsRequest, ::api::v1::GetNewMarketProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetNewMarketProposalsRequest* request, ::api::v1::GetNewMarketProposalsResponse* response) { return this->GetNewMarketProposals(context, request, response); }));}
    void SetMessageAllocatorFor_GetNewMarketProposals(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetNewMarketProposalsRequest, ::api::v1::GetNewMarketProposalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNewMarketProposalsRequest, ::api::v1::GetNewMarketProposalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNewMarketProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNewMarketProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetUpdateMarketProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetUpdateMarketProposalsRequest, ::api::v1::GetUpdateMarketProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetUpdateMarketProposalsRequest* request, ::api::v1::GetUpdateMarketProposalsResponse* response) { return this->GetUpdateMarketProposals(context, request, response); }));}
    void SetMessageAllocatorFor_GetUpdateMarketProposals(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetUpdateMarketProposalsRequest, ::api::v1::GetUpdateMarketProposalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetUpdateMarketProposalsRequest, ::api::v1::GetUpdateMarketProposalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUpdateMarketProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUpdateMarketProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNetworkParametersProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNetworkParametersProposalsRequest, ::api::v1::GetNetworkParametersProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetNetworkParametersProposalsRequest* request, ::api::v1::GetNetworkParametersProposalsResponse* response) { return this->GetNetworkParametersProposals(context, request, response); }));}
    void SetMessageAllocatorFor_GetNetworkParametersProposals(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetNetworkParametersProposalsRequest, ::api::v1::GetNetworkParametersProposalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNetworkParametersProposalsRequest, ::api::v1::GetNetworkParametersProposalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkParametersProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkParametersProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNewAssetProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNewAssetProposalsRequest, ::api::v1::GetNewAssetProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetNewAssetProposalsRequest* request, ::api::v1::GetNewAssetProposalsResponse* response) { return this->GetNewAssetProposals(context, request, response); }));}
    void SetMessageAllocatorFor_GetNewAssetProposals(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetNewAssetProposalsRequest, ::api::v1::GetNewAssetProposalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNewAssetProposalsRequest, ::api::v1::GetNewAssetProposalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNewAssetProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNewAssetProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetProposalByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalByIDRequest, ::api::v1::GetProposalByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetProposalByIDRequest* request, ::api::v1::GetProposalByIDResponse* response) { return this->GetProposalByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetProposalByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetProposalByIDRequest, ::api::v1::GetProposalByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalByIDRequest, ::api::v1::GetProposalByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetProposalByReference() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalByReferenceRequest, ::api::v1::GetProposalByReferenceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetProposalByReferenceRequest* request, ::api::v1::GetProposalByReferenceResponse* response) { return this->GetProposalByReference(context, request, response); }));}
    void SetMessageAllocatorFor_GetProposalByReference(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetProposalByReferenceRequest, ::api::v1::GetProposalByReferenceResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetProposalByReferenceRequest, ::api::v1::GetProposalByReferenceResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalByReference(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalByReference(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ObserveGovernance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::ObserveGovernanceRequest, ::api::v1::ObserveGovernanceResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::ObserveGovernanceRequest* request) { return this->ObserveGovernance(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::ObserveGovernanceResponse>* ObserveGovernance(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::ObserveGovernanceResponse>* ObserveGovernance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ObservePartyProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::ObservePartyProposalsRequest, ::api::v1::ObservePartyProposalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::ObservePartyProposalsRequest* request) { return this->ObservePartyProposals(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::ObservePartyProposalsResponse>* ObservePartyProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::ObservePartyProposalsResponse>* ObservePartyProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ObservePartyVotes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::ObservePartyVotesRequest, ::api::v1::ObservePartyVotesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::ObservePartyVotesRequest* request) { return this->ObservePartyVotes(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::ObservePartyVotesResponse>* ObservePartyVotes(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::ObservePartyVotesResponse>* ObservePartyVotes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ObserveProposalVotes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::ObserveProposalVotesRequest, ::api::v1::ObserveProposalVotesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::ObserveProposalVotesRequest* request) { return this->ObserveProposalVotes(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::ObserveProposalVotesResponse>* ObserveProposalVotes(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::ObserveProposalVotesResponse>* ObserveProposalVotes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ObserveEventBus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ObserveEventBus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc::internal::CallbackBidiHandler< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ObserveEventBus(context); }));
    }
    ~ExperimentalWithCallbackMethod_ObserveEventBus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveEventBus(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* ObserveEventBus(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::api::v1::ObserveEventBusRequest, ::api::v1::ObserveEventBusResponse>* ObserveEventBus(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Statistics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::StatisticsRequest, ::api::v1::StatisticsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::StatisticsRequest* request, ::api::v1::StatisticsResponse* response) { return this->Statistics(context, request, response); }));}
    void SetMessageAllocatorFor_Statistics(
        ::grpc::experimental::MessageAllocator< ::api::v1::StatisticsRequest, ::api::v1::StatisticsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::StatisticsRequest, ::api::v1::StatisticsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Statistics(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Statistics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LastBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::LastBlockHeightRequest, ::api::v1::LastBlockHeightResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::LastBlockHeightRequest* request, ::api::v1::LastBlockHeightResponse* response) { return this->LastBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_LastBlockHeight(
        ::grpc::experimental::MessageAllocator< ::api::v1::LastBlockHeightRequest, ::api::v1::LastBlockHeightResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::LastBlockHeightRequest, ::api::v1::LastBlockHeightResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LastBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LastBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVegaTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetVegaTimeRequest, ::api::v1::GetVegaTimeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetVegaTimeRequest* request, ::api::v1::GetVegaTimeResponse* response) { return this->GetVegaTime(context, request, response); }));}
    void SetMessageAllocatorFor_GetVegaTime(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetVegaTimeRequest, ::api::v1::GetVegaTimeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetVegaTimeRequest, ::api::v1::GetVegaTimeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVegaTime(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVegaTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AccountsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::AccountsSubscribeRequest, ::api::v1::AccountsSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::AccountsSubscribeRequest* request) { return this->AccountsSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::AccountsSubscribeResponse>* AccountsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::AccountsSubscribeResponse>* AccountsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CandlesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::CandlesSubscribeRequest, ::api::v1::CandlesSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::CandlesSubscribeRequest* request) { return this->CandlesSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::CandlesSubscribeResponse>* CandlesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::CandlesSubscribeResponse>* CandlesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarginLevelsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::MarginLevelsSubscribeRequest, ::api::v1::MarginLevelsSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarginLevelsSubscribeRequest* request) { return this->MarginLevelsSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::MarginLevelsSubscribeResponse>* MarginLevelsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::MarginLevelsSubscribeResponse>* MarginLevelsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketDepthSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::MarketDepthSubscribeRequest, ::api::v1::MarketDepthSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketDepthSubscribeRequest* request) { return this->MarketDepthSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::MarketDepthSubscribeResponse>* MarketDepthSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::MarketDepthSubscribeResponse>* MarketDepthSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketDepthUpdatesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::MarketDepthUpdatesSubscribeRequest, ::api::v1::MarketDepthUpdatesSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketDepthUpdatesSubscribeRequest* request) { return this->MarketDepthUpdatesSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* MarketDepthUpdatesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::MarketDepthUpdatesSubscribeResponse>* MarketDepthUpdatesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MarketsDataSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::MarketsDataSubscribeRequest, ::api::v1::MarketsDataSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::MarketsDataSubscribeRequest* request) { return this->MarketsDataSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::MarketsDataSubscribeResponse>* MarketsDataSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::MarketsDataSubscribeResponse>* MarketsDataSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OrdersSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::OrdersSubscribeRequest, ::api::v1::OrdersSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OrdersSubscribeRequest* request) { return this->OrdersSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::OrdersSubscribeResponse>* OrdersSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::OrdersSubscribeResponse>* OrdersSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PositionsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::PositionsSubscribeRequest, ::api::v1::PositionsSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::PositionsSubscribeRequest* request) { return this->PositionsSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::PositionsSubscribeResponse>* PositionsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::PositionsSubscribeResponse>* PositionsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TradesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::TradesSubscribeRequest, ::api::v1::TradesSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::TradesSubscribeRequest* request) { return this->TradesSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::TradesSubscribeResponse>* TradesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::TradesSubscribeResponse>* TradesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TransferResponsesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc::internal::CallbackServerStreamingHandler< ::api::v1::TransferResponsesSubscribeRequest, ::api::v1::TransferResponsesSubscribeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::TransferResponsesSubscribeRequest* request) { return this->TransferResponsesSubscribe(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::api::v1::TransferResponsesSubscribeResponse>* TransferResponsesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::api::v1::TransferResponsesSubscribeResponse>* TransferResponsesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNodeSignaturesAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNodeSignaturesAggregateRequest, ::api::v1::GetNodeSignaturesAggregateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::GetNodeSignaturesAggregateRequest* request, ::api::v1::GetNodeSignaturesAggregateResponse* response) { return this->GetNodeSignaturesAggregate(context, request, response); }));}
    void SetMessageAllocatorFor_GetNodeSignaturesAggregate(
        ::grpc::experimental::MessageAllocator< ::api::v1::GetNodeSignaturesAggregateRequest, ::api::v1::GetNodeSignaturesAggregateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(50);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::GetNodeSignaturesAggregateRequest, ::api::v1::GetNodeSignaturesAggregateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeSignaturesAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeSignaturesAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AssetByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::AssetByIDRequest, ::api::v1::AssetByIDResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::AssetByIDRequest* request, ::api::v1::AssetByIDResponse* response) { return this->AssetByID(context, request, response); }));}
    void SetMessageAllocatorFor_AssetByID(
        ::grpc::experimental::MessageAllocator< ::api::v1::AssetByIDRequest, ::api::v1::AssetByIDResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::AssetByIDRequest, ::api::v1::AssetByIDResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssetByID(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssetByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Assets() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::AssetsRequest, ::api::v1::AssetsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::AssetsRequest* request, ::api::v1::AssetsResponse* response) { return this->Assets(context, request, response); }));}
    void SetMessageAllocatorFor_Assets(
        ::grpc::experimental::MessageAllocator< ::api::v1::AssetsRequest, ::api::v1::AssetsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(52);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::AssetsRequest, ::api::v1::AssetsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Assets(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Assets(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EstimateFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::EstimateFeeRequest, ::api::v1::EstimateFeeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::EstimateFeeRequest* request, ::api::v1::EstimateFeeResponse* response) { return this->EstimateFee(context, request, response); }));}
    void SetMessageAllocatorFor_EstimateFee(
        ::grpc::experimental::MessageAllocator< ::api::v1::EstimateFeeRequest, ::api::v1::EstimateFeeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(53);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::EstimateFeeRequest, ::api::v1::EstimateFeeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateFee(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EstimateMargin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::EstimateMarginRequest, ::api::v1::EstimateMarginResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::EstimateMarginRequest* request, ::api::v1::EstimateMarginResponse* response) { return this->EstimateMargin(context, request, response); }));}
    void SetMessageAllocatorFor_EstimateMargin(
        ::grpc::experimental::MessageAllocator< ::api::v1::EstimateMarginRequest, ::api::v1::EstimateMarginResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(54);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::EstimateMarginRequest, ::api::v1::EstimateMarginResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateMargin(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateMargin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ERC20WithdrawalApproval() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::ERC20WithdrawalApprovalRequest, ::api::v1::ERC20WithdrawalApprovalResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::ERC20WithdrawalApprovalRequest* request, ::api::v1::ERC20WithdrawalApprovalResponse* response) { return this->ERC20WithdrawalApproval(context, request, response); }));}
    void SetMessageAllocatorFor_ERC20WithdrawalApproval(
        ::grpc::experimental::MessageAllocator< ::api::v1::ERC20WithdrawalApprovalRequest, ::api::v1::ERC20WithdrawalApprovalResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(55);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::ERC20WithdrawalApprovalRequest, ::api::v1::ERC20WithdrawalApprovalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ERC20WithdrawalApproval(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ERC20WithdrawalApproval(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Withdrawal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::WithdrawalRequest, ::api::v1::WithdrawalResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::WithdrawalRequest* request, ::api::v1::WithdrawalResponse* response) { return this->Withdrawal(context, request, response); }));}
    void SetMessageAllocatorFor_Withdrawal(
        ::grpc::experimental::MessageAllocator< ::api::v1::WithdrawalRequest, ::api::v1::WithdrawalResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(56);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::WithdrawalRequest, ::api::v1::WithdrawalResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Withdrawal(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Withdrawal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Withdrawals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::WithdrawalsRequest, ::api::v1::WithdrawalsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::WithdrawalsRequest* request, ::api::v1::WithdrawalsResponse* response) { return this->Withdrawals(context, request, response); }));}
    void SetMessageAllocatorFor_Withdrawals(
        ::grpc::experimental::MessageAllocator< ::api::v1::WithdrawalsRequest, ::api::v1::WithdrawalsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(57);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::WithdrawalsRequest, ::api::v1::WithdrawalsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Withdrawals(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Withdrawals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Deposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::DepositRequest, ::api::v1::DepositResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::DepositRequest* request, ::api::v1::DepositResponse* response) { return this->Deposit(context, request, response); }));}
    void SetMessageAllocatorFor_Deposit(
        ::grpc::experimental::MessageAllocator< ::api::v1::DepositRequest, ::api::v1::DepositResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(58);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::DepositRequest, ::api::v1::DepositResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Deposit(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Deposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Deposits() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::DepositsRequest, ::api::v1::DepositsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::DepositsRequest* request, ::api::v1::DepositsResponse* response) { return this->Deposits(context, request, response); }));}
    void SetMessageAllocatorFor_Deposits(
        ::grpc::experimental::MessageAllocator< ::api::v1::DepositsRequest, ::api::v1::DepositsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(59);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::DepositsRequest, ::api::v1::DepositsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Deposits(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Deposits(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NetworkParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::NetworkParametersRequest, ::api::v1::NetworkParametersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::NetworkParametersRequest* request, ::api::v1::NetworkParametersResponse* response) { return this->NetworkParameters(context, request, response); }));}
    void SetMessageAllocatorFor_NetworkParameters(
        ::grpc::experimental::MessageAllocator< ::api::v1::NetworkParametersRequest, ::api::v1::NetworkParametersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(60);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::NetworkParametersRequest, ::api::v1::NetworkParametersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NetworkParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LiquidityProvisions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::LiquidityProvisionsRequest, ::api::v1::LiquidityProvisionsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::LiquidityProvisionsRequest* request, ::api::v1::LiquidityProvisionsResponse* response) { return this->LiquidityProvisions(context, request, response); }));}
    void SetMessageAllocatorFor_LiquidityProvisions(
        ::grpc::experimental::MessageAllocator< ::api::v1::LiquidityProvisionsRequest, ::api::v1::LiquidityProvisionsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(61);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::LiquidityProvisionsRequest, ::api::v1::LiquidityProvisionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LiquidityProvisions(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LiquidityProvisions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OracleSpec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleSpecRequest, ::api::v1::OracleSpecResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OracleSpecRequest* request, ::api::v1::OracleSpecResponse* response) { return this->OracleSpec(context, request, response); }));}
    void SetMessageAllocatorFor_OracleSpec(
        ::grpc::experimental::MessageAllocator< ::api::v1::OracleSpecRequest, ::api::v1::OracleSpecResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(62);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleSpecRequest, ::api::v1::OracleSpecResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleSpec(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleSpec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OracleSpecs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleSpecsRequest, ::api::v1::OracleSpecsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OracleSpecsRequest* request, ::api::v1::OracleSpecsResponse* response) { return this->OracleSpecs(context, request, response); }));}
    void SetMessageAllocatorFor_OracleSpecs(
        ::grpc::experimental::MessageAllocator< ::api::v1::OracleSpecsRequest, ::api::v1::OracleSpecsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(63);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleSpecsRequest, ::api::v1::OracleSpecsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleSpecs(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleSpecs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_OracleDataBySpec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleDataBySpecRequest, ::api::v1::OracleDataBySpecResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::api::v1::OracleDataBySpecRequest* request, ::api::v1::OracleDataBySpecResponse* response) { return this->OracleDataBySpec(context, request, response); }));}
    void SetMessageAllocatorFor_OracleDataBySpec(
        ::grpc::experimental::MessageAllocator< ::api::v1::OracleDataBySpecRequest, ::api::v1::OracleDataBySpecResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(64);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::api::v1::OracleDataBySpecRequest, ::api::v1::OracleDataBySpecResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleDataBySpec(
      ::grpc::CallbackServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleDataBySpec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_MarketAccounts<ExperimentalWithCallbackMethod_PartyAccounts<ExperimentalWithCallbackMethod_FeeInfrastructureAccounts<ExperimentalWithCallbackMethod_Candles<ExperimentalWithCallbackMethod_MarketDataByID<ExperimentalWithCallbackMethod_MarketsData<ExperimentalWithCallbackMethod_MarketByID<ExperimentalWithCallbackMethod_MarketDepth<ExperimentalWithCallbackMethod_Markets<ExperimentalWithCallbackMethod_OrderByMarketAndID<ExperimentalWithCallbackMethod_OrderByReference<ExperimentalWithCallbackMethod_OrdersByMarket<ExperimentalWithCallbackMethod_OrdersByParty<ExperimentalWithCallbackMethod_OrderByID<ExperimentalWithCallbackMethod_OrderVersionsByID<ExperimentalWithCallbackMethod_MarginLevels<ExperimentalWithCallbackMethod_Parties<ExperimentalWithCallbackMethod_PartyByID<ExperimentalWithCallbackMethod_PositionsByParty<ExperimentalWithCallbackMethod_LastTrade<ExperimentalWithCallbackMethod_TradesByMarket<ExperimentalWithCallbackMethod_TradesByOrder<ExperimentalWithCallbackMethod_TradesByParty<ExperimentalWithCallbackMethod_GetProposals<ExperimentalWithCallbackMethod_GetProposalsByParty<ExperimentalWithCallbackMethod_GetVotesByParty<ExperimentalWithCallbackMethod_GetNewMarketProposals<ExperimentalWithCallbackMethod_GetUpdateMarketProposals<ExperimentalWithCallbackMethod_GetNetworkParametersProposals<ExperimentalWithCallbackMethod_GetNewAssetProposals<ExperimentalWithCallbackMethod_GetProposalByID<ExperimentalWithCallbackMethod_GetProposalByReference<ExperimentalWithCallbackMethod_ObserveGovernance<ExperimentalWithCallbackMethod_ObservePartyProposals<ExperimentalWithCallbackMethod_ObservePartyVotes<ExperimentalWithCallbackMethod_ObserveProposalVotes<ExperimentalWithCallbackMethod_ObserveEventBus<ExperimentalWithCallbackMethod_Statistics<ExperimentalWithCallbackMethod_LastBlockHeight<ExperimentalWithCallbackMethod_GetVegaTime<ExperimentalWithCallbackMethod_AccountsSubscribe<ExperimentalWithCallbackMethod_CandlesSubscribe<ExperimentalWithCallbackMethod_MarginLevelsSubscribe<ExperimentalWithCallbackMethod_MarketDepthSubscribe<ExperimentalWithCallbackMethod_MarketDepthUpdatesSubscribe<ExperimentalWithCallbackMethod_MarketsDataSubscribe<ExperimentalWithCallbackMethod_OrdersSubscribe<ExperimentalWithCallbackMethod_PositionsSubscribe<ExperimentalWithCallbackMethod_TradesSubscribe<ExperimentalWithCallbackMethod_TransferResponsesSubscribe<ExperimentalWithCallbackMethod_GetNodeSignaturesAggregate<ExperimentalWithCallbackMethod_AssetByID<ExperimentalWithCallbackMethod_Assets<ExperimentalWithCallbackMethod_EstimateFee<ExperimentalWithCallbackMethod_EstimateMargin<ExperimentalWithCallbackMethod_ERC20WithdrawalApproval<ExperimentalWithCallbackMethod_Withdrawal<ExperimentalWithCallbackMethod_Withdrawals<ExperimentalWithCallbackMethod_Deposit<ExperimentalWithCallbackMethod_Deposits<ExperimentalWithCallbackMethod_NetworkParameters<ExperimentalWithCallbackMethod_LiquidityProvisions<ExperimentalWithCallbackMethod_OracleSpec<ExperimentalWithCallbackMethod_OracleSpecs<ExperimentalWithCallbackMethod_OracleDataBySpec<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_MarketAccounts<ExperimentalWithCallbackMethod_PartyAccounts<ExperimentalWithCallbackMethod_FeeInfrastructureAccounts<ExperimentalWithCallbackMethod_Candles<ExperimentalWithCallbackMethod_MarketDataByID<ExperimentalWithCallbackMethod_MarketsData<ExperimentalWithCallbackMethod_MarketByID<ExperimentalWithCallbackMethod_MarketDepth<ExperimentalWithCallbackMethod_Markets<ExperimentalWithCallbackMethod_OrderByMarketAndID<ExperimentalWithCallbackMethod_OrderByReference<ExperimentalWithCallbackMethod_OrdersByMarket<ExperimentalWithCallbackMethod_OrdersByParty<ExperimentalWithCallbackMethod_OrderByID<ExperimentalWithCallbackMethod_OrderVersionsByID<ExperimentalWithCallbackMethod_MarginLevels<ExperimentalWithCallbackMethod_Parties<ExperimentalWithCallbackMethod_PartyByID<ExperimentalWithCallbackMethod_PositionsByParty<ExperimentalWithCallbackMethod_LastTrade<ExperimentalWithCallbackMethod_TradesByMarket<ExperimentalWithCallbackMethod_TradesByOrder<ExperimentalWithCallbackMethod_TradesByParty<ExperimentalWithCallbackMethod_GetProposals<ExperimentalWithCallbackMethod_GetProposalsByParty<ExperimentalWithCallbackMethod_GetVotesByParty<ExperimentalWithCallbackMethod_GetNewMarketProposals<ExperimentalWithCallbackMethod_GetUpdateMarketProposals<ExperimentalWithCallbackMethod_GetNetworkParametersProposals<ExperimentalWithCallbackMethod_GetNewAssetProposals<ExperimentalWithCallbackMethod_GetProposalByID<ExperimentalWithCallbackMethod_GetProposalByReference<ExperimentalWithCallbackMethod_ObserveGovernance<ExperimentalWithCallbackMethod_ObservePartyProposals<ExperimentalWithCallbackMethod_ObservePartyVotes<ExperimentalWithCallbackMethod_ObserveProposalVotes<ExperimentalWithCallbackMethod_ObserveEventBus<ExperimentalWithCallbackMethod_Statistics<ExperimentalWithCallbackMethod_LastBlockHeight<ExperimentalWithCallbackMethod_GetVegaTime<ExperimentalWithCallbackMethod_AccountsSubscribe<ExperimentalWithCallbackMethod_CandlesSubscribe<ExperimentalWithCallbackMethod_MarginLevelsSubscribe<ExperimentalWithCallbackMethod_MarketDepthSubscribe<ExperimentalWithCallbackMethod_MarketDepthUpdatesSubscribe<ExperimentalWithCallbackMethod_MarketsDataSubscribe<ExperimentalWithCallbackMethod_OrdersSubscribe<ExperimentalWithCallbackMethod_PositionsSubscribe<ExperimentalWithCallbackMethod_TradesSubscribe<ExperimentalWithCallbackMethod_TransferResponsesSubscribe<ExperimentalWithCallbackMethod_GetNodeSignaturesAggregate<ExperimentalWithCallbackMethod_AssetByID<ExperimentalWithCallbackMethod_Assets<ExperimentalWithCallbackMethod_EstimateFee<ExperimentalWithCallbackMethod_EstimateMargin<ExperimentalWithCallbackMethod_ERC20WithdrawalApproval<ExperimentalWithCallbackMethod_Withdrawal<ExperimentalWithCallbackMethod_Withdrawals<ExperimentalWithCallbackMethod_Deposit<ExperimentalWithCallbackMethod_Deposits<ExperimentalWithCallbackMethod_NetworkParameters<ExperimentalWithCallbackMethod_LiquidityProvisions<ExperimentalWithCallbackMethod_OracleSpec<ExperimentalWithCallbackMethod_OracleSpecs<ExperimentalWithCallbackMethod_OracleDataBySpec<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketAccounts() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PartyAccounts() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FeeInfrastructureAccounts() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Candles() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketDataByID() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketsData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketByID() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketDepth() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Markets() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderByMarketAndID() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderByReference() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrdersByMarket() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrdersByParty() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderByID() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrderVersionsByID() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarginLevels() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Parties() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PartyByID() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PositionsByParty() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LastTrade() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradesByMarket() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradesByOrder() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradesByParty() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProposals() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProposalsByParty() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVotesByParty() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNewMarketProposals() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetUpdateMarketProposals() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNetworkParametersProposals() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNewAssetProposals() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProposalByID() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetProposalByReference() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ObserveGovernance() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ObservePartyProposals() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ObservePartyVotes() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ObserveProposalVotes() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ObserveEventBus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ObserveEventBus() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_ObserveEventBus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveEventBus(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Statistics() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LastBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVegaTime() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AccountsSubscribe() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CandlesSubscribe() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarginLevelsSubscribe() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketDepthSubscribe() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketDepthUpdatesSubscribe() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MarketsDataSubscribe() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OrdersSubscribe() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PositionsSubscribe() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TradesSubscribe() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TransferResponsesSubscribe() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNodeSignaturesAggregate() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AssetByID() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Assets() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EstimateFee() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EstimateMargin() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ERC20WithdrawalApproval() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Withdrawal() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Withdrawals() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deposit() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deposits() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NetworkParameters() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LiquidityProvisions() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OracleSpec() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OracleSpecs() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_OracleDataBySpec() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketAccounts() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketAccounts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PartyAccounts() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPartyAccounts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FeeInfrastructureAccounts() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFeeInfrastructureAccounts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Candles() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCandles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketDataByID() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDataByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketsData() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketsData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketByID() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketDepth() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepth(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Markets() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarkets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderByMarketAndID() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByMarketAndID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderByReference() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByReference(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrdersByMarket() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersByMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrdersByParty() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersByParty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderByID() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrderVersionsByID() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrderVersionsByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarginLevels() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarginLevels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Parties() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestParties(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PartyByID() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPartyByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PositionsByParty() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositionsByParty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LastTrade() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLastTrade(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradesByMarket() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByMarket(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradesByOrder() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByOrder(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradesByParty() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesByParty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProposals() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProposalsByParty() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalsByParty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVotesByParty() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVotesByParty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNewMarketProposals() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNewMarketProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetUpdateMarketProposals() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUpdateMarketProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNetworkParametersProposals() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParametersProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNewAssetProposals() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNewAssetProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProposalByID() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetProposalByReference() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProposalByReference(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ObserveGovernance() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveGovernance(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ObservePartyProposals() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObservePartyProposals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(33, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ObservePartyVotes() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObservePartyVotes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(34, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ObserveProposalVotes() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveProposalVotes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(35, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ObserveEventBus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ObserveEventBus() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_ObserveEventBus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveEventBus(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestObserveEventBus(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(36, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Statistics() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatistics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LastBlockHeight() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLastBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVegaTime() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVegaTime(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AccountsSubscribe() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccountsSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(40, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CandlesSubscribe() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCandlesSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(41, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarginLevelsSubscribe() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarginLevelsSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(42, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketDepthSubscribe() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepthSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(43, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketDepthUpdatesSubscribe() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketDepthUpdatesSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(44, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MarketsDataSubscribe() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMarketsDataSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(45, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OrdersSubscribe() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOrdersSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(46, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PositionsSubscribe() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositionsSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(47, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TradesSubscribe() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTradesSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(48, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TransferResponsesSubscribe() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferResponsesSubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(49, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNodeSignaturesAggregate() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNodeSignaturesAggregate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AssetByID() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssetByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Assets() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EstimateFee() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateFee(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EstimateMargin() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEstimateMargin(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ERC20WithdrawalApproval() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestERC20WithdrawalApproval(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Withdrawal() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdrawal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Withdrawals() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWithdrawals(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deposit() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deposits() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeposits(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NetworkParameters() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNetworkParameters(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LiquidityProvisions() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLiquidityProvisions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OracleSpec() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleSpec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OracleSpecs() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleSpecs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_OracleDataBySpec() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOracleDataBySpec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketAccounts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PartyAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PartyAccounts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PartyAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PartyAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FeeInfrastructureAccounts() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FeeInfrastructureAccounts(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FeeInfrastructureAccounts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FeeInfrastructureAccounts(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Candles() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Candles(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Candles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Candles(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketDataByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketDataByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketDataByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketDataByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketsData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketsData(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketsData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketsData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketDepth() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarketDepth(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarketDepth(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarketDepth(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Markets() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Markets(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Markets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Markets(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrderByMarketAndID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderByMarketAndID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByMarketAndID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByMarketAndID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrderByReference() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderByReference(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByReference(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByReference(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrdersByMarket() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrdersByMarket(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrdersByMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrdersByMarket(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrdersByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrdersByParty(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrdersByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrdersByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrderByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrderVersionsByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OrderVersionsByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OrderVersionsByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OrderVersionsByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarginLevels() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MarginLevels(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MarginLevels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MarginLevels(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Parties() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Parties(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Parties(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Parties(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PartyByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PartyByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PartyByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PartyByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PositionsByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PositionsByParty(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PositionsByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PositionsByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LastTrade() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LastTrade(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LastTrade(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LastTrade(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TradesByMarket() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TradesByMarket(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByMarket(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByMarket(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TradesByOrder() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TradesByOrder(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByOrder(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByOrder(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TradesByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TradesByParty(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TradesByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TradesByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProposals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProposalsByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProposalsByParty(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalsByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalsByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVotesByParty() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVotesByParty(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVotesByParty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVotesByParty(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNewMarketProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNewMarketProposals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNewMarketProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNewMarketProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetUpdateMarketProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetUpdateMarketProposals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUpdateMarketProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUpdateMarketProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNetworkParametersProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNetworkParametersProposals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkParametersProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkParametersProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNewAssetProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNewAssetProposals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNewAssetProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNewAssetProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProposalByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProposalByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetProposalByReference() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetProposalByReference(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetProposalByReference(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetProposalByReference(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ObserveGovernance() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ObserveGovernance(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ObserveGovernance(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ObserveGovernance(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ObservePartyProposals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ObservePartyProposals(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ObservePartyProposals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ObservePartyProposals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ObservePartyVotes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ObservePartyVotes(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ObservePartyVotes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ObservePartyVotes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ObserveProposalVotes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ObserveProposalVotes(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ObserveProposalVotes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ObserveProposalVotes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ObserveEventBus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ObserveEventBus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->ObserveEventBus(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_ObserveEventBus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ObserveEventBus(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::api::v1::ObserveEventBusResponse, ::api::v1::ObserveEventBusRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ObserveEventBus(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ObserveEventBus(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Statistics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Statistics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Statistics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Statistics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LastBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LastBlockHeight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LastBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LastBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVegaTime() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVegaTime(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVegaTime(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVegaTime(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AccountsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->AccountsSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* AccountsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* AccountsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CandlesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CandlesSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CandlesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CandlesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarginLevelsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->MarginLevelsSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* MarginLevelsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* MarginLevelsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketDepthSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->MarketDepthSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* MarketDepthSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* MarketDepthSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketDepthUpdatesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->MarketDepthUpdatesSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* MarketDepthUpdatesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* MarketDepthUpdatesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MarketsDataSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->MarketsDataSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* MarketsDataSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* MarketsDataSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OrdersSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->OrdersSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* OrdersSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* OrdersSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PositionsSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->PositionsSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* PositionsSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* PositionsSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TradesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->TradesSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* TradesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* TradesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TransferResponsesSubscribe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->TransferResponsesSubscribe(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* TransferResponsesSubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* TransferResponsesSubscribe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNodeSignaturesAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNodeSignaturesAggregate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNodeSignaturesAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNodeSignaturesAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AssetByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AssetByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AssetByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AssetByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Assets() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Assets(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Assets(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Assets(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EstimateFee() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EstimateFee(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateFee(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateFee(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EstimateMargin() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EstimateMargin(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EstimateMargin(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EstimateMargin(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ERC20WithdrawalApproval() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ERC20WithdrawalApproval(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ERC20WithdrawalApproval(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ERC20WithdrawalApproval(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Withdrawal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Withdrawal(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Withdrawal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Withdrawal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Withdrawals() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Withdrawals(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Withdrawals(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Withdrawals(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Deposit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deposit(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Deposit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Deposit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Deposits() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deposits(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Deposits(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Deposits(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NetworkParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NetworkParameters(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NetworkParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LiquidityProvisions() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LiquidityProvisions(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LiquidityProvisions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LiquidityProvisions(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OracleSpec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OracleSpec(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleSpec(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleSpec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OracleSpecs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OracleSpecs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleSpecs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleSpecs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_OracleDataBySpec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->OracleDataBySpec(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* OracleDataBySpec(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* OracleDataBySpec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketAccounts() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketAccountsRequest, ::api::v1::MarketAccountsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketAccountsRequest, ::api::v1::MarketAccountsResponse>* streamer) {
                       return this->StreamedMarketAccounts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::MarketAccountsRequest* /*request*/, ::api::v1::MarketAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketAccounts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketAccountsRequest,::api::v1::MarketAccountsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PartyAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PartyAccounts() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PartyAccountsRequest, ::api::v1::PartyAccountsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PartyAccountsRequest, ::api::v1::PartyAccountsResponse>* streamer) {
                       return this->StreamedPartyAccounts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PartyAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PartyAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::PartyAccountsRequest* /*request*/, ::api::v1::PartyAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPartyAccounts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PartyAccountsRequest,::api::v1::PartyAccountsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FeeInfrastructureAccounts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FeeInfrastructureAccounts() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::FeeInfrastructureAccountsRequest, ::api::v1::FeeInfrastructureAccountsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::FeeInfrastructureAccountsRequest, ::api::v1::FeeInfrastructureAccountsResponse>* streamer) {
                       return this->StreamedFeeInfrastructureAccounts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FeeInfrastructureAccounts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FeeInfrastructureAccounts(::grpc::ServerContext* /*context*/, const ::api::v1::FeeInfrastructureAccountsRequest* /*request*/, ::api::v1::FeeInfrastructureAccountsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFeeInfrastructureAccounts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::FeeInfrastructureAccountsRequest,::api::v1::FeeInfrastructureAccountsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Candles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Candles() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::CandlesRequest, ::api::v1::CandlesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::CandlesRequest, ::api::v1::CandlesResponse>* streamer) {
                       return this->StreamedCandles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Candles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Candles(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesRequest* /*request*/, ::api::v1::CandlesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCandles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::CandlesRequest,::api::v1::CandlesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketDataByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketDataByID() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketDataByIDRequest, ::api::v1::MarketDataByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketDataByIDRequest, ::api::v1::MarketDataByIDResponse>* streamer) {
                       return this->StreamedMarketDataByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketDataByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketDataByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDataByIDRequest* /*request*/, ::api::v1::MarketDataByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketDataByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketDataByIDRequest,::api::v1::MarketDataByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketsData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketsData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketsDataRequest, ::api::v1::MarketsDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketsDataRequest, ::api::v1::MarketsDataResponse>* streamer) {
                       return this->StreamedMarketsData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketsData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketsData(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataRequest* /*request*/, ::api::v1::MarketsDataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketsData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketsDataRequest,::api::v1::MarketsDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketByID() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketByIDRequest, ::api::v1::MarketByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketByIDRequest, ::api::v1::MarketByIDResponse>* streamer) {
                       return this->StreamedMarketByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketByID(::grpc::ServerContext* /*context*/, const ::api::v1::MarketByIDRequest* /*request*/, ::api::v1::MarketByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketByIDRequest,::api::v1::MarketByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarketDepth : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarketDepth() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketDepthRequest, ::api::v1::MarketDepthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketDepthRequest, ::api::v1::MarketDepthResponse>* streamer) {
                       return this->StreamedMarketDepth(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarketDepth() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketDepth(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthRequest* /*request*/, ::api::v1::MarketDepthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarketDepth(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketDepthRequest,::api::v1::MarketDepthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Markets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Markets() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarketsRequest, ::api::v1::MarketsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarketsRequest, ::api::v1::MarketsResponse>* streamer) {
                       return this->StreamedMarkets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Markets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Markets(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsRequest* /*request*/, ::api::v1::MarketsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarkets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarketsRequest,::api::v1::MarketsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderByMarketAndID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderByMarketAndID() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrderByMarketAndIDRequest, ::api::v1::OrderByMarketAndIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrderByMarketAndIDRequest, ::api::v1::OrderByMarketAndIDResponse>* streamer) {
                       return this->StreamedOrderByMarketAndID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderByMarketAndID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderByMarketAndID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByMarketAndIDRequest* /*request*/, ::api::v1::OrderByMarketAndIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderByMarketAndID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrderByMarketAndIDRequest,::api::v1::OrderByMarketAndIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderByReference() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrderByReferenceRequest, ::api::v1::OrderByReferenceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrderByReferenceRequest, ::api::v1::OrderByReferenceResponse>* streamer) {
                       return this->StreamedOrderByReference(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderByReference(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByReferenceRequest* /*request*/, ::api::v1::OrderByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderByReference(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrderByReferenceRequest,::api::v1::OrderByReferenceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrdersByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrdersByMarket() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrdersByMarketRequest, ::api::v1::OrdersByMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrdersByMarketRequest, ::api::v1::OrdersByMarketResponse>* streamer) {
                       return this->StreamedOrdersByMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrdersByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrdersByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByMarketRequest* /*request*/, ::api::v1::OrdersByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrdersByMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrdersByMarketRequest,::api::v1::OrdersByMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrdersByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrdersByParty() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrdersByPartyRequest, ::api::v1::OrdersByPartyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrdersByPartyRequest, ::api::v1::OrdersByPartyResponse>* streamer) {
                       return this->StreamedOrdersByParty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrdersByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrdersByParty(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersByPartyRequest* /*request*/, ::api::v1::OrdersByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrdersByParty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrdersByPartyRequest,::api::v1::OrdersByPartyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderByID() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrderByIDRequest, ::api::v1::OrderByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrderByIDRequest, ::api::v1::OrderByIDResponse>* streamer) {
                       return this->StreamedOrderByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderByIDRequest* /*request*/, ::api::v1::OrderByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrderByIDRequest,::api::v1::OrderByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OrderVersionsByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OrderVersionsByID() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OrderVersionsByIDRequest, ::api::v1::OrderVersionsByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OrderVersionsByIDRequest, ::api::v1::OrderVersionsByIDResponse>* streamer) {
                       return this->StreamedOrderVersionsByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OrderVersionsByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrderVersionsByID(::grpc::ServerContext* /*context*/, const ::api::v1::OrderVersionsByIDRequest* /*request*/, ::api::v1::OrderVersionsByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOrderVersionsByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OrderVersionsByIDRequest,::api::v1::OrderVersionsByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MarginLevels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MarginLevels() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::MarginLevelsRequest, ::api::v1::MarginLevelsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::MarginLevelsRequest, ::api::v1::MarginLevelsResponse>* streamer) {
                       return this->StreamedMarginLevels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MarginLevels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarginLevels(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsRequest* /*request*/, ::api::v1::MarginLevelsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMarginLevels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::MarginLevelsRequest,::api::v1::MarginLevelsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Parties : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Parties() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PartiesRequest, ::api::v1::PartiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PartiesRequest, ::api::v1::PartiesResponse>* streamer) {
                       return this->StreamedParties(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Parties() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Parties(::grpc::ServerContext* /*context*/, const ::api::v1::PartiesRequest* /*request*/, ::api::v1::PartiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedParties(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PartiesRequest,::api::v1::PartiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PartyByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PartyByID() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PartyByIDRequest, ::api::v1::PartyByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PartyByIDRequest, ::api::v1::PartyByIDResponse>* streamer) {
                       return this->StreamedPartyByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PartyByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PartyByID(::grpc::ServerContext* /*context*/, const ::api::v1::PartyByIDRequest* /*request*/, ::api::v1::PartyByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPartyByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PartyByIDRequest,::api::v1::PartyByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PositionsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PositionsByParty() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::PositionsByPartyRequest, ::api::v1::PositionsByPartyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::PositionsByPartyRequest, ::api::v1::PositionsByPartyResponse>* streamer) {
                       return this->StreamedPositionsByParty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PositionsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PositionsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsByPartyRequest* /*request*/, ::api::v1::PositionsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPositionsByParty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::PositionsByPartyRequest,::api::v1::PositionsByPartyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LastTrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LastTrade() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::LastTradeRequest, ::api::v1::LastTradeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::LastTradeRequest, ::api::v1::LastTradeResponse>* streamer) {
                       return this->StreamedLastTrade(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LastTrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LastTrade(::grpc::ServerContext* /*context*/, const ::api::v1::LastTradeRequest* /*request*/, ::api::v1::LastTradeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLastTrade(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::LastTradeRequest,::api::v1::LastTradeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TradesByMarket : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TradesByMarket() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::TradesByMarketRequest, ::api::v1::TradesByMarketResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::TradesByMarketRequest, ::api::v1::TradesByMarketResponse>* streamer) {
                       return this->StreamedTradesByMarket(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TradesByMarket() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradesByMarket(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByMarketRequest* /*request*/, ::api::v1::TradesByMarketResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTradesByMarket(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::TradesByMarketRequest,::api::v1::TradesByMarketResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TradesByOrder : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TradesByOrder() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::TradesByOrderRequest, ::api::v1::TradesByOrderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::TradesByOrderRequest, ::api::v1::TradesByOrderResponse>* streamer) {
                       return this->StreamedTradesByOrder(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TradesByOrder() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradesByOrder(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByOrderRequest* /*request*/, ::api::v1::TradesByOrderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTradesByOrder(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::TradesByOrderRequest,::api::v1::TradesByOrderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TradesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TradesByParty() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::TradesByPartyRequest, ::api::v1::TradesByPartyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::TradesByPartyRequest, ::api::v1::TradesByPartyResponse>* streamer) {
                       return this->StreamedTradesByParty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TradesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::TradesByPartyRequest* /*request*/, ::api::v1::TradesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTradesByParty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::TradesByPartyRequest,::api::v1::TradesByPartyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProposals() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetProposalsRequest, ::api::v1::GetProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetProposalsRequest, ::api::v1::GetProposalsResponse>* streamer) {
                       return this->StreamedGetProposals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsRequest* /*request*/, ::api::v1::GetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProposals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetProposalsRequest,::api::v1::GetProposalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProposalsByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProposalsByParty() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetProposalsByPartyRequest, ::api::v1::GetProposalsByPartyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetProposalsByPartyRequest, ::api::v1::GetProposalsByPartyResponse>* streamer) {
                       return this->StreamedGetProposalsByParty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProposalsByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProposalsByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalsByPartyRequest* /*request*/, ::api::v1::GetProposalsByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProposalsByParty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetProposalsByPartyRequest,::api::v1::GetProposalsByPartyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVotesByParty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVotesByParty() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetVotesByPartyRequest, ::api::v1::GetVotesByPartyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetVotesByPartyRequest, ::api::v1::GetVotesByPartyResponse>* streamer) {
                       return this->StreamedGetVotesByParty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVotesByParty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVotesByParty(::grpc::ServerContext* /*context*/, const ::api::v1::GetVotesByPartyRequest* /*request*/, ::api::v1::GetVotesByPartyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVotesByParty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetVotesByPartyRequest,::api::v1::GetVotesByPartyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNewMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNewMarketProposals() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetNewMarketProposalsRequest, ::api::v1::GetNewMarketProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetNewMarketProposalsRequest, ::api::v1::GetNewMarketProposalsResponse>* streamer) {
                       return this->StreamedGetNewMarketProposals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNewMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNewMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewMarketProposalsRequest* /*request*/, ::api::v1::GetNewMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNewMarketProposals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetNewMarketProposalsRequest,::api::v1::GetNewMarketProposalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUpdateMarketProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetUpdateMarketProposals() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetUpdateMarketProposalsRequest, ::api::v1::GetUpdateMarketProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetUpdateMarketProposalsRequest, ::api::v1::GetUpdateMarketProposalsResponse>* streamer) {
                       return this->StreamedGetUpdateMarketProposals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetUpdateMarketProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUpdateMarketProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetUpdateMarketProposalsRequest* /*request*/, ::api::v1::GetUpdateMarketProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUpdateMarketProposals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetUpdateMarketProposalsRequest,::api::v1::GetUpdateMarketProposalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetworkParametersProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNetworkParametersProposals() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetNetworkParametersProposalsRequest, ::api::v1::GetNetworkParametersProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetNetworkParametersProposalsRequest, ::api::v1::GetNetworkParametersProposalsResponse>* streamer) {
                       return this->StreamedGetNetworkParametersProposals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNetworkParametersProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetworkParametersProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNetworkParametersProposalsRequest* /*request*/, ::api::v1::GetNetworkParametersProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetworkParametersProposals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetNetworkParametersProposalsRequest,::api::v1::GetNetworkParametersProposalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNewAssetProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNewAssetProposals() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetNewAssetProposalsRequest, ::api::v1::GetNewAssetProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetNewAssetProposalsRequest, ::api::v1::GetNewAssetProposalsResponse>* streamer) {
                       return this->StreamedGetNewAssetProposals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNewAssetProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNewAssetProposals(::grpc::ServerContext* /*context*/, const ::api::v1::GetNewAssetProposalsRequest* /*request*/, ::api::v1::GetNewAssetProposalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNewAssetProposals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetNewAssetProposalsRequest,::api::v1::GetNewAssetProposalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProposalByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProposalByID() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetProposalByIDRequest, ::api::v1::GetProposalByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetProposalByIDRequest, ::api::v1::GetProposalByIDResponse>* streamer) {
                       return this->StreamedGetProposalByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProposalByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProposalByID(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByIDRequest* /*request*/, ::api::v1::GetProposalByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProposalByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetProposalByIDRequest,::api::v1::GetProposalByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProposalByReference : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetProposalByReference() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetProposalByReferenceRequest, ::api::v1::GetProposalByReferenceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetProposalByReferenceRequest, ::api::v1::GetProposalByReferenceResponse>* streamer) {
                       return this->StreamedGetProposalByReference(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetProposalByReference() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProposalByReference(::grpc::ServerContext* /*context*/, const ::api::v1::GetProposalByReferenceRequest* /*request*/, ::api::v1::GetProposalByReferenceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProposalByReference(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetProposalByReferenceRequest,::api::v1::GetProposalByReferenceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Statistics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Statistics() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::StatisticsRequest, ::api::v1::StatisticsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::StatisticsRequest, ::api::v1::StatisticsResponse>* streamer) {
                       return this->StreamedStatistics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Statistics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Statistics(::grpc::ServerContext* /*context*/, const ::api::v1::StatisticsRequest* /*request*/, ::api::v1::StatisticsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStatistics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::StatisticsRequest,::api::v1::StatisticsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LastBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LastBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::LastBlockHeightRequest, ::api::v1::LastBlockHeightResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::LastBlockHeightRequest, ::api::v1::LastBlockHeightResponse>* streamer) {
                       return this->StreamedLastBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LastBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LastBlockHeight(::grpc::ServerContext* /*context*/, const ::api::v1::LastBlockHeightRequest* /*request*/, ::api::v1::LastBlockHeightResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLastBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::LastBlockHeightRequest,::api::v1::LastBlockHeightResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVegaTime : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVegaTime() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetVegaTimeRequest, ::api::v1::GetVegaTimeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetVegaTimeRequest, ::api::v1::GetVegaTimeResponse>* streamer) {
                       return this->StreamedGetVegaTime(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVegaTime() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVegaTime(::grpc::ServerContext* /*context*/, const ::api::v1::GetVegaTimeRequest* /*request*/, ::api::v1::GetVegaTimeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVegaTime(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetVegaTimeRequest,::api::v1::GetVegaTimeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNodeSignaturesAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNodeSignaturesAggregate() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::GetNodeSignaturesAggregateRequest, ::api::v1::GetNodeSignaturesAggregateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::GetNodeSignaturesAggregateRequest, ::api::v1::GetNodeSignaturesAggregateResponse>* streamer) {
                       return this->StreamedGetNodeSignaturesAggregate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNodeSignaturesAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNodeSignaturesAggregate(::grpc::ServerContext* /*context*/, const ::api::v1::GetNodeSignaturesAggregateRequest* /*request*/, ::api::v1::GetNodeSignaturesAggregateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNodeSignaturesAggregate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::GetNodeSignaturesAggregateRequest,::api::v1::GetNodeSignaturesAggregateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AssetByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AssetByID() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::AssetByIDRequest, ::api::v1::AssetByIDResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::AssetByIDRequest, ::api::v1::AssetByIDResponse>* streamer) {
                       return this->StreamedAssetByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AssetByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AssetByID(::grpc::ServerContext* /*context*/, const ::api::v1::AssetByIDRequest* /*request*/, ::api::v1::AssetByIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAssetByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::AssetByIDRequest,::api::v1::AssetByIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Assets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Assets() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::AssetsRequest, ::api::v1::AssetsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::AssetsRequest, ::api::v1::AssetsResponse>* streamer) {
                       return this->StreamedAssets(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Assets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Assets(::grpc::ServerContext* /*context*/, const ::api::v1::AssetsRequest* /*request*/, ::api::v1::AssetsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAssets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::AssetsRequest,::api::v1::AssetsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EstimateFee : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EstimateFee() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::EstimateFeeRequest, ::api::v1::EstimateFeeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::EstimateFeeRequest, ::api::v1::EstimateFeeResponse>* streamer) {
                       return this->StreamedEstimateFee(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EstimateFee() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EstimateFee(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateFeeRequest* /*request*/, ::api::v1::EstimateFeeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEstimateFee(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::EstimateFeeRequest,::api::v1::EstimateFeeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EstimateMargin : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EstimateMargin() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::EstimateMarginRequest, ::api::v1::EstimateMarginResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::EstimateMarginRequest, ::api::v1::EstimateMarginResponse>* streamer) {
                       return this->StreamedEstimateMargin(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EstimateMargin() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EstimateMargin(::grpc::ServerContext* /*context*/, const ::api::v1::EstimateMarginRequest* /*request*/, ::api::v1::EstimateMarginResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEstimateMargin(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::EstimateMarginRequest,::api::v1::EstimateMarginResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ERC20WithdrawalApproval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ERC20WithdrawalApproval() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::ERC20WithdrawalApprovalRequest, ::api::v1::ERC20WithdrawalApprovalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::ERC20WithdrawalApprovalRequest, ::api::v1::ERC20WithdrawalApprovalResponse>* streamer) {
                       return this->StreamedERC20WithdrawalApproval(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ERC20WithdrawalApproval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ERC20WithdrawalApproval(::grpc::ServerContext* /*context*/, const ::api::v1::ERC20WithdrawalApprovalRequest* /*request*/, ::api::v1::ERC20WithdrawalApprovalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedERC20WithdrawalApproval(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::ERC20WithdrawalApprovalRequest,::api::v1::ERC20WithdrawalApprovalResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Withdrawal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Withdrawal() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::WithdrawalRequest, ::api::v1::WithdrawalResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::WithdrawalRequest, ::api::v1::WithdrawalResponse>* streamer) {
                       return this->StreamedWithdrawal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Withdrawal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Withdrawal(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalRequest* /*request*/, ::api::v1::WithdrawalResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWithdrawal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::WithdrawalRequest,::api::v1::WithdrawalResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Withdrawals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Withdrawals() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::WithdrawalsRequest, ::api::v1::WithdrawalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::WithdrawalsRequest, ::api::v1::WithdrawalsResponse>* streamer) {
                       return this->StreamedWithdrawals(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Withdrawals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Withdrawals(::grpc::ServerContext* /*context*/, const ::api::v1::WithdrawalsRequest* /*request*/, ::api::v1::WithdrawalsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWithdrawals(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::WithdrawalsRequest,::api::v1::WithdrawalsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deposit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deposit() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::DepositRequest, ::api::v1::DepositResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::DepositRequest, ::api::v1::DepositResponse>* streamer) {
                       return this->StreamedDeposit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deposit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deposit(::grpc::ServerContext* /*context*/, const ::api::v1::DepositRequest* /*request*/, ::api::v1::DepositResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeposit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::DepositRequest,::api::v1::DepositResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deposits : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deposits() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::DepositsRequest, ::api::v1::DepositsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::DepositsRequest, ::api::v1::DepositsResponse>* streamer) {
                       return this->StreamedDeposits(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deposits() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deposits(::grpc::ServerContext* /*context*/, const ::api::v1::DepositsRequest* /*request*/, ::api::v1::DepositsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeposits(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::DepositsRequest,::api::v1::DepositsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NetworkParameters() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::NetworkParametersRequest, ::api::v1::NetworkParametersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::NetworkParametersRequest, ::api::v1::NetworkParametersResponse>* streamer) {
                       return this->StreamedNetworkParameters(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NetworkParameters(::grpc::ServerContext* /*context*/, const ::api::v1::NetworkParametersRequest* /*request*/, ::api::v1::NetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNetworkParameters(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::NetworkParametersRequest,::api::v1::NetworkParametersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LiquidityProvisions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LiquidityProvisions() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::LiquidityProvisionsRequest, ::api::v1::LiquidityProvisionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::LiquidityProvisionsRequest, ::api::v1::LiquidityProvisionsResponse>* streamer) {
                       return this->StreamedLiquidityProvisions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LiquidityProvisions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LiquidityProvisions(::grpc::ServerContext* /*context*/, const ::api::v1::LiquidityProvisionsRequest* /*request*/, ::api::v1::LiquidityProvisionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLiquidityProvisions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::LiquidityProvisionsRequest,::api::v1::LiquidityProvisionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OracleSpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OracleSpec() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OracleSpecRequest, ::api::v1::OracleSpecResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OracleSpecRequest, ::api::v1::OracleSpecResponse>* streamer) {
                       return this->StreamedOracleSpec(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OracleSpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OracleSpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecRequest* /*request*/, ::api::v1::OracleSpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOracleSpec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OracleSpecRequest,::api::v1::OracleSpecResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OracleSpecs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OracleSpecs() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OracleSpecsRequest, ::api::v1::OracleSpecsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OracleSpecsRequest, ::api::v1::OracleSpecsResponse>* streamer) {
                       return this->StreamedOracleSpecs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OracleSpecs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OracleSpecs(::grpc::ServerContext* /*context*/, const ::api::v1::OracleSpecsRequest* /*request*/, ::api::v1::OracleSpecsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOracleSpecs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OracleSpecsRequest,::api::v1::OracleSpecsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_OracleDataBySpec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_OracleDataBySpec() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::api::v1::OracleDataBySpecRequest, ::api::v1::OracleDataBySpecResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::api::v1::OracleDataBySpecRequest, ::api::v1::OracleDataBySpecResponse>* streamer) {
                       return this->StreamedOracleDataBySpec(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_OracleDataBySpec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OracleDataBySpec(::grpc::ServerContext* /*context*/, const ::api::v1::OracleDataBySpecRequest* /*request*/, ::api::v1::OracleDataBySpecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOracleDataBySpec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::api::v1::OracleDataBySpecRequest,::api::v1::OracleDataBySpecResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_MarketAccounts<WithStreamedUnaryMethod_PartyAccounts<WithStreamedUnaryMethod_FeeInfrastructureAccounts<WithStreamedUnaryMethod_Candles<WithStreamedUnaryMethod_MarketDataByID<WithStreamedUnaryMethod_MarketsData<WithStreamedUnaryMethod_MarketByID<WithStreamedUnaryMethod_MarketDepth<WithStreamedUnaryMethod_Markets<WithStreamedUnaryMethod_OrderByMarketAndID<WithStreamedUnaryMethod_OrderByReference<WithStreamedUnaryMethod_OrdersByMarket<WithStreamedUnaryMethod_OrdersByParty<WithStreamedUnaryMethod_OrderByID<WithStreamedUnaryMethod_OrderVersionsByID<WithStreamedUnaryMethod_MarginLevels<WithStreamedUnaryMethod_Parties<WithStreamedUnaryMethod_PartyByID<WithStreamedUnaryMethod_PositionsByParty<WithStreamedUnaryMethod_LastTrade<WithStreamedUnaryMethod_TradesByMarket<WithStreamedUnaryMethod_TradesByOrder<WithStreamedUnaryMethod_TradesByParty<WithStreamedUnaryMethod_GetProposals<WithStreamedUnaryMethod_GetProposalsByParty<WithStreamedUnaryMethod_GetVotesByParty<WithStreamedUnaryMethod_GetNewMarketProposals<WithStreamedUnaryMethod_GetUpdateMarketProposals<WithStreamedUnaryMethod_GetNetworkParametersProposals<WithStreamedUnaryMethod_GetNewAssetProposals<WithStreamedUnaryMethod_GetProposalByID<WithStreamedUnaryMethod_GetProposalByReference<WithStreamedUnaryMethod_Statistics<WithStreamedUnaryMethod_LastBlockHeight<WithStreamedUnaryMethod_GetVegaTime<WithStreamedUnaryMethod_GetNodeSignaturesAggregate<WithStreamedUnaryMethod_AssetByID<WithStreamedUnaryMethod_Assets<WithStreamedUnaryMethod_EstimateFee<WithStreamedUnaryMethod_EstimateMargin<WithStreamedUnaryMethod_ERC20WithdrawalApproval<WithStreamedUnaryMethod_Withdrawal<WithStreamedUnaryMethod_Withdrawals<WithStreamedUnaryMethod_Deposit<WithStreamedUnaryMethod_Deposits<WithStreamedUnaryMethod_NetworkParameters<WithStreamedUnaryMethod_LiquidityProvisions<WithStreamedUnaryMethod_OracleSpec<WithStreamedUnaryMethod_OracleSpecs<WithStreamedUnaryMethod_OracleDataBySpec<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_ObserveGovernance : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ObserveGovernance() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::ObserveGovernanceRequest, ::api::v1::ObserveGovernanceResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::ObserveGovernanceRequest, ::api::v1::ObserveGovernanceResponse>* streamer) {
                       return this->StreamedObserveGovernance(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ObserveGovernance() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ObserveGovernance(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveGovernanceRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveGovernanceResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedObserveGovernance(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::ObserveGovernanceRequest,::api::v1::ObserveGovernanceResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ObservePartyProposals : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ObservePartyProposals() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::ObservePartyProposalsRequest, ::api::v1::ObservePartyProposalsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::ObservePartyProposalsRequest, ::api::v1::ObservePartyProposalsResponse>* streamer) {
                       return this->StreamedObservePartyProposals(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ObservePartyProposals() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ObservePartyProposals(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyProposalsRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyProposalsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedObservePartyProposals(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::ObservePartyProposalsRequest,::api::v1::ObservePartyProposalsResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ObservePartyVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ObservePartyVotes() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::ObservePartyVotesRequest, ::api::v1::ObservePartyVotesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::ObservePartyVotesRequest, ::api::v1::ObservePartyVotesResponse>* streamer) {
                       return this->StreamedObservePartyVotes(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ObservePartyVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ObservePartyVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObservePartyVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObservePartyVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedObservePartyVotes(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::ObservePartyVotesRequest,::api::v1::ObservePartyVotesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ObserveProposalVotes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ObserveProposalVotes() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::ObserveProposalVotesRequest, ::api::v1::ObserveProposalVotesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::ObserveProposalVotesRequest, ::api::v1::ObserveProposalVotesResponse>* streamer) {
                       return this->StreamedObserveProposalVotes(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ObserveProposalVotes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ObserveProposalVotes(::grpc::ServerContext* /*context*/, const ::api::v1::ObserveProposalVotesRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::ObserveProposalVotesResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedObserveProposalVotes(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::ObserveProposalVotesRequest,::api::v1::ObserveProposalVotesResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_AccountsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_AccountsSubscribe() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::AccountsSubscribeRequest, ::api::v1::AccountsSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::AccountsSubscribeRequest, ::api::v1::AccountsSubscribeResponse>* streamer) {
                       return this->StreamedAccountsSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_AccountsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AccountsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::AccountsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::AccountsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedAccountsSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::AccountsSubscribeRequest,::api::v1::AccountsSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CandlesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CandlesSubscribe() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::CandlesSubscribeRequest, ::api::v1::CandlesSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::CandlesSubscribeRequest, ::api::v1::CandlesSubscribeResponse>* streamer) {
                       return this->StreamedCandlesSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_CandlesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CandlesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::CandlesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::CandlesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCandlesSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::CandlesSubscribeRequest,::api::v1::CandlesSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_MarginLevelsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_MarginLevelsSubscribe() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::MarginLevelsSubscribeRequest, ::api::v1::MarginLevelsSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::MarginLevelsSubscribeRequest, ::api::v1::MarginLevelsSubscribeResponse>* streamer) {
                       return this->StreamedMarginLevelsSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_MarginLevelsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarginLevelsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarginLevelsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarginLevelsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMarginLevelsSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::MarginLevelsSubscribeRequest,::api::v1::MarginLevelsSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_MarketDepthSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_MarketDepthSubscribe() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::MarketDepthSubscribeRequest, ::api::v1::MarketDepthSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::MarketDepthSubscribeRequest, ::api::v1::MarketDepthSubscribeResponse>* streamer) {
                       return this->StreamedMarketDepthSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_MarketDepthSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketDepthSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMarketDepthSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::MarketDepthSubscribeRequest,::api::v1::MarketDepthSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_MarketDepthUpdatesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_MarketDepthUpdatesSubscribe() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::MarketDepthUpdatesSubscribeRequest, ::api::v1::MarketDepthUpdatesSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::MarketDepthUpdatesSubscribeRequest, ::api::v1::MarketDepthUpdatesSubscribeResponse>* streamer) {
                       return this->StreamedMarketDepthUpdatesSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_MarketDepthUpdatesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketDepthUpdatesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketDepthUpdatesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketDepthUpdatesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMarketDepthUpdatesSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::MarketDepthUpdatesSubscribeRequest,::api::v1::MarketDepthUpdatesSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_MarketsDataSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_MarketsDataSubscribe() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::MarketsDataSubscribeRequest, ::api::v1::MarketsDataSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::MarketsDataSubscribeRequest, ::api::v1::MarketsDataSubscribeResponse>* streamer) {
                       return this->StreamedMarketsDataSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_MarketsDataSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MarketsDataSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::MarketsDataSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::MarketsDataSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedMarketsDataSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::MarketsDataSubscribeRequest,::api::v1::MarketsDataSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OrdersSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_OrdersSubscribe() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::OrdersSubscribeRequest, ::api::v1::OrdersSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::OrdersSubscribeRequest, ::api::v1::OrdersSubscribeResponse>* streamer) {
                       return this->StreamedOrdersSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_OrdersSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OrdersSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::OrdersSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::OrdersSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOrdersSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::OrdersSubscribeRequest,::api::v1::OrdersSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_PositionsSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_PositionsSubscribe() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::PositionsSubscribeRequest, ::api::v1::PositionsSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::PositionsSubscribeRequest, ::api::v1::PositionsSubscribeResponse>* streamer) {
                       return this->StreamedPositionsSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_PositionsSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PositionsSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::PositionsSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::PositionsSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPositionsSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::PositionsSubscribeRequest,::api::v1::PositionsSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_TradesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_TradesSubscribe() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::TradesSubscribeRequest, ::api::v1::TradesSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::TradesSubscribeRequest, ::api::v1::TradesSubscribeResponse>* streamer) {
                       return this->StreamedTradesSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_TradesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TradesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TradesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TradesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedTradesSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::TradesSubscribeRequest,::api::v1::TradesSubscribeResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_TransferResponsesSubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_TransferResponsesSubscribe() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::api::v1::TransferResponsesSubscribeRequest, ::api::v1::TransferResponsesSubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::api::v1::TransferResponsesSubscribeRequest, ::api::v1::TransferResponsesSubscribeResponse>* streamer) {
                       return this->StreamedTransferResponsesSubscribe(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_TransferResponsesSubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferResponsesSubscribe(::grpc::ServerContext* /*context*/, const ::api::v1::TransferResponsesSubscribeRequest* /*request*/, ::grpc::ServerWriter< ::api::v1::TransferResponsesSubscribeResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedTransferResponsesSubscribe(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::api::v1::TransferResponsesSubscribeRequest,::api::v1::TransferResponsesSubscribeResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_ObserveGovernance<WithSplitStreamingMethod_ObservePartyProposals<WithSplitStreamingMethod_ObservePartyVotes<WithSplitStreamingMethod_ObserveProposalVotes<WithSplitStreamingMethod_AccountsSubscribe<WithSplitStreamingMethod_CandlesSubscribe<WithSplitStreamingMethod_MarginLevelsSubscribe<WithSplitStreamingMethod_MarketDepthSubscribe<WithSplitStreamingMethod_MarketDepthUpdatesSubscribe<WithSplitStreamingMethod_MarketsDataSubscribe<WithSplitStreamingMethod_OrdersSubscribe<WithSplitStreamingMethod_PositionsSubscribe<WithSplitStreamingMethod_TradesSubscribe<WithSplitStreamingMethod_TransferResponsesSubscribe<Service > > > > > > > > > > > > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_MarketAccounts<WithStreamedUnaryMethod_PartyAccounts<WithStreamedUnaryMethod_FeeInfrastructureAccounts<WithStreamedUnaryMethod_Candles<WithStreamedUnaryMethod_MarketDataByID<WithStreamedUnaryMethod_MarketsData<WithStreamedUnaryMethod_MarketByID<WithStreamedUnaryMethod_MarketDepth<WithStreamedUnaryMethod_Markets<WithStreamedUnaryMethod_OrderByMarketAndID<WithStreamedUnaryMethod_OrderByReference<WithStreamedUnaryMethod_OrdersByMarket<WithStreamedUnaryMethod_OrdersByParty<WithStreamedUnaryMethod_OrderByID<WithStreamedUnaryMethod_OrderVersionsByID<WithStreamedUnaryMethod_MarginLevels<WithStreamedUnaryMethod_Parties<WithStreamedUnaryMethod_PartyByID<WithStreamedUnaryMethod_PositionsByParty<WithStreamedUnaryMethod_LastTrade<WithStreamedUnaryMethod_TradesByMarket<WithStreamedUnaryMethod_TradesByOrder<WithStreamedUnaryMethod_TradesByParty<WithStreamedUnaryMethod_GetProposals<WithStreamedUnaryMethod_GetProposalsByParty<WithStreamedUnaryMethod_GetVotesByParty<WithStreamedUnaryMethod_GetNewMarketProposals<WithStreamedUnaryMethod_GetUpdateMarketProposals<WithStreamedUnaryMethod_GetNetworkParametersProposals<WithStreamedUnaryMethod_GetNewAssetProposals<WithStreamedUnaryMethod_GetProposalByID<WithStreamedUnaryMethod_GetProposalByReference<WithSplitStreamingMethod_ObserveGovernance<WithSplitStreamingMethod_ObservePartyProposals<WithSplitStreamingMethod_ObservePartyVotes<WithSplitStreamingMethod_ObserveProposalVotes<WithStreamedUnaryMethod_Statistics<WithStreamedUnaryMethod_LastBlockHeight<WithStreamedUnaryMethod_GetVegaTime<WithSplitStreamingMethod_AccountsSubscribe<WithSplitStreamingMethod_CandlesSubscribe<WithSplitStreamingMethod_MarginLevelsSubscribe<WithSplitStreamingMethod_MarketDepthSubscribe<WithSplitStreamingMethod_MarketDepthUpdatesSubscribe<WithSplitStreamingMethod_MarketsDataSubscribe<WithSplitStreamingMethod_OrdersSubscribe<WithSplitStreamingMethod_PositionsSubscribe<WithSplitStreamingMethod_TradesSubscribe<WithSplitStreamingMethod_TransferResponsesSubscribe<WithStreamedUnaryMethod_GetNodeSignaturesAggregate<WithStreamedUnaryMethod_AssetByID<WithStreamedUnaryMethod_Assets<WithStreamedUnaryMethod_EstimateFee<WithStreamedUnaryMethod_EstimateMargin<WithStreamedUnaryMethod_ERC20WithdrawalApproval<WithStreamedUnaryMethod_Withdrawal<WithStreamedUnaryMethod_Withdrawals<WithStreamedUnaryMethod_Deposit<WithStreamedUnaryMethod_Deposits<WithStreamedUnaryMethod_NetworkParameters<WithStreamedUnaryMethod_LiquidityProvisions<WithStreamedUnaryMethod_OracleSpec<WithStreamedUnaryMethod_OracleSpecs<WithStreamedUnaryMethod_OracleDataBySpec<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace api


#endif  // GRPC_api_2ftrading_2eproto__INCLUDED
