// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: markets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_markets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_markets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "github.com/mwitkow/go-proto-validators/validator.pb.h"
#include "oracles/v1/spec.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_markets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_markets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_markets_2eproto;
namespace vega {
class AuctionDuration;
class AuctionDurationDefaultTypeInternal;
extern AuctionDurationDefaultTypeInternal _AuctionDuration_default_instance_;
class ContinuousTrading;
class ContinuousTradingDefaultTypeInternal;
extern ContinuousTradingDefaultTypeInternal _ContinuousTrading_default_instance_;
class DiscreteTrading;
class DiscreteTradingDefaultTypeInternal;
extern DiscreteTradingDefaultTypeInternal _DiscreteTrading_default_instance_;
class FeeFactors;
class FeeFactorsDefaultTypeInternal;
extern FeeFactorsDefaultTypeInternal _FeeFactors_default_instance_;
class Fees;
class FeesDefaultTypeInternal;
extern FeesDefaultTypeInternal _Fees_default_instance_;
class Future;
class FutureDefaultTypeInternal;
extern FutureDefaultTypeInternal _Future_default_instance_;
class Instrument;
class InstrumentDefaultTypeInternal;
extern InstrumentDefaultTypeInternal _Instrument_default_instance_;
class InstrumentMetadata;
class InstrumentMetadataDefaultTypeInternal;
extern InstrumentMetadataDefaultTypeInternal _InstrumentMetadata_default_instance_;
class LiquidityMonitoringParameters;
class LiquidityMonitoringParametersDefaultTypeInternal;
extern LiquidityMonitoringParametersDefaultTypeInternal _LiquidityMonitoringParameters_default_instance_;
class LogNormalModelParams;
class LogNormalModelParamsDefaultTypeInternal;
extern LogNormalModelParamsDefaultTypeInternal _LogNormalModelParams_default_instance_;
class LogNormalRiskModel;
class LogNormalRiskModelDefaultTypeInternal;
extern LogNormalRiskModelDefaultTypeInternal _LogNormalRiskModel_default_instance_;
class MarginCalculator;
class MarginCalculatorDefaultTypeInternal;
extern MarginCalculatorDefaultTypeInternal _MarginCalculator_default_instance_;
class Market;
class MarketDefaultTypeInternal;
extern MarketDefaultTypeInternal _Market_default_instance_;
class MarketTimestamps;
class MarketTimestampsDefaultTypeInternal;
extern MarketTimestampsDefaultTypeInternal _MarketTimestamps_default_instance_;
class OracleSpecToFutureBinding;
class OracleSpecToFutureBindingDefaultTypeInternal;
extern OracleSpecToFutureBindingDefaultTypeInternal _OracleSpecToFutureBinding_default_instance_;
class PriceMonitoringParameters;
class PriceMonitoringParametersDefaultTypeInternal;
extern PriceMonitoringParametersDefaultTypeInternal _PriceMonitoringParameters_default_instance_;
class PriceMonitoringSettings;
class PriceMonitoringSettingsDefaultTypeInternal;
extern PriceMonitoringSettingsDefaultTypeInternal _PriceMonitoringSettings_default_instance_;
class PriceMonitoringTrigger;
class PriceMonitoringTriggerDefaultTypeInternal;
extern PriceMonitoringTriggerDefaultTypeInternal _PriceMonitoringTrigger_default_instance_;
class ScalingFactors;
class ScalingFactorsDefaultTypeInternal;
extern ScalingFactorsDefaultTypeInternal _ScalingFactors_default_instance_;
class SimpleModelParams;
class SimpleModelParamsDefaultTypeInternal;
extern SimpleModelParamsDefaultTypeInternal _SimpleModelParams_default_instance_;
class SimpleRiskModel;
class SimpleRiskModelDefaultTypeInternal;
extern SimpleRiskModelDefaultTypeInternal _SimpleRiskModel_default_instance_;
class TargetStakeParameters;
class TargetStakeParametersDefaultTypeInternal;
extern TargetStakeParametersDefaultTypeInternal _TargetStakeParameters_default_instance_;
class TradableInstrument;
class TradableInstrumentDefaultTypeInternal;
extern TradableInstrumentDefaultTypeInternal _TradableInstrument_default_instance_;
}  // namespace vega
PROTOBUF_NAMESPACE_OPEN
template<> ::vega::AuctionDuration* Arena::CreateMaybeMessage<::vega::AuctionDuration>(Arena*);
template<> ::vega::ContinuousTrading* Arena::CreateMaybeMessage<::vega::ContinuousTrading>(Arena*);
template<> ::vega::DiscreteTrading* Arena::CreateMaybeMessage<::vega::DiscreteTrading>(Arena*);
template<> ::vega::FeeFactors* Arena::CreateMaybeMessage<::vega::FeeFactors>(Arena*);
template<> ::vega::Fees* Arena::CreateMaybeMessage<::vega::Fees>(Arena*);
template<> ::vega::Future* Arena::CreateMaybeMessage<::vega::Future>(Arena*);
template<> ::vega::Instrument* Arena::CreateMaybeMessage<::vega::Instrument>(Arena*);
template<> ::vega::InstrumentMetadata* Arena::CreateMaybeMessage<::vega::InstrumentMetadata>(Arena*);
template<> ::vega::LiquidityMonitoringParameters* Arena::CreateMaybeMessage<::vega::LiquidityMonitoringParameters>(Arena*);
template<> ::vega::LogNormalModelParams* Arena::CreateMaybeMessage<::vega::LogNormalModelParams>(Arena*);
template<> ::vega::LogNormalRiskModel* Arena::CreateMaybeMessage<::vega::LogNormalRiskModel>(Arena*);
template<> ::vega::MarginCalculator* Arena::CreateMaybeMessage<::vega::MarginCalculator>(Arena*);
template<> ::vega::Market* Arena::CreateMaybeMessage<::vega::Market>(Arena*);
template<> ::vega::MarketTimestamps* Arena::CreateMaybeMessage<::vega::MarketTimestamps>(Arena*);
template<> ::vega::OracleSpecToFutureBinding* Arena::CreateMaybeMessage<::vega::OracleSpecToFutureBinding>(Arena*);
template<> ::vega::PriceMonitoringParameters* Arena::CreateMaybeMessage<::vega::PriceMonitoringParameters>(Arena*);
template<> ::vega::PriceMonitoringSettings* Arena::CreateMaybeMessage<::vega::PriceMonitoringSettings>(Arena*);
template<> ::vega::PriceMonitoringTrigger* Arena::CreateMaybeMessage<::vega::PriceMonitoringTrigger>(Arena*);
template<> ::vega::ScalingFactors* Arena::CreateMaybeMessage<::vega::ScalingFactors>(Arena*);
template<> ::vega::SimpleModelParams* Arena::CreateMaybeMessage<::vega::SimpleModelParams>(Arena*);
template<> ::vega::SimpleRiskModel* Arena::CreateMaybeMessage<::vega::SimpleRiskModel>(Arena*);
template<> ::vega::TargetStakeParameters* Arena::CreateMaybeMessage<::vega::TargetStakeParameters>(Arena*);
template<> ::vega::TradableInstrument* Arena::CreateMaybeMessage<::vega::TradableInstrument>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vega {

enum Market_State : int {
  Market_State_STATE_UNSPECIFIED = 0,
  Market_State_STATE_PROPOSED = 1,
  Market_State_STATE_REJECTED = 2,
  Market_State_STATE_PENDING = 3,
  Market_State_STATE_CANCELLED = 4,
  Market_State_STATE_ACTIVE = 5,
  Market_State_STATE_SUSPENDED = 6,
  Market_State_STATE_CLOSED = 7,
  Market_State_STATE_TRADING_TERMINATED = 8,
  Market_State_STATE_SETTLED = 9,
  Market_State_Market_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Market_State_Market_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Market_State_IsValid(int value);
constexpr Market_State Market_State_State_MIN = Market_State_STATE_UNSPECIFIED;
constexpr Market_State Market_State_State_MAX = Market_State_STATE_SETTLED;
constexpr int Market_State_State_ARRAYSIZE = Market_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Market_State_descriptor();
template<typename T>
inline const std::string& Market_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Market_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Market_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Market_State_descriptor(), enum_t_value);
}
inline bool Market_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Market_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Market_State>(
    Market_State_descriptor(), name, value);
}
enum Market_TradingMode : int {
  Market_TradingMode_TRADING_MODE_UNSPECIFIED = 0,
  Market_TradingMode_TRADING_MODE_CONTINUOUS = 1,
  Market_TradingMode_TRADING_MODE_BATCH_AUCTION = 2,
  Market_TradingMode_TRADING_MODE_OPENING_AUCTION = 3,
  Market_TradingMode_TRADING_MODE_MONITORING_AUCTION = 4,
  Market_TradingMode_Market_TradingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Market_TradingMode_Market_TradingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Market_TradingMode_IsValid(int value);
constexpr Market_TradingMode Market_TradingMode_TradingMode_MIN = Market_TradingMode_TRADING_MODE_UNSPECIFIED;
constexpr Market_TradingMode Market_TradingMode_TradingMode_MAX = Market_TradingMode_TRADING_MODE_MONITORING_AUCTION;
constexpr int Market_TradingMode_TradingMode_ARRAYSIZE = Market_TradingMode_TradingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Market_TradingMode_descriptor();
template<typename T>
inline const std::string& Market_TradingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Market_TradingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Market_TradingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Market_TradingMode_descriptor(), enum_t_value);
}
inline bool Market_TradingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Market_TradingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Market_TradingMode>(
    Market_TradingMode_descriptor(), name, value);
}
// ===================================================================

class AuctionDuration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.AuctionDuration) */ {
 public:
  inline AuctionDuration() : AuctionDuration(nullptr) {}
  virtual ~AuctionDuration();

  AuctionDuration(const AuctionDuration& from);
  AuctionDuration(AuctionDuration&& from) noexcept
    : AuctionDuration() {
    *this = ::std::move(from);
  }

  inline AuctionDuration& operator=(const AuctionDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuctionDuration& operator=(AuctionDuration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AuctionDuration& default_instance();

  static inline const AuctionDuration* internal_default_instance() {
    return reinterpret_cast<const AuctionDuration*>(
               &_AuctionDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AuctionDuration& a, AuctionDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(AuctionDuration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuctionDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuctionDuration* New() const final {
    return CreateMaybeMessage<AuctionDuration>(nullptr);
  }

  AuctionDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuctionDuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AuctionDuration& from);
  void MergeFrom(const AuctionDuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionDuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.AuctionDuration";
  }
  protected:
  explicit AuctionDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kVolumeFieldNumber = 2,
  };
  // int64 duration = 1 [json_name = "duration"];
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint64 volume = 2 [json_name = "volume"];
  void clear_volume();
  ::PROTOBUF_NAMESPACE_ID::uint64 volume() const;
  void set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_volume() const;
  void _internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.AuctionDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_;
  ::PROTOBUF_NAMESPACE_ID::uint64 volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class ContinuousTrading PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ContinuousTrading) */ {
 public:
  inline ContinuousTrading() : ContinuousTrading(nullptr) {}
  virtual ~ContinuousTrading();

  ContinuousTrading(const ContinuousTrading& from);
  ContinuousTrading(ContinuousTrading&& from) noexcept
    : ContinuousTrading() {
    *this = ::std::move(from);
  }

  inline ContinuousTrading& operator=(const ContinuousTrading& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinuousTrading& operator=(ContinuousTrading&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContinuousTrading& default_instance();

  static inline const ContinuousTrading* internal_default_instance() {
    return reinterpret_cast<const ContinuousTrading*>(
               &_ContinuousTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ContinuousTrading& a, ContinuousTrading& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinuousTrading* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinuousTrading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContinuousTrading* New() const final {
    return CreateMaybeMessage<ContinuousTrading>(nullptr);
  }

  ContinuousTrading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContinuousTrading>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContinuousTrading& from);
  void MergeFrom(const ContinuousTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinuousTrading* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ContinuousTrading";
  }
  protected:
  explicit ContinuousTrading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickSizeFieldNumber = 1,
  };
  // string tick_size = 1 [json_name = "tickSize"];
  void clear_tick_size();
  const std::string& tick_size() const;
  void set_tick_size(const std::string& value);
  void set_tick_size(std::string&& value);
  void set_tick_size(const char* value);
  void set_tick_size(const char* value, size_t size);
  std::string* mutable_tick_size();
  std::string* release_tick_size();
  void set_allocated_tick_size(std::string* tick_size);
  private:
  const std::string& _internal_tick_size() const;
  void _internal_set_tick_size(const std::string& value);
  std::string* _internal_mutable_tick_size();
  public:

  // @@protoc_insertion_point(class_scope:vega.ContinuousTrading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tick_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class DiscreteTrading PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.DiscreteTrading) */ {
 public:
  inline DiscreteTrading() : DiscreteTrading(nullptr) {}
  virtual ~DiscreteTrading();

  DiscreteTrading(const DiscreteTrading& from);
  DiscreteTrading(DiscreteTrading&& from) noexcept
    : DiscreteTrading() {
    *this = ::std::move(from);
  }

  inline DiscreteTrading& operator=(const DiscreteTrading& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscreteTrading& operator=(DiscreteTrading&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DiscreteTrading& default_instance();

  static inline const DiscreteTrading* internal_default_instance() {
    return reinterpret_cast<const DiscreteTrading*>(
               &_DiscreteTrading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DiscreteTrading& a, DiscreteTrading& b) {
    a.Swap(&b);
  }
  inline void Swap(DiscreteTrading* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscreteTrading* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiscreteTrading* New() const final {
    return CreateMaybeMessage<DiscreteTrading>(nullptr);
  }

  DiscreteTrading* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiscreteTrading>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DiscreteTrading& from);
  void MergeFrom(const DiscreteTrading& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscreteTrading* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.DiscreteTrading";
  }
  protected:
  explicit DiscreteTrading(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickSizeFieldNumber = 2,
    kDurationNsFieldNumber = 1,
  };
  // string tick_size = 2 [json_name = "tickSize"];
  void clear_tick_size();
  const std::string& tick_size() const;
  void set_tick_size(const std::string& value);
  void set_tick_size(std::string&& value);
  void set_tick_size(const char* value);
  void set_tick_size(const char* value, size_t size);
  std::string* mutable_tick_size();
  std::string* release_tick_size();
  void set_allocated_tick_size(std::string* tick_size);
  private:
  const std::string& _internal_tick_size() const;
  void _internal_set_tick_size(const std::string& value);
  std::string* _internal_mutable_tick_size();
  public:

  // int64 duration_ns = 1 [json_name = "durationNs", (.validator.field) = {
  void clear_duration_ns();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ns() const;
  void set_duration_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration_ns() const;
  void _internal_set_duration_ns(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.DiscreteTrading)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tick_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Future PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Future) */ {
 public:
  inline Future() : Future(nullptr) {}
  virtual ~Future();

  Future(const Future& from);
  Future(Future&& from) noexcept
    : Future() {
    *this = ::std::move(from);
  }

  inline Future& operator=(const Future& from) {
    CopyFrom(from);
    return *this;
  }
  inline Future& operator=(Future&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Future& default_instance();

  static inline const Future* internal_default_instance() {
    return reinterpret_cast<const Future*>(
               &_Future_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Future& a, Future& b) {
    a.Swap(&b);
  }
  inline void Swap(Future* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Future* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Future* New() const final {
    return CreateMaybeMessage<Future>(nullptr);
  }

  Future* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Future>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Future& from);
  void MergeFrom(const Future& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Future* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Future";
  }
  protected:
  explicit Future(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaturityFieldNumber = 1,
    kSettlementAssetFieldNumber = 2,
    kQuoteNameFieldNumber = 4,
    kOracleSpecFieldNumber = 5,
    kOracleSpecBindingFieldNumber = 6,
  };
  // string maturity = 1 [json_name = "maturity"];
  void clear_maturity();
  const std::string& maturity() const;
  void set_maturity(const std::string& value);
  void set_maturity(std::string&& value);
  void set_maturity(const char* value);
  void set_maturity(const char* value, size_t size);
  std::string* mutable_maturity();
  std::string* release_maturity();
  void set_allocated_maturity(std::string* maturity);
  private:
  const std::string& _internal_maturity() const;
  void _internal_set_maturity(const std::string& value);
  std::string* _internal_mutable_maturity();
  public:

  // string settlement_asset = 2 [json_name = "settlementAsset"];
  void clear_settlement_asset();
  const std::string& settlement_asset() const;
  void set_settlement_asset(const std::string& value);
  void set_settlement_asset(std::string&& value);
  void set_settlement_asset(const char* value);
  void set_settlement_asset(const char* value, size_t size);
  std::string* mutable_settlement_asset();
  std::string* release_settlement_asset();
  void set_allocated_settlement_asset(std::string* settlement_asset);
  private:
  const std::string& _internal_settlement_asset() const;
  void _internal_set_settlement_asset(const std::string& value);
  std::string* _internal_mutable_settlement_asset();
  public:

  // string quote_name = 4 [json_name = "quoteName"];
  void clear_quote_name();
  const std::string& quote_name() const;
  void set_quote_name(const std::string& value);
  void set_quote_name(std::string&& value);
  void set_quote_name(const char* value);
  void set_quote_name(const char* value, size_t size);
  std::string* mutable_quote_name();
  std::string* release_quote_name();
  void set_allocated_quote_name(std::string* quote_name);
  private:
  const std::string& _internal_quote_name() const;
  void _internal_set_quote_name(const std::string& value);
  std::string* _internal_mutable_quote_name();
  public:

  // .oracles.v1.OracleSpec oracle_spec = 5 [json_name = "oracleSpec"];
  bool has_oracle_spec() const;
  private:
  bool _internal_has_oracle_spec() const;
  public:
  void clear_oracle_spec();
  const ::oracles::v1::OracleSpec& oracle_spec() const;
  ::oracles::v1::OracleSpec* release_oracle_spec();
  ::oracles::v1::OracleSpec* mutable_oracle_spec();
  void set_allocated_oracle_spec(::oracles::v1::OracleSpec* oracle_spec);
  private:
  const ::oracles::v1::OracleSpec& _internal_oracle_spec() const;
  ::oracles::v1::OracleSpec* _internal_mutable_oracle_spec();
  public:
  void unsafe_arena_set_allocated_oracle_spec(
      ::oracles::v1::OracleSpec* oracle_spec);
  ::oracles::v1::OracleSpec* unsafe_arena_release_oracle_spec();

  // .vega.OracleSpecToFutureBinding oracle_spec_binding = 6 [json_name = "oracleSpecBinding"];
  bool has_oracle_spec_binding() const;
  private:
  bool _internal_has_oracle_spec_binding() const;
  public:
  void clear_oracle_spec_binding();
  const ::vega::OracleSpecToFutureBinding& oracle_spec_binding() const;
  ::vega::OracleSpecToFutureBinding* release_oracle_spec_binding();
  ::vega::OracleSpecToFutureBinding* mutable_oracle_spec_binding();
  void set_allocated_oracle_spec_binding(::vega::OracleSpecToFutureBinding* oracle_spec_binding);
  private:
  const ::vega::OracleSpecToFutureBinding& _internal_oracle_spec_binding() const;
  ::vega::OracleSpecToFutureBinding* _internal_mutable_oracle_spec_binding();
  public:
  void unsafe_arena_set_allocated_oracle_spec_binding(
      ::vega::OracleSpecToFutureBinding* oracle_spec_binding);
  ::vega::OracleSpecToFutureBinding* unsafe_arena_release_oracle_spec_binding();

  // @@protoc_insertion_point(class_scope:vega.Future)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maturity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_asset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_name_;
  ::oracles::v1::OracleSpec* oracle_spec_;
  ::vega::OracleSpecToFutureBinding* oracle_spec_binding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class OracleSpecToFutureBinding PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.OracleSpecToFutureBinding) */ {
 public:
  inline OracleSpecToFutureBinding() : OracleSpecToFutureBinding(nullptr) {}
  virtual ~OracleSpecToFutureBinding();

  OracleSpecToFutureBinding(const OracleSpecToFutureBinding& from);
  OracleSpecToFutureBinding(OracleSpecToFutureBinding&& from) noexcept
    : OracleSpecToFutureBinding() {
    *this = ::std::move(from);
  }

  inline OracleSpecToFutureBinding& operator=(const OracleSpecToFutureBinding& from) {
    CopyFrom(from);
    return *this;
  }
  inline OracleSpecToFutureBinding& operator=(OracleSpecToFutureBinding&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OracleSpecToFutureBinding& default_instance();

  static inline const OracleSpecToFutureBinding* internal_default_instance() {
    return reinterpret_cast<const OracleSpecToFutureBinding*>(
               &_OracleSpecToFutureBinding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OracleSpecToFutureBinding& a, OracleSpecToFutureBinding& b) {
    a.Swap(&b);
  }
  inline void Swap(OracleSpecToFutureBinding* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OracleSpecToFutureBinding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OracleSpecToFutureBinding* New() const final {
    return CreateMaybeMessage<OracleSpecToFutureBinding>(nullptr);
  }

  OracleSpecToFutureBinding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OracleSpecToFutureBinding>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OracleSpecToFutureBinding& from);
  void MergeFrom(const OracleSpecToFutureBinding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OracleSpecToFutureBinding* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.OracleSpecToFutureBinding";
  }
  protected:
  explicit OracleSpecToFutureBinding(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettlementPricePropertyFieldNumber = 1,
  };
  // string settlement_price_property = 1 [json_name = "settlementPriceProperty"];
  void clear_settlement_price_property();
  const std::string& settlement_price_property() const;
  void set_settlement_price_property(const std::string& value);
  void set_settlement_price_property(std::string&& value);
  void set_settlement_price_property(const char* value);
  void set_settlement_price_property(const char* value, size_t size);
  std::string* mutable_settlement_price_property();
  std::string* release_settlement_price_property();
  void set_allocated_settlement_price_property(std::string* settlement_price_property);
  private:
  const std::string& _internal_settlement_price_property() const;
  void _internal_set_settlement_price_property(const std::string& value);
  std::string* _internal_mutable_settlement_price_property();
  public:

  // @@protoc_insertion_point(class_scope:vega.OracleSpecToFutureBinding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settlement_price_property_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class InstrumentMetadata PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.InstrumentMetadata) */ {
 public:
  inline InstrumentMetadata() : InstrumentMetadata(nullptr) {}
  virtual ~InstrumentMetadata();

  InstrumentMetadata(const InstrumentMetadata& from);
  InstrumentMetadata(InstrumentMetadata&& from) noexcept
    : InstrumentMetadata() {
    *this = ::std::move(from);
  }

  inline InstrumentMetadata& operator=(const InstrumentMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentMetadata& operator=(InstrumentMetadata&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstrumentMetadata& default_instance();

  static inline const InstrumentMetadata* internal_default_instance() {
    return reinterpret_cast<const InstrumentMetadata*>(
               &_InstrumentMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InstrumentMetadata& a, InstrumentMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentMetadata* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstrumentMetadata* New() const final {
    return CreateMaybeMessage<InstrumentMetadata>(nullptr);
  }

  InstrumentMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstrumentMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstrumentMetadata& from);
  void MergeFrom(const InstrumentMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.InstrumentMetadata";
  }
  protected:
  explicit InstrumentMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 1,
  };
  // repeated string tags = 1 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // @@protoc_insertion_point(class_scope:vega.InstrumentMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Instrument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Instrument) */ {
 public:
  inline Instrument() : Instrument(nullptr) {}
  virtual ~Instrument();

  Instrument(const Instrument& from);
  Instrument(Instrument&& from) noexcept
    : Instrument() {
    *this = ::std::move(from);
  }

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instrument& operator=(Instrument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Instrument& default_instance();

  enum ProductCase {
    kFuture = 100,
    PRODUCT_NOT_SET = 0,
  };

  static inline const Instrument* internal_default_instance() {
    return reinterpret_cast<const Instrument*>(
               &_Instrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Instrument& a, Instrument& b) {
    a.Swap(&b);
  }
  inline void Swap(Instrument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Instrument* New() const final {
    return CreateMaybeMessage<Instrument>(nullptr);
  }

  Instrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Instrument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instrument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Instrument";
  }
  protected:
  explicit Instrument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCodeFieldNumber = 2,
    kNameFieldNumber = 3,
    kMetadataFieldNumber = 4,
    kFutureFieldNumber = 100,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string code = 2 [json_name = "code"];
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string name = 3 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vega.InstrumentMetadata metadata = 4 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::vega::InstrumentMetadata& metadata() const;
  ::vega::InstrumentMetadata* release_metadata();
  ::vega::InstrumentMetadata* mutable_metadata();
  void set_allocated_metadata(::vega::InstrumentMetadata* metadata);
  private:
  const ::vega::InstrumentMetadata& _internal_metadata() const;
  ::vega::InstrumentMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::vega::InstrumentMetadata* metadata);
  ::vega::InstrumentMetadata* unsafe_arena_release_metadata();

  // .vega.Future future = 100 [json_name = "future"];
  bool has_future() const;
  private:
  bool _internal_has_future() const;
  public:
  void clear_future();
  const ::vega::Future& future() const;
  ::vega::Future* release_future();
  ::vega::Future* mutable_future();
  void set_allocated_future(::vega::Future* future);
  private:
  const ::vega::Future& _internal_future() const;
  ::vega::Future* _internal_mutable_future();
  public:
  void unsafe_arena_set_allocated_future(
      ::vega::Future* future);
  ::vega::Future* unsafe_arena_release_future();

  void clear_product();
  ProductCase product_case() const;
  // @@protoc_insertion_point(class_scope:vega.Instrument)
 private:
  class _Internal;
  void set_has_future();

  inline bool has_product() const;
  inline void clear_has_product();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::vega::InstrumentMetadata* metadata_;
  union ProductUnion {
    ProductUnion() {}
    ::vega::Future* future_;
  } product_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalRiskModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalRiskModel) */ {
 public:
  inline LogNormalRiskModel() : LogNormalRiskModel(nullptr) {}
  virtual ~LogNormalRiskModel();

  LogNormalRiskModel(const LogNormalRiskModel& from);
  LogNormalRiskModel(LogNormalRiskModel&& from) noexcept
    : LogNormalRiskModel() {
    *this = ::std::move(from);
  }

  inline LogNormalRiskModel& operator=(const LogNormalRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogNormalRiskModel& operator=(LogNormalRiskModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogNormalRiskModel& default_instance();

  static inline const LogNormalRiskModel* internal_default_instance() {
    return reinterpret_cast<const LogNormalRiskModel*>(
               &_LogNormalRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LogNormalRiskModel& a, LogNormalRiskModel& b) {
    a.Swap(&b);
  }
  inline void Swap(LogNormalRiskModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogNormalRiskModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogNormalRiskModel* New() const final {
    return CreateMaybeMessage<LogNormalRiskModel>(nullptr);
  }

  LogNormalRiskModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalRiskModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogNormalRiskModel& from);
  void MergeFrom(const LogNormalRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalRiskModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.LogNormalRiskModel";
  }
  protected:
  explicit LogNormalRiskModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kRiskAversionParameterFieldNumber = 1,
    kTauFieldNumber = 2,
  };
  // .vega.LogNormalModelParams params = 3 [json_name = "params"];
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::vega::LogNormalModelParams& params() const;
  ::vega::LogNormalModelParams* release_params();
  ::vega::LogNormalModelParams* mutable_params();
  void set_allocated_params(::vega::LogNormalModelParams* params);
  private:
  const ::vega::LogNormalModelParams& _internal_params() const;
  ::vega::LogNormalModelParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::vega::LogNormalModelParams* params);
  ::vega::LogNormalModelParams* unsafe_arena_release_params();

  // double risk_aversion_parameter = 1 [json_name = "riskAversionParameter"];
  void clear_risk_aversion_parameter();
  double risk_aversion_parameter() const;
  void set_risk_aversion_parameter(double value);
  private:
  double _internal_risk_aversion_parameter() const;
  void _internal_set_risk_aversion_parameter(double value);
  public:

  // double tau = 2 [json_name = "tau"];
  void clear_tau();
  double tau() const;
  void set_tau(double value);
  private:
  double _internal_tau() const;
  void _internal_set_tau(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.LogNormalRiskModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::LogNormalModelParams* params_;
  double risk_aversion_parameter_;
  double tau_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class LogNormalModelParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.LogNormalModelParams) */ {
 public:
  inline LogNormalModelParams() : LogNormalModelParams(nullptr) {}
  virtual ~LogNormalModelParams();

  LogNormalModelParams(const LogNormalModelParams& from);
  LogNormalModelParams(LogNormalModelParams&& from) noexcept
    : LogNormalModelParams() {
    *this = ::std::move(from);
  }

  inline LogNormalModelParams& operator=(const LogNormalModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogNormalModelParams& operator=(LogNormalModelParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogNormalModelParams& default_instance();

  static inline const LogNormalModelParams* internal_default_instance() {
    return reinterpret_cast<const LogNormalModelParams*>(
               &_LogNormalModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogNormalModelParams& a, LogNormalModelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(LogNormalModelParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogNormalModelParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogNormalModelParams* New() const final {
    return CreateMaybeMessage<LogNormalModelParams>(nullptr);
  }

  LogNormalModelParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogNormalModelParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogNormalModelParams& from);
  void MergeFrom(const LogNormalModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogNormalModelParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.LogNormalModelParams";
  }
  protected:
  explicit LogNormalModelParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMuFieldNumber = 1,
    kRFieldNumber = 2,
    kSigmaFieldNumber = 3,
  };
  // double mu = 1 [json_name = "mu"];
  void clear_mu();
  double mu() const;
  void set_mu(double value);
  private:
  double _internal_mu() const;
  void _internal_set_mu(double value);
  public:

  // double r = 2 [json_name = "r"];
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double sigma = 3 [json_name = "sigma"];
  void clear_sigma();
  double sigma() const;
  void set_sigma(double value);
  private:
  double _internal_sigma() const;
  void _internal_set_sigma(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.LogNormalModelParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double mu_;
  double r_;
  double sigma_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class SimpleRiskModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.SimpleRiskModel) */ {
 public:
  inline SimpleRiskModel() : SimpleRiskModel(nullptr) {}
  virtual ~SimpleRiskModel();

  SimpleRiskModel(const SimpleRiskModel& from);
  SimpleRiskModel(SimpleRiskModel&& from) noexcept
    : SimpleRiskModel() {
    *this = ::std::move(from);
  }

  inline SimpleRiskModel& operator=(const SimpleRiskModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleRiskModel& operator=(SimpleRiskModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimpleRiskModel& default_instance();

  static inline const SimpleRiskModel* internal_default_instance() {
    return reinterpret_cast<const SimpleRiskModel*>(
               &_SimpleRiskModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimpleRiskModel& a, SimpleRiskModel& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleRiskModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleRiskModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimpleRiskModel* New() const final {
    return CreateMaybeMessage<SimpleRiskModel>(nullptr);
  }

  SimpleRiskModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimpleRiskModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimpleRiskModel& from);
  void MergeFrom(const SimpleRiskModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleRiskModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.SimpleRiskModel";
  }
  protected:
  explicit SimpleRiskModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // .vega.SimpleModelParams params = 1 [json_name = "params"];
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::vega::SimpleModelParams& params() const;
  ::vega::SimpleModelParams* release_params();
  ::vega::SimpleModelParams* mutable_params();
  void set_allocated_params(::vega::SimpleModelParams* params);
  private:
  const ::vega::SimpleModelParams& _internal_params() const;
  ::vega::SimpleModelParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::vega::SimpleModelParams* params);
  ::vega::SimpleModelParams* unsafe_arena_release_params();

  // @@protoc_insertion_point(class_scope:vega.SimpleRiskModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::SimpleModelParams* params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class SimpleModelParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.SimpleModelParams) */ {
 public:
  inline SimpleModelParams() : SimpleModelParams(nullptr) {}
  virtual ~SimpleModelParams();

  SimpleModelParams(const SimpleModelParams& from);
  SimpleModelParams(SimpleModelParams&& from) noexcept
    : SimpleModelParams() {
    *this = ::std::move(from);
  }

  inline SimpleModelParams& operator=(const SimpleModelParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleModelParams& operator=(SimpleModelParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimpleModelParams& default_instance();

  static inline const SimpleModelParams* internal_default_instance() {
    return reinterpret_cast<const SimpleModelParams*>(
               &_SimpleModelParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SimpleModelParams& a, SimpleModelParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleModelParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleModelParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimpleModelParams* New() const final {
    return CreateMaybeMessage<SimpleModelParams>(nullptr);
  }

  SimpleModelParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimpleModelParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimpleModelParams& from);
  void MergeFrom(const SimpleModelParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleModelParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.SimpleModelParams";
  }
  protected:
  explicit SimpleModelParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactorLongFieldNumber = 1,
    kFactorShortFieldNumber = 2,
    kMaxMoveUpFieldNumber = 3,
    kMinMoveDownFieldNumber = 4,
    kProbabilityOfTradingFieldNumber = 5,
  };
  // double factor_long = 1 [json_name = "factorLong"];
  void clear_factor_long();
  double factor_long() const;
  void set_factor_long(double value);
  private:
  double _internal_factor_long() const;
  void _internal_set_factor_long(double value);
  public:

  // double factor_short = 2 [json_name = "factorShort"];
  void clear_factor_short();
  double factor_short() const;
  void set_factor_short(double value);
  private:
  double _internal_factor_short() const;
  void _internal_set_factor_short(double value);
  public:

  // double max_move_up = 3 [json_name = "maxMoveUp", (.validator.field) = {
  void clear_max_move_up();
  double max_move_up() const;
  void set_max_move_up(double value);
  private:
  double _internal_max_move_up() const;
  void _internal_set_max_move_up(double value);
  public:

  // double min_move_down = 4 [json_name = "minMoveDown", (.validator.field) = {
  void clear_min_move_down();
  double min_move_down() const;
  void set_min_move_down(double value);
  private:
  double _internal_min_move_down() const;
  void _internal_set_min_move_down(double value);
  public:

  // double probability_of_trading = 5 [json_name = "probabilityOfTrading", (.validator.field) = {
  void clear_probability_of_trading();
  double probability_of_trading() const;
  void set_probability_of_trading(double value);
  private:
  double _internal_probability_of_trading() const;
  void _internal_set_probability_of_trading(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.SimpleModelParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double factor_long_;
  double factor_short_;
  double max_move_up_;
  double min_move_down_;
  double probability_of_trading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class ScalingFactors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.ScalingFactors) */ {
 public:
  inline ScalingFactors() : ScalingFactors(nullptr) {}
  virtual ~ScalingFactors();

  ScalingFactors(const ScalingFactors& from);
  ScalingFactors(ScalingFactors&& from) noexcept
    : ScalingFactors() {
    *this = ::std::move(from);
  }

  inline ScalingFactors& operator=(const ScalingFactors& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalingFactors& operator=(ScalingFactors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScalingFactors& default_instance();

  static inline const ScalingFactors* internal_default_instance() {
    return reinterpret_cast<const ScalingFactors*>(
               &_ScalingFactors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ScalingFactors& a, ScalingFactors& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalingFactors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalingFactors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScalingFactors* New() const final {
    return CreateMaybeMessage<ScalingFactors>(nullptr);
  }

  ScalingFactors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScalingFactors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScalingFactors& from);
  void MergeFrom(const ScalingFactors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScalingFactors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.ScalingFactors";
  }
  protected:
  explicit ScalingFactors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchLevelFieldNumber = 1,
    kInitialMarginFieldNumber = 2,
    kCollateralReleaseFieldNumber = 3,
  };
  // double search_level = 1 [json_name = "searchLevel"];
  void clear_search_level();
  double search_level() const;
  void set_search_level(double value);
  private:
  double _internal_search_level() const;
  void _internal_set_search_level(double value);
  public:

  // double initial_margin = 2 [json_name = "initialMargin"];
  void clear_initial_margin();
  double initial_margin() const;
  void set_initial_margin(double value);
  private:
  double _internal_initial_margin() const;
  void _internal_set_initial_margin(double value);
  public:

  // double collateral_release = 3 [json_name = "collateralRelease"];
  void clear_collateral_release();
  double collateral_release() const;
  void set_collateral_release(double value);
  private:
  double _internal_collateral_release() const;
  void _internal_set_collateral_release(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.ScalingFactors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double search_level_;
  double initial_margin_;
  double collateral_release_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class MarginCalculator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.MarginCalculator) */ {
 public:
  inline MarginCalculator() : MarginCalculator(nullptr) {}
  virtual ~MarginCalculator();

  MarginCalculator(const MarginCalculator& from);
  MarginCalculator(MarginCalculator&& from) noexcept
    : MarginCalculator() {
    *this = ::std::move(from);
  }

  inline MarginCalculator& operator=(const MarginCalculator& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarginCalculator& operator=(MarginCalculator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarginCalculator& default_instance();

  static inline const MarginCalculator* internal_default_instance() {
    return reinterpret_cast<const MarginCalculator*>(
               &_MarginCalculator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MarginCalculator& a, MarginCalculator& b) {
    a.Swap(&b);
  }
  inline void Swap(MarginCalculator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarginCalculator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarginCalculator* New() const final {
    return CreateMaybeMessage<MarginCalculator>(nullptr);
  }

  MarginCalculator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarginCalculator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarginCalculator& from);
  void MergeFrom(const MarginCalculator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarginCalculator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.MarginCalculator";
  }
  protected:
  explicit MarginCalculator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScalingFactorsFieldNumber = 1,
  };
  // .vega.ScalingFactors scaling_factors = 1 [json_name = "scalingFactors"];
  bool has_scaling_factors() const;
  private:
  bool _internal_has_scaling_factors() const;
  public:
  void clear_scaling_factors();
  const ::vega::ScalingFactors& scaling_factors() const;
  ::vega::ScalingFactors* release_scaling_factors();
  ::vega::ScalingFactors* mutable_scaling_factors();
  void set_allocated_scaling_factors(::vega::ScalingFactors* scaling_factors);
  private:
  const ::vega::ScalingFactors& _internal_scaling_factors() const;
  ::vega::ScalingFactors* _internal_mutable_scaling_factors();
  public:
  void unsafe_arena_set_allocated_scaling_factors(
      ::vega::ScalingFactors* scaling_factors);
  ::vega::ScalingFactors* unsafe_arena_release_scaling_factors();

  // @@protoc_insertion_point(class_scope:vega.MarginCalculator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::ScalingFactors* scaling_factors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class TradableInstrument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.TradableInstrument) */ {
 public:
  inline TradableInstrument() : TradableInstrument(nullptr) {}
  virtual ~TradableInstrument();

  TradableInstrument(const TradableInstrument& from);
  TradableInstrument(TradableInstrument&& from) noexcept
    : TradableInstrument() {
    *this = ::std::move(from);
  }

  inline TradableInstrument& operator=(const TradableInstrument& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradableInstrument& operator=(TradableInstrument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TradableInstrument& default_instance();

  enum RiskModelCase {
    kLogNormalRiskModel = 100,
    kSimpleRiskModel = 101,
    RISK_MODEL_NOT_SET = 0,
  };

  static inline const TradableInstrument* internal_default_instance() {
    return reinterpret_cast<const TradableInstrument*>(
               &_TradableInstrument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TradableInstrument& a, TradableInstrument& b) {
    a.Swap(&b);
  }
  inline void Swap(TradableInstrument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradableInstrument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TradableInstrument* New() const final {
    return CreateMaybeMessage<TradableInstrument>(nullptr);
  }

  TradableInstrument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TradableInstrument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TradableInstrument& from);
  void MergeFrom(const TradableInstrument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradableInstrument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.TradableInstrument";
  }
  protected:
  explicit TradableInstrument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrumentFieldNumber = 1,
    kMarginCalculatorFieldNumber = 2,
    kLogNormalRiskModelFieldNumber = 100,
    kSimpleRiskModelFieldNumber = 101,
  };
  // .vega.Instrument instrument = 1 [json_name = "instrument"];
  bool has_instrument() const;
  private:
  bool _internal_has_instrument() const;
  public:
  void clear_instrument();
  const ::vega::Instrument& instrument() const;
  ::vega::Instrument* release_instrument();
  ::vega::Instrument* mutable_instrument();
  void set_allocated_instrument(::vega::Instrument* instrument);
  private:
  const ::vega::Instrument& _internal_instrument() const;
  ::vega::Instrument* _internal_mutable_instrument();
  public:
  void unsafe_arena_set_allocated_instrument(
      ::vega::Instrument* instrument);
  ::vega::Instrument* unsafe_arena_release_instrument();

  // .vega.MarginCalculator margin_calculator = 2 [json_name = "marginCalculator"];
  bool has_margin_calculator() const;
  private:
  bool _internal_has_margin_calculator() const;
  public:
  void clear_margin_calculator();
  const ::vega::MarginCalculator& margin_calculator() const;
  ::vega::MarginCalculator* release_margin_calculator();
  ::vega::MarginCalculator* mutable_margin_calculator();
  void set_allocated_margin_calculator(::vega::MarginCalculator* margin_calculator);
  private:
  const ::vega::MarginCalculator& _internal_margin_calculator() const;
  ::vega::MarginCalculator* _internal_mutable_margin_calculator();
  public:
  void unsafe_arena_set_allocated_margin_calculator(
      ::vega::MarginCalculator* margin_calculator);
  ::vega::MarginCalculator* unsafe_arena_release_margin_calculator();

  // .vega.LogNormalRiskModel log_normal_risk_model = 100 [json_name = "logNormalRiskModel"];
  bool has_log_normal_risk_model() const;
  private:
  bool _internal_has_log_normal_risk_model() const;
  public:
  void clear_log_normal_risk_model();
  const ::vega::LogNormalRiskModel& log_normal_risk_model() const;
  ::vega::LogNormalRiskModel* release_log_normal_risk_model();
  ::vega::LogNormalRiskModel* mutable_log_normal_risk_model();
  void set_allocated_log_normal_risk_model(::vega::LogNormalRiskModel* log_normal_risk_model);
  private:
  const ::vega::LogNormalRiskModel& _internal_log_normal_risk_model() const;
  ::vega::LogNormalRiskModel* _internal_mutable_log_normal_risk_model();
  public:
  void unsafe_arena_set_allocated_log_normal_risk_model(
      ::vega::LogNormalRiskModel* log_normal_risk_model);
  ::vega::LogNormalRiskModel* unsafe_arena_release_log_normal_risk_model();

  // .vega.SimpleRiskModel simple_risk_model = 101 [json_name = "simpleRiskModel"];
  bool has_simple_risk_model() const;
  private:
  bool _internal_has_simple_risk_model() const;
  public:
  void clear_simple_risk_model();
  const ::vega::SimpleRiskModel& simple_risk_model() const;
  ::vega::SimpleRiskModel* release_simple_risk_model();
  ::vega::SimpleRiskModel* mutable_simple_risk_model();
  void set_allocated_simple_risk_model(::vega::SimpleRiskModel* simple_risk_model);
  private:
  const ::vega::SimpleRiskModel& _internal_simple_risk_model() const;
  ::vega::SimpleRiskModel* _internal_mutable_simple_risk_model();
  public:
  void unsafe_arena_set_allocated_simple_risk_model(
      ::vega::SimpleRiskModel* simple_risk_model);
  ::vega::SimpleRiskModel* unsafe_arena_release_simple_risk_model();

  void clear_risk_model();
  RiskModelCase risk_model_case() const;
  // @@protoc_insertion_point(class_scope:vega.TradableInstrument)
 private:
  class _Internal;
  void set_has_log_normal_risk_model();
  void set_has_simple_risk_model();

  inline bool has_risk_model() const;
  inline void clear_has_risk_model();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::Instrument* instrument_;
  ::vega::MarginCalculator* margin_calculator_;
  union RiskModelUnion {
    RiskModelUnion() {}
    ::vega::LogNormalRiskModel* log_normal_risk_model_;
    ::vega::SimpleRiskModel* simple_risk_model_;
  } risk_model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class FeeFactors PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.FeeFactors) */ {
 public:
  inline FeeFactors() : FeeFactors(nullptr) {}
  virtual ~FeeFactors();

  FeeFactors(const FeeFactors& from);
  FeeFactors(FeeFactors&& from) noexcept
    : FeeFactors() {
    *this = ::std::move(from);
  }

  inline FeeFactors& operator=(const FeeFactors& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeeFactors& operator=(FeeFactors&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeeFactors& default_instance();

  static inline const FeeFactors* internal_default_instance() {
    return reinterpret_cast<const FeeFactors*>(
               &_FeeFactors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FeeFactors& a, FeeFactors& b) {
    a.Swap(&b);
  }
  inline void Swap(FeeFactors* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeeFactors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeeFactors* New() const final {
    return CreateMaybeMessage<FeeFactors>(nullptr);
  }

  FeeFactors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeeFactors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeeFactors& from);
  void MergeFrom(const FeeFactors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeeFactors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.FeeFactors";
  }
  protected:
  explicit FeeFactors(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMakerFeeFieldNumber = 1,
    kInfrastructureFeeFieldNumber = 2,
    kLiquidityFeeFieldNumber = 3,
  };
  // string maker_fee = 1 [json_name = "makerFee"];
  void clear_maker_fee();
  const std::string& maker_fee() const;
  void set_maker_fee(const std::string& value);
  void set_maker_fee(std::string&& value);
  void set_maker_fee(const char* value);
  void set_maker_fee(const char* value, size_t size);
  std::string* mutable_maker_fee();
  std::string* release_maker_fee();
  void set_allocated_maker_fee(std::string* maker_fee);
  private:
  const std::string& _internal_maker_fee() const;
  void _internal_set_maker_fee(const std::string& value);
  std::string* _internal_mutable_maker_fee();
  public:

  // string infrastructure_fee = 2 [json_name = "infrastructureFee"];
  void clear_infrastructure_fee();
  const std::string& infrastructure_fee() const;
  void set_infrastructure_fee(const std::string& value);
  void set_infrastructure_fee(std::string&& value);
  void set_infrastructure_fee(const char* value);
  void set_infrastructure_fee(const char* value, size_t size);
  std::string* mutable_infrastructure_fee();
  std::string* release_infrastructure_fee();
  void set_allocated_infrastructure_fee(std::string* infrastructure_fee);
  private:
  const std::string& _internal_infrastructure_fee() const;
  void _internal_set_infrastructure_fee(const std::string& value);
  std::string* _internal_mutable_infrastructure_fee();
  public:

  // string liquidity_fee = 3 [json_name = "liquidityFee"];
  void clear_liquidity_fee();
  const std::string& liquidity_fee() const;
  void set_liquidity_fee(const std::string& value);
  void set_liquidity_fee(std::string&& value);
  void set_liquidity_fee(const char* value);
  void set_liquidity_fee(const char* value, size_t size);
  std::string* mutable_liquidity_fee();
  std::string* release_liquidity_fee();
  void set_allocated_liquidity_fee(std::string* liquidity_fee);
  private:
  const std::string& _internal_liquidity_fee() const;
  void _internal_set_liquidity_fee(const std::string& value);
  std::string* _internal_mutable_liquidity_fee();
  public:

  // @@protoc_insertion_point(class_scope:vega.FeeFactors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maker_fee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr infrastructure_fee_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr liquidity_fee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Fees PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Fees) */ {
 public:
  inline Fees() : Fees(nullptr) {}
  virtual ~Fees();

  Fees(const Fees& from);
  Fees(Fees&& from) noexcept
    : Fees() {
    *this = ::std::move(from);
  }

  inline Fees& operator=(const Fees& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fees& operator=(Fees&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fees& default_instance();

  static inline const Fees* internal_default_instance() {
    return reinterpret_cast<const Fees*>(
               &_Fees_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Fees& a, Fees& b) {
    a.Swap(&b);
  }
  inline void Swap(Fees* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fees* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fees* New() const final {
    return CreateMaybeMessage<Fees>(nullptr);
  }

  Fees* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fees>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fees& from);
  void MergeFrom(const Fees& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fees* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Fees";
  }
  protected:
  explicit Fees(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactorsFieldNumber = 1,
  };
  // .vega.FeeFactors factors = 1 [json_name = "factors"];
  bool has_factors() const;
  private:
  bool _internal_has_factors() const;
  public:
  void clear_factors();
  const ::vega::FeeFactors& factors() const;
  ::vega::FeeFactors* release_factors();
  ::vega::FeeFactors* mutable_factors();
  void set_allocated_factors(::vega::FeeFactors* factors);
  private:
  const ::vega::FeeFactors& _internal_factors() const;
  ::vega::FeeFactors* _internal_mutable_factors();
  public:
  void unsafe_arena_set_allocated_factors(
      ::vega::FeeFactors* factors);
  ::vega::FeeFactors* unsafe_arena_release_factors();

  // @@protoc_insertion_point(class_scope:vega.Fees)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::FeeFactors* factors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringTrigger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringTrigger) */ {
 public:
  inline PriceMonitoringTrigger() : PriceMonitoringTrigger(nullptr) {}
  virtual ~PriceMonitoringTrigger();

  PriceMonitoringTrigger(const PriceMonitoringTrigger& from);
  PriceMonitoringTrigger(PriceMonitoringTrigger&& from) noexcept
    : PriceMonitoringTrigger() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringTrigger& operator=(const PriceMonitoringTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringTrigger& operator=(PriceMonitoringTrigger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringTrigger& default_instance();

  static inline const PriceMonitoringTrigger* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringTrigger*>(
               &_PriceMonitoringTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PriceMonitoringTrigger& a, PriceMonitoringTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringTrigger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringTrigger* New() const final {
    return CreateMaybeMessage<PriceMonitoringTrigger>(nullptr);
  }

  PriceMonitoringTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringTrigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringTrigger& from);
  void MergeFrom(const PriceMonitoringTrigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringTrigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringTrigger";
  }
  protected:
  explicit PriceMonitoringTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorizonFieldNumber = 1,
    kProbabilityFieldNumber = 2,
    kAuctionExtensionFieldNumber = 3,
  };
  // int64 horizon = 1 [json_name = "horizon", (.validator.field) = {
  void clear_horizon();
  ::PROTOBUF_NAMESPACE_ID::int64 horizon() const;
  void set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_horizon() const;
  void _internal_set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double probability = 2 [json_name = "probability", (.validator.field) = {
  void clear_probability();
  double probability() const;
  void set_probability(double value);
  private:
  double _internal_probability() const;
  void _internal_set_probability(double value);
  public:

  // int64 auction_extension = 3 [json_name = "auctionExtension", (.validator.field) = {
  void clear_auction_extension();
  ::PROTOBUF_NAMESPACE_ID::int64 auction_extension() const;
  void set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_auction_extension() const;
  void _internal_set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 horizon_;
  double probability_;
  ::PROTOBUF_NAMESPACE_ID::int64 auction_extension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringParameters) */ {
 public:
  inline PriceMonitoringParameters() : PriceMonitoringParameters(nullptr) {}
  virtual ~PriceMonitoringParameters();

  PriceMonitoringParameters(const PriceMonitoringParameters& from);
  PriceMonitoringParameters(PriceMonitoringParameters&& from) noexcept
    : PriceMonitoringParameters() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringParameters& operator=(const PriceMonitoringParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringParameters& operator=(PriceMonitoringParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringParameters& default_instance();

  static inline const PriceMonitoringParameters* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringParameters*>(
               &_PriceMonitoringParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PriceMonitoringParameters& a, PriceMonitoringParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringParameters* New() const final {
    return CreateMaybeMessage<PriceMonitoringParameters>(nullptr);
  }

  PriceMonitoringParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringParameters& from);
  void MergeFrom(const PriceMonitoringParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringParameters";
  }
  protected:
  explicit PriceMonitoringParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggersFieldNumber = 1,
  };
  // repeated .vega.PriceMonitoringTrigger triggers = 1 [json_name = "triggers"];
  int triggers_size() const;
  private:
  int _internal_triggers_size() const;
  public:
  void clear_triggers();
  ::vega::PriceMonitoringTrigger* mutable_triggers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >*
      mutable_triggers();
  private:
  const ::vega::PriceMonitoringTrigger& _internal_triggers(int index) const;
  ::vega::PriceMonitoringTrigger* _internal_add_triggers();
  public:
  const ::vega::PriceMonitoringTrigger& triggers(int index) const;
  ::vega::PriceMonitoringTrigger* add_triggers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >&
      triggers() const;

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger > triggers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class PriceMonitoringSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.PriceMonitoringSettings) */ {
 public:
  inline PriceMonitoringSettings() : PriceMonitoringSettings(nullptr) {}
  virtual ~PriceMonitoringSettings();

  PriceMonitoringSettings(const PriceMonitoringSettings& from);
  PriceMonitoringSettings(PriceMonitoringSettings&& from) noexcept
    : PriceMonitoringSettings() {
    *this = ::std::move(from);
  }

  inline PriceMonitoringSettings& operator=(const PriceMonitoringSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PriceMonitoringSettings& operator=(PriceMonitoringSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PriceMonitoringSettings& default_instance();

  static inline const PriceMonitoringSettings* internal_default_instance() {
    return reinterpret_cast<const PriceMonitoringSettings*>(
               &_PriceMonitoringSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PriceMonitoringSettings& a, PriceMonitoringSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PriceMonitoringSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PriceMonitoringSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PriceMonitoringSettings* New() const final {
    return CreateMaybeMessage<PriceMonitoringSettings>(nullptr);
  }

  PriceMonitoringSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PriceMonitoringSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PriceMonitoringSettings& from);
  void MergeFrom(const PriceMonitoringSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriceMonitoringSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.PriceMonitoringSettings";
  }
  protected:
  explicit PriceMonitoringSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 1,
    kUpdateFrequencyFieldNumber = 2,
  };
  // .vega.PriceMonitoringParameters parameters = 1 [json_name = "parameters"];
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::vega::PriceMonitoringParameters& parameters() const;
  ::vega::PriceMonitoringParameters* release_parameters();
  ::vega::PriceMonitoringParameters* mutable_parameters();
  void set_allocated_parameters(::vega::PriceMonitoringParameters* parameters);
  private:
  const ::vega::PriceMonitoringParameters& _internal_parameters() const;
  ::vega::PriceMonitoringParameters* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::vega::PriceMonitoringParameters* parameters);
  ::vega::PriceMonitoringParameters* unsafe_arena_release_parameters();

  // int64 update_frequency = 2 [json_name = "updateFrequency"];
  void clear_update_frequency();
  ::PROTOBUF_NAMESPACE_ID::int64 update_frequency() const;
  void set_update_frequency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_update_frequency() const;
  void _internal_set_update_frequency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.PriceMonitoringSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::PriceMonitoringParameters* parameters_;
  ::PROTOBUF_NAMESPACE_ID::int64 update_frequency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class LiquidityMonitoringParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.LiquidityMonitoringParameters) */ {
 public:
  inline LiquidityMonitoringParameters() : LiquidityMonitoringParameters(nullptr) {}
  virtual ~LiquidityMonitoringParameters();

  LiquidityMonitoringParameters(const LiquidityMonitoringParameters& from);
  LiquidityMonitoringParameters(LiquidityMonitoringParameters&& from) noexcept
    : LiquidityMonitoringParameters() {
    *this = ::std::move(from);
  }

  inline LiquidityMonitoringParameters& operator=(const LiquidityMonitoringParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiquidityMonitoringParameters& operator=(LiquidityMonitoringParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LiquidityMonitoringParameters& default_instance();

  static inline const LiquidityMonitoringParameters* internal_default_instance() {
    return reinterpret_cast<const LiquidityMonitoringParameters*>(
               &_LiquidityMonitoringParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LiquidityMonitoringParameters& a, LiquidityMonitoringParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(LiquidityMonitoringParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiquidityMonitoringParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LiquidityMonitoringParameters* New() const final {
    return CreateMaybeMessage<LiquidityMonitoringParameters>(nullptr);
  }

  LiquidityMonitoringParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LiquidityMonitoringParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LiquidityMonitoringParameters& from);
  void MergeFrom(const LiquidityMonitoringParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiquidityMonitoringParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.LiquidityMonitoringParameters";
  }
  protected:
  explicit LiquidityMonitoringParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetStakeParametersFieldNumber = 1,
    kTriggeringRatioFieldNumber = 2,
    kAuctionExtensionFieldNumber = 3,
  };
  // .vega.TargetStakeParameters target_stake_parameters = 1 [json_name = "targetStakeParameters"];
  bool has_target_stake_parameters() const;
  private:
  bool _internal_has_target_stake_parameters() const;
  public:
  void clear_target_stake_parameters();
  const ::vega::TargetStakeParameters& target_stake_parameters() const;
  ::vega::TargetStakeParameters* release_target_stake_parameters();
  ::vega::TargetStakeParameters* mutable_target_stake_parameters();
  void set_allocated_target_stake_parameters(::vega::TargetStakeParameters* target_stake_parameters);
  private:
  const ::vega::TargetStakeParameters& _internal_target_stake_parameters() const;
  ::vega::TargetStakeParameters* _internal_mutable_target_stake_parameters();
  public:
  void unsafe_arena_set_allocated_target_stake_parameters(
      ::vega::TargetStakeParameters* target_stake_parameters);
  ::vega::TargetStakeParameters* unsafe_arena_release_target_stake_parameters();

  // double triggering_ratio = 2 [json_name = "triggeringRatio", (.validator.field) = {
  void clear_triggering_ratio();
  double triggering_ratio() const;
  void set_triggering_ratio(double value);
  private:
  double _internal_triggering_ratio() const;
  void _internal_set_triggering_ratio(double value);
  public:

  // int64 auction_extension = 3 [json_name = "auctionExtension"];
  void clear_auction_extension();
  ::PROTOBUF_NAMESPACE_ID::int64 auction_extension() const;
  void set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_auction_extension() const;
  void _internal_set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.LiquidityMonitoringParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::vega::TargetStakeParameters* target_stake_parameters_;
  double triggering_ratio_;
  ::PROTOBUF_NAMESPACE_ID::int64 auction_extension_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class TargetStakeParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.TargetStakeParameters) */ {
 public:
  inline TargetStakeParameters() : TargetStakeParameters(nullptr) {}
  virtual ~TargetStakeParameters();

  TargetStakeParameters(const TargetStakeParameters& from);
  TargetStakeParameters(TargetStakeParameters&& from) noexcept
    : TargetStakeParameters() {
    *this = ::std::move(from);
  }

  inline TargetStakeParameters& operator=(const TargetStakeParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetStakeParameters& operator=(TargetStakeParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TargetStakeParameters& default_instance();

  static inline const TargetStakeParameters* internal_default_instance() {
    return reinterpret_cast<const TargetStakeParameters*>(
               &_TargetStakeParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TargetStakeParameters& a, TargetStakeParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetStakeParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetStakeParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetStakeParameters* New() const final {
    return CreateMaybeMessage<TargetStakeParameters>(nullptr);
  }

  TargetStakeParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetStakeParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TargetStakeParameters& from);
  void MergeFrom(const TargetStakeParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetStakeParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.TargetStakeParameters";
  }
  protected:
  explicit TargetStakeParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeWindowFieldNumber = 1,
    kScalingFactorFieldNumber = 2,
  };
  // int64 time_window = 1 [json_name = "timeWindow", (.validator.field) = {
  void clear_time_window();
  ::PROTOBUF_NAMESPACE_ID::int64 time_window() const;
  void set_time_window(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_window() const;
  void _internal_set_time_window(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // double scaling_factor = 2 [json_name = "scalingFactor", (.validator.field) = {
  void clear_scaling_factor();
  double scaling_factor() const;
  void set_scaling_factor(double value);
  private:
  double _internal_scaling_factor() const;
  void _internal_set_scaling_factor(double value);
  public:

  // @@protoc_insertion_point(class_scope:vega.TargetStakeParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_window_;
  double scaling_factor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class Market PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.Market) */ {
 public:
  inline Market() : Market(nullptr) {}
  virtual ~Market();

  Market(const Market& from);
  Market(Market&& from) noexcept
    : Market() {
    *this = ::std::move(from);
  }

  inline Market& operator=(const Market& from) {
    CopyFrom(from);
    return *this;
  }
  inline Market& operator=(Market&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Market& default_instance();

  enum TradingModeConfigCase {
    kContinuous = 100,
    kDiscrete = 101,
    TRADING_MODE_CONFIG_NOT_SET = 0,
  };

  static inline const Market* internal_default_instance() {
    return reinterpret_cast<const Market*>(
               &_Market_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Market& a, Market& b) {
    a.Swap(&b);
  }
  inline void Swap(Market* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Market* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Market* New() const final {
    return CreateMaybeMessage<Market>(nullptr);
  }

  Market* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Market>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Market& from);
  void MergeFrom(const Market& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Market* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.Market";
  }
  protected:
  explicit Market(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Market_State State;
  static constexpr State STATE_UNSPECIFIED =
    Market_State_STATE_UNSPECIFIED;
  static constexpr State STATE_PROPOSED =
    Market_State_STATE_PROPOSED;
  static constexpr State STATE_REJECTED =
    Market_State_STATE_REJECTED;
  static constexpr State STATE_PENDING =
    Market_State_STATE_PENDING;
  static constexpr State STATE_CANCELLED =
    Market_State_STATE_CANCELLED;
  static constexpr State STATE_ACTIVE =
    Market_State_STATE_ACTIVE;
  static constexpr State STATE_SUSPENDED =
    Market_State_STATE_SUSPENDED;
  static constexpr State STATE_CLOSED =
    Market_State_STATE_CLOSED;
  static constexpr State STATE_TRADING_TERMINATED =
    Market_State_STATE_TRADING_TERMINATED;
  static constexpr State STATE_SETTLED =
    Market_State_STATE_SETTLED;
  static inline bool State_IsValid(int value) {
    return Market_State_IsValid(value);
  }
  static constexpr State State_MIN =
    Market_State_State_MIN;
  static constexpr State State_MAX =
    Market_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    Market_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return Market_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return Market_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return Market_State_Parse(name, value);
  }

  typedef Market_TradingMode TradingMode;
  static constexpr TradingMode TRADING_MODE_UNSPECIFIED =
    Market_TradingMode_TRADING_MODE_UNSPECIFIED;
  static constexpr TradingMode TRADING_MODE_CONTINUOUS =
    Market_TradingMode_TRADING_MODE_CONTINUOUS;
  static constexpr TradingMode TRADING_MODE_BATCH_AUCTION =
    Market_TradingMode_TRADING_MODE_BATCH_AUCTION;
  static constexpr TradingMode TRADING_MODE_OPENING_AUCTION =
    Market_TradingMode_TRADING_MODE_OPENING_AUCTION;
  static constexpr TradingMode TRADING_MODE_MONITORING_AUCTION =
    Market_TradingMode_TRADING_MODE_MONITORING_AUCTION;
  static inline bool TradingMode_IsValid(int value) {
    return Market_TradingMode_IsValid(value);
  }
  static constexpr TradingMode TradingMode_MIN =
    Market_TradingMode_TradingMode_MIN;
  static constexpr TradingMode TradingMode_MAX =
    Market_TradingMode_TradingMode_MAX;
  static constexpr int TradingMode_ARRAYSIZE =
    Market_TradingMode_TradingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TradingMode_descriptor() {
    return Market_TradingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& TradingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TradingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TradingMode_Name.");
    return Market_TradingMode_Name(enum_t_value);
  }
  static inline bool TradingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TradingMode* value) {
    return Market_TradingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTradableInstrumentFieldNumber = 2,
    kFeesFieldNumber = 4,
    kOpeningAuctionFieldNumber = 5,
    kPriceMonitoringSettingsFieldNumber = 6,
    kLiquidityMonitoringParametersFieldNumber = 7,
    kMarketTimestampsFieldNumber = 10,
    kDecimalPlacesFieldNumber = 3,
    kTradingModeFieldNumber = 8,
    kStateFieldNumber = 9,
    kContinuousFieldNumber = 100,
    kDiscreteFieldNumber = 101,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .vega.TradableInstrument tradable_instrument = 2 [json_name = "tradableInstrument"];
  bool has_tradable_instrument() const;
  private:
  bool _internal_has_tradable_instrument() const;
  public:
  void clear_tradable_instrument();
  const ::vega::TradableInstrument& tradable_instrument() const;
  ::vega::TradableInstrument* release_tradable_instrument();
  ::vega::TradableInstrument* mutable_tradable_instrument();
  void set_allocated_tradable_instrument(::vega::TradableInstrument* tradable_instrument);
  private:
  const ::vega::TradableInstrument& _internal_tradable_instrument() const;
  ::vega::TradableInstrument* _internal_mutable_tradable_instrument();
  public:
  void unsafe_arena_set_allocated_tradable_instrument(
      ::vega::TradableInstrument* tradable_instrument);
  ::vega::TradableInstrument* unsafe_arena_release_tradable_instrument();

  // .vega.Fees fees = 4 [json_name = "fees"];
  bool has_fees() const;
  private:
  bool _internal_has_fees() const;
  public:
  void clear_fees();
  const ::vega::Fees& fees() const;
  ::vega::Fees* release_fees();
  ::vega::Fees* mutable_fees();
  void set_allocated_fees(::vega::Fees* fees);
  private:
  const ::vega::Fees& _internal_fees() const;
  ::vega::Fees* _internal_mutable_fees();
  public:
  void unsafe_arena_set_allocated_fees(
      ::vega::Fees* fees);
  ::vega::Fees* unsafe_arena_release_fees();

  // .vega.AuctionDuration opening_auction = 5 [json_name = "openingAuction"];
  bool has_opening_auction() const;
  private:
  bool _internal_has_opening_auction() const;
  public:
  void clear_opening_auction();
  const ::vega::AuctionDuration& opening_auction() const;
  ::vega::AuctionDuration* release_opening_auction();
  ::vega::AuctionDuration* mutable_opening_auction();
  void set_allocated_opening_auction(::vega::AuctionDuration* opening_auction);
  private:
  const ::vega::AuctionDuration& _internal_opening_auction() const;
  ::vega::AuctionDuration* _internal_mutable_opening_auction();
  public:
  void unsafe_arena_set_allocated_opening_auction(
      ::vega::AuctionDuration* opening_auction);
  ::vega::AuctionDuration* unsafe_arena_release_opening_auction();

  // .vega.PriceMonitoringSettings price_monitoring_settings = 6 [json_name = "priceMonitoringSettings"];
  bool has_price_monitoring_settings() const;
  private:
  bool _internal_has_price_monitoring_settings() const;
  public:
  void clear_price_monitoring_settings();
  const ::vega::PriceMonitoringSettings& price_monitoring_settings() const;
  ::vega::PriceMonitoringSettings* release_price_monitoring_settings();
  ::vega::PriceMonitoringSettings* mutable_price_monitoring_settings();
  void set_allocated_price_monitoring_settings(::vega::PriceMonitoringSettings* price_monitoring_settings);
  private:
  const ::vega::PriceMonitoringSettings& _internal_price_monitoring_settings() const;
  ::vega::PriceMonitoringSettings* _internal_mutable_price_monitoring_settings();
  public:
  void unsafe_arena_set_allocated_price_monitoring_settings(
      ::vega::PriceMonitoringSettings* price_monitoring_settings);
  ::vega::PriceMonitoringSettings* unsafe_arena_release_price_monitoring_settings();

  // .vega.LiquidityMonitoringParameters liquidity_monitoring_parameters = 7 [json_name = "liquidityMonitoringParameters"];
  bool has_liquidity_monitoring_parameters() const;
  private:
  bool _internal_has_liquidity_monitoring_parameters() const;
  public:
  void clear_liquidity_monitoring_parameters();
  const ::vega::LiquidityMonitoringParameters& liquidity_monitoring_parameters() const;
  ::vega::LiquidityMonitoringParameters* release_liquidity_monitoring_parameters();
  ::vega::LiquidityMonitoringParameters* mutable_liquidity_monitoring_parameters();
  void set_allocated_liquidity_monitoring_parameters(::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters);
  private:
  const ::vega::LiquidityMonitoringParameters& _internal_liquidity_monitoring_parameters() const;
  ::vega::LiquidityMonitoringParameters* _internal_mutable_liquidity_monitoring_parameters();
  public:
  void unsafe_arena_set_allocated_liquidity_monitoring_parameters(
      ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters);
  ::vega::LiquidityMonitoringParameters* unsafe_arena_release_liquidity_monitoring_parameters();

  // .vega.MarketTimestamps market_timestamps = 10 [json_name = "marketTimestamps"];
  bool has_market_timestamps() const;
  private:
  bool _internal_has_market_timestamps() const;
  public:
  void clear_market_timestamps();
  const ::vega::MarketTimestamps& market_timestamps() const;
  ::vega::MarketTimestamps* release_market_timestamps();
  ::vega::MarketTimestamps* mutable_market_timestamps();
  void set_allocated_market_timestamps(::vega::MarketTimestamps* market_timestamps);
  private:
  const ::vega::MarketTimestamps& _internal_market_timestamps() const;
  ::vega::MarketTimestamps* _internal_mutable_market_timestamps();
  public:
  void unsafe_arena_set_allocated_market_timestamps(
      ::vega::MarketTimestamps* market_timestamps);
  ::vega::MarketTimestamps* unsafe_arena_release_market_timestamps();

  // uint64 decimal_places = 3 [json_name = "decimalPlaces"];
  void clear_decimal_places();
  ::PROTOBUF_NAMESPACE_ID::uint64 decimal_places() const;
  void set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_decimal_places() const;
  void _internal_set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .vega.Market.TradingMode trading_mode = 8 [json_name = "tradingMode"];
  void clear_trading_mode();
  ::vega::Market_TradingMode trading_mode() const;
  void set_trading_mode(::vega::Market_TradingMode value);
  private:
  ::vega::Market_TradingMode _internal_trading_mode() const;
  void _internal_set_trading_mode(::vega::Market_TradingMode value);
  public:

  // .vega.Market.State state = 9 [json_name = "state"];
  void clear_state();
  ::vega::Market_State state() const;
  void set_state(::vega::Market_State value);
  private:
  ::vega::Market_State _internal_state() const;
  void _internal_set_state(::vega::Market_State value);
  public:

  // .vega.ContinuousTrading continuous = 100 [json_name = "continuous"];
  bool has_continuous() const;
  private:
  bool _internal_has_continuous() const;
  public:
  void clear_continuous();
  const ::vega::ContinuousTrading& continuous() const;
  ::vega::ContinuousTrading* release_continuous();
  ::vega::ContinuousTrading* mutable_continuous();
  void set_allocated_continuous(::vega::ContinuousTrading* continuous);
  private:
  const ::vega::ContinuousTrading& _internal_continuous() const;
  ::vega::ContinuousTrading* _internal_mutable_continuous();
  public:
  void unsafe_arena_set_allocated_continuous(
      ::vega::ContinuousTrading* continuous);
  ::vega::ContinuousTrading* unsafe_arena_release_continuous();

  // .vega.DiscreteTrading discrete = 101 [json_name = "discrete"];
  bool has_discrete() const;
  private:
  bool _internal_has_discrete() const;
  public:
  void clear_discrete();
  const ::vega::DiscreteTrading& discrete() const;
  ::vega::DiscreteTrading* release_discrete();
  ::vega::DiscreteTrading* mutable_discrete();
  void set_allocated_discrete(::vega::DiscreteTrading* discrete);
  private:
  const ::vega::DiscreteTrading& _internal_discrete() const;
  ::vega::DiscreteTrading* _internal_mutable_discrete();
  public:
  void unsafe_arena_set_allocated_discrete(
      ::vega::DiscreteTrading* discrete);
  ::vega::DiscreteTrading* unsafe_arena_release_discrete();

  void clear_trading_mode_config();
  TradingModeConfigCase trading_mode_config_case() const;
  // @@protoc_insertion_point(class_scope:vega.Market)
 private:
  class _Internal;
  void set_has_continuous();
  void set_has_discrete();

  inline bool has_trading_mode_config() const;
  inline void clear_has_trading_mode_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::vega::TradableInstrument* tradable_instrument_;
  ::vega::Fees* fees_;
  ::vega::AuctionDuration* opening_auction_;
  ::vega::PriceMonitoringSettings* price_monitoring_settings_;
  ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters_;
  ::vega::MarketTimestamps* market_timestamps_;
  ::PROTOBUF_NAMESPACE_ID::uint64 decimal_places_;
  int trading_mode_;
  int state_;
  union TradingModeConfigUnion {
    TradingModeConfigUnion() {}
    ::vega::ContinuousTrading* continuous_;
    ::vega::DiscreteTrading* discrete_;
  } trading_mode_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_markets_2eproto;
};
// -------------------------------------------------------------------

class MarketTimestamps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vega.MarketTimestamps) */ {
 public:
  inline MarketTimestamps() : MarketTimestamps(nullptr) {}
  virtual ~MarketTimestamps();

  MarketTimestamps(const MarketTimestamps& from);
  MarketTimestamps(MarketTimestamps&& from) noexcept
    : MarketTimestamps() {
    *this = ::std::move(from);
  }

  inline MarketTimestamps& operator=(const MarketTimestamps& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketTimestamps& operator=(MarketTimestamps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarketTimestamps& default_instance();

  static inline const MarketTimestamps* internal_default_instance() {
    return reinterpret_cast<const MarketTimestamps*>(
               &_MarketTimestamps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MarketTimestamps& a, MarketTimestamps& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketTimestamps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketTimestamps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarketTimestamps* New() const final {
    return CreateMaybeMessage<MarketTimestamps>(nullptr);
  }

  MarketTimestamps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarketTimestamps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarketTimestamps& from);
  void MergeFrom(const MarketTimestamps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketTimestamps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vega.MarketTimestamps";
  }
  protected:
  explicit MarketTimestamps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_markets_2eproto);
    return ::descriptor_table_markets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposedFieldNumber = 1,
    kPendingFieldNumber = 2,
    kOpenFieldNumber = 3,
    kCloseFieldNumber = 4,
  };
  // int64 proposed = 1 [json_name = "proposed"];
  void clear_proposed();
  ::PROTOBUF_NAMESPACE_ID::int64 proposed() const;
  void set_proposed(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_proposed() const;
  void _internal_set_proposed(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 pending = 2 [json_name = "pending"];
  void clear_pending();
  ::PROTOBUF_NAMESPACE_ID::int64 pending() const;
  void set_pending(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pending() const;
  void _internal_set_pending(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 open = 3 [json_name = "open"];
  void clear_open();
  ::PROTOBUF_NAMESPACE_ID::int64 open() const;
  void set_open(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_open() const;
  void _internal_set_open(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 close = 4 [json_name = "close"];
  void clear_close();
  ::PROTOBUF_NAMESPACE_ID::int64 close() const;
  void set_close(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_close() const;
  void _internal_set_close(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:vega.MarketTimestamps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 proposed_;
  ::PROTOBUF_NAMESPACE_ID::int64 pending_;
  ::PROTOBUF_NAMESPACE_ID::int64 open_;
  ::PROTOBUF_NAMESPACE_ID::int64 close_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_markets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuctionDuration

// int64 duration = 1 [json_name = "duration"];
inline void AuctionDuration::clear_duration() {
  duration_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuctionDuration::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AuctionDuration::duration() const {
  // @@protoc_insertion_point(field_get:vega.AuctionDuration.duration)
  return _internal_duration();
}
inline void AuctionDuration::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {

  duration_ = value;
}
inline void AuctionDuration::set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:vega.AuctionDuration.duration)
}

// uint64 volume = 2 [json_name = "volume"];
inline void AuctionDuration::clear_volume() {
  volume_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AuctionDuration::_internal_volume() const {
  return volume_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AuctionDuration::volume() const {
  // @@protoc_insertion_point(field_get:vega.AuctionDuration.volume)
  return _internal_volume();
}
inline void AuctionDuration::_internal_set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  volume_ = value;
}
inline void AuctionDuration::set_volume(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:vega.AuctionDuration.volume)
}

// -------------------------------------------------------------------

// ContinuousTrading

// string tick_size = 1 [json_name = "tickSize"];
inline void ContinuousTrading::clear_tick_size() {
  tick_size_.ClearToEmpty();
}
inline const std::string& ContinuousTrading::tick_size() const {
  // @@protoc_insertion_point(field_get:vega.ContinuousTrading.tick_size)
  return _internal_tick_size();
}
inline void ContinuousTrading::set_tick_size(const std::string& value) {
  _internal_set_tick_size(value);
  // @@protoc_insertion_point(field_set:vega.ContinuousTrading.tick_size)
}
inline std::string* ContinuousTrading::mutable_tick_size() {
  // @@protoc_insertion_point(field_mutable:vega.ContinuousTrading.tick_size)
  return _internal_mutable_tick_size();
}
inline const std::string& ContinuousTrading::_internal_tick_size() const {
  return tick_size_.Get();
}
inline void ContinuousTrading::_internal_set_tick_size(const std::string& value) {

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ContinuousTrading::set_tick_size(std::string&& value) {

  tick_size_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.ContinuousTrading.tick_size)
}
inline void ContinuousTrading::set_tick_size(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.ContinuousTrading.tick_size)
}
inline void ContinuousTrading::set_tick_size(const char* value,
    size_t size) {

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.ContinuousTrading.tick_size)
}
inline std::string* ContinuousTrading::_internal_mutable_tick_size() {

  return tick_size_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ContinuousTrading::release_tick_size() {
  // @@protoc_insertion_point(field_release:vega.ContinuousTrading.tick_size)
  return tick_size_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContinuousTrading::set_allocated_tick_size(std::string* tick_size) {
  if (tick_size != nullptr) {

  } else {

  }
  tick_size_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tick_size,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.ContinuousTrading.tick_size)
}

// -------------------------------------------------------------------

// DiscreteTrading

// int64 duration_ns = 1 [json_name = "durationNs", (.validator.field) = {
inline void DiscreteTrading::clear_duration_ns() {
  duration_ns_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiscreteTrading::_internal_duration_ns() const {
  return duration_ns_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiscreteTrading::duration_ns() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.duration_ns)
  return _internal_duration_ns();
}
inline void DiscreteTrading::_internal_set_duration_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {

  duration_ns_ = value;
}
inline void DiscreteTrading::set_duration_ns(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration_ns(value);
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.duration_ns)
}

// string tick_size = 2 [json_name = "tickSize"];
inline void DiscreteTrading::clear_tick_size() {
  tick_size_.ClearToEmpty();
}
inline const std::string& DiscreteTrading::tick_size() const {
  // @@protoc_insertion_point(field_get:vega.DiscreteTrading.tick_size)
  return _internal_tick_size();
}
inline void DiscreteTrading::set_tick_size(const std::string& value) {
  _internal_set_tick_size(value);
  // @@protoc_insertion_point(field_set:vega.DiscreteTrading.tick_size)
}
inline std::string* DiscreteTrading::mutable_tick_size() {
  // @@protoc_insertion_point(field_mutable:vega.DiscreteTrading.tick_size)
  return _internal_mutable_tick_size();
}
inline const std::string& DiscreteTrading::_internal_tick_size() const {
  return tick_size_.Get();
}
inline void DiscreteTrading::_internal_set_tick_size(const std::string& value) {

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DiscreteTrading::set_tick_size(std::string&& value) {

  tick_size_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.DiscreteTrading.tick_size)
}
inline void DiscreteTrading::set_tick_size(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.DiscreteTrading.tick_size)
}
inline void DiscreteTrading::set_tick_size(const char* value,
    size_t size) {

  tick_size_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.DiscreteTrading.tick_size)
}
inline std::string* DiscreteTrading::_internal_mutable_tick_size() {

  return tick_size_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DiscreteTrading::release_tick_size() {
  // @@protoc_insertion_point(field_release:vega.DiscreteTrading.tick_size)
  return tick_size_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DiscreteTrading::set_allocated_tick_size(std::string* tick_size) {
  if (tick_size != nullptr) {

  } else {

  }
  tick_size_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tick_size,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.DiscreteTrading.tick_size)
}

// -------------------------------------------------------------------

// Future

// string maturity = 1 [json_name = "maturity"];
inline void Future::clear_maturity() {
  maturity_.ClearToEmpty();
}
inline const std::string& Future::maturity() const {
  // @@protoc_insertion_point(field_get:vega.Future.maturity)
  return _internal_maturity();
}
inline void Future::set_maturity(const std::string& value) {
  _internal_set_maturity(value);
  // @@protoc_insertion_point(field_set:vega.Future.maturity)
}
inline std::string* Future::mutable_maturity() {
  // @@protoc_insertion_point(field_mutable:vega.Future.maturity)
  return _internal_mutable_maturity();
}
inline const std::string& Future::_internal_maturity() const {
  return maturity_.Get();
}
inline void Future::_internal_set_maturity(const std::string& value) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_maturity(std::string&& value) {

  maturity_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.maturity)
}
inline void Future::set_maturity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.maturity)
}
inline void Future::set_maturity(const char* value,
    size_t size) {

  maturity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.maturity)
}
inline std::string* Future::_internal_mutable_maturity() {

  return maturity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_maturity() {
  // @@protoc_insertion_point(field_release:vega.Future.maturity)
  return maturity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_maturity(std::string* maturity) {
  if (maturity != nullptr) {

  } else {

  }
  maturity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maturity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.maturity)
}

// string settlement_asset = 2 [json_name = "settlementAsset"];
inline void Future::clear_settlement_asset() {
  settlement_asset_.ClearToEmpty();
}
inline const std::string& Future::settlement_asset() const {
  // @@protoc_insertion_point(field_get:vega.Future.settlement_asset)
  return _internal_settlement_asset();
}
inline void Future::set_settlement_asset(const std::string& value) {
  _internal_set_settlement_asset(value);
  // @@protoc_insertion_point(field_set:vega.Future.settlement_asset)
}
inline std::string* Future::mutable_settlement_asset() {
  // @@protoc_insertion_point(field_mutable:vega.Future.settlement_asset)
  return _internal_mutable_settlement_asset();
}
inline const std::string& Future::_internal_settlement_asset() const {
  return settlement_asset_.Get();
}
inline void Future::_internal_set_settlement_asset(const std::string& value) {

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_settlement_asset(std::string&& value) {

  settlement_asset_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.settlement_asset)
}
inline void Future::set_settlement_asset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.settlement_asset)
}
inline void Future::set_settlement_asset(const char* value,
    size_t size) {

  settlement_asset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.settlement_asset)
}
inline std::string* Future::_internal_mutable_settlement_asset() {

  return settlement_asset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_settlement_asset() {
  // @@protoc_insertion_point(field_release:vega.Future.settlement_asset)
  return settlement_asset_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_settlement_asset(std::string* settlement_asset) {
  if (settlement_asset != nullptr) {

  } else {

  }
  settlement_asset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settlement_asset,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.settlement_asset)
}

// string quote_name = 4 [json_name = "quoteName"];
inline void Future::clear_quote_name() {
  quote_name_.ClearToEmpty();
}
inline const std::string& Future::quote_name() const {
  // @@protoc_insertion_point(field_get:vega.Future.quote_name)
  return _internal_quote_name();
}
inline void Future::set_quote_name(const std::string& value) {
  _internal_set_quote_name(value);
  // @@protoc_insertion_point(field_set:vega.Future.quote_name)
}
inline std::string* Future::mutable_quote_name() {
  // @@protoc_insertion_point(field_mutable:vega.Future.quote_name)
  return _internal_mutable_quote_name();
}
inline const std::string& Future::_internal_quote_name() const {
  return quote_name_.Get();
}
inline void Future::_internal_set_quote_name(const std::string& value) {

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Future::set_quote_name(std::string&& value) {

  quote_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Future.quote_name)
}
inline void Future::set_quote_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Future.quote_name)
}
inline void Future::set_quote_name(const char* value,
    size_t size) {

  quote_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Future.quote_name)
}
inline std::string* Future::_internal_mutable_quote_name() {

  return quote_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Future::release_quote_name() {
  // @@protoc_insertion_point(field_release:vega.Future.quote_name)
  return quote_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Future::set_allocated_quote_name(std::string* quote_name) {
  if (quote_name != nullptr) {

  } else {

  }
  quote_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quote_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Future.quote_name)
}

// .oracles.v1.OracleSpec oracle_spec = 5 [json_name = "oracleSpec"];
inline bool Future::_internal_has_oracle_spec() const {
  return this != internal_default_instance() && oracle_spec_ != nullptr;
}
inline bool Future::has_oracle_spec() const {
  return _internal_has_oracle_spec();
}
inline const ::oracles::v1::OracleSpec& Future::_internal_oracle_spec() const {
  const ::oracles::v1::OracleSpec* p = oracle_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::oracles::v1::OracleSpec&>(
      ::oracles::v1::_OracleSpec_default_instance_);
}
inline const ::oracles::v1::OracleSpec& Future::oracle_spec() const {
  // @@protoc_insertion_point(field_get:vega.Future.oracle_spec)
  return _internal_oracle_spec();
}
inline void Future::unsafe_arena_set_allocated_oracle_spec(
    ::oracles::v1::OracleSpec* oracle_spec) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_);
  }
  oracle_spec_ = oracle_spec;
  if (oracle_spec) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Future.oracle_spec)
}
inline ::oracles::v1::OracleSpec* Future::release_oracle_spec() {

  ::oracles::v1::OracleSpec* temp = oracle_spec_;
  oracle_spec_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::oracles::v1::OracleSpec* Future::unsafe_arena_release_oracle_spec() {
  // @@protoc_insertion_point(field_release:vega.Future.oracle_spec)

  ::oracles::v1::OracleSpec* temp = oracle_spec_;
  oracle_spec_ = nullptr;
  return temp;
}
inline ::oracles::v1::OracleSpec* Future::_internal_mutable_oracle_spec() {

  if (oracle_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::oracles::v1::OracleSpec>(GetArena());
    oracle_spec_ = p;
  }
  return oracle_spec_;
}
inline ::oracles::v1::OracleSpec* Future::mutable_oracle_spec() {
  // @@protoc_insertion_point(field_mutable:vega.Future.oracle_spec)
  return _internal_mutable_oracle_spec();
}
inline void Future::set_allocated_oracle_spec(::oracles::v1::OracleSpec* oracle_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_);
  }
  if (oracle_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec)->GetArena();
    if (message_arena != submessage_arena) {
      oracle_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_spec, submessage_arena);
    }

  } else {

  }
  oracle_spec_ = oracle_spec;
  // @@protoc_insertion_point(field_set_allocated:vega.Future.oracle_spec)
}

// .vega.OracleSpecToFutureBinding oracle_spec_binding = 6 [json_name = "oracleSpecBinding"];
inline bool Future::_internal_has_oracle_spec_binding() const {
  return this != internal_default_instance() && oracle_spec_binding_ != nullptr;
}
inline bool Future::has_oracle_spec_binding() const {
  return _internal_has_oracle_spec_binding();
}
inline void Future::clear_oracle_spec_binding() {
  if (GetArena() == nullptr && oracle_spec_binding_ != nullptr) {
    delete oracle_spec_binding_;
  }
  oracle_spec_binding_ = nullptr;
}
inline const ::vega::OracleSpecToFutureBinding& Future::_internal_oracle_spec_binding() const {
  const ::vega::OracleSpecToFutureBinding* p = oracle_spec_binding_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::OracleSpecToFutureBinding&>(
      ::vega::_OracleSpecToFutureBinding_default_instance_);
}
inline const ::vega::OracleSpecToFutureBinding& Future::oracle_spec_binding() const {
  // @@protoc_insertion_point(field_get:vega.Future.oracle_spec_binding)
  return _internal_oracle_spec_binding();
}
inline void Future::unsafe_arena_set_allocated_oracle_spec_binding(
    ::vega::OracleSpecToFutureBinding* oracle_spec_binding) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(oracle_spec_binding_);
  }
  oracle_spec_binding_ = oracle_spec_binding;
  if (oracle_spec_binding) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Future.oracle_spec_binding)
}
inline ::vega::OracleSpecToFutureBinding* Future::release_oracle_spec_binding() {

  ::vega::OracleSpecToFutureBinding* temp = oracle_spec_binding_;
  oracle_spec_binding_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::OracleSpecToFutureBinding* Future::unsafe_arena_release_oracle_spec_binding() {
  // @@protoc_insertion_point(field_release:vega.Future.oracle_spec_binding)

  ::vega::OracleSpecToFutureBinding* temp = oracle_spec_binding_;
  oracle_spec_binding_ = nullptr;
  return temp;
}
inline ::vega::OracleSpecToFutureBinding* Future::_internal_mutable_oracle_spec_binding() {

  if (oracle_spec_binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::OracleSpecToFutureBinding>(GetArena());
    oracle_spec_binding_ = p;
  }
  return oracle_spec_binding_;
}
inline ::vega::OracleSpecToFutureBinding* Future::mutable_oracle_spec_binding() {
  // @@protoc_insertion_point(field_mutable:vega.Future.oracle_spec_binding)
  return _internal_mutable_oracle_spec_binding();
}
inline void Future::set_allocated_oracle_spec_binding(::vega::OracleSpecToFutureBinding* oracle_spec_binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete oracle_spec_binding_;
  }
  if (oracle_spec_binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(oracle_spec_binding);
    if (message_arena != submessage_arena) {
      oracle_spec_binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oracle_spec_binding, submessage_arena);
    }

  } else {

  }
  oracle_spec_binding_ = oracle_spec_binding;
  // @@protoc_insertion_point(field_set_allocated:vega.Future.oracle_spec_binding)
}

// -------------------------------------------------------------------

// OracleSpecToFutureBinding

// string settlement_price_property = 1 [json_name = "settlementPriceProperty"];
inline void OracleSpecToFutureBinding::clear_settlement_price_property() {
  settlement_price_property_.ClearToEmpty();
}
inline const std::string& OracleSpecToFutureBinding::settlement_price_property() const {
  // @@protoc_insertion_point(field_get:vega.OracleSpecToFutureBinding.settlement_price_property)
  return _internal_settlement_price_property();
}
inline void OracleSpecToFutureBinding::set_settlement_price_property(const std::string& value) {
  _internal_set_settlement_price_property(value);
  // @@protoc_insertion_point(field_set:vega.OracleSpecToFutureBinding.settlement_price_property)
}
inline std::string* OracleSpecToFutureBinding::mutable_settlement_price_property() {
  // @@protoc_insertion_point(field_mutable:vega.OracleSpecToFutureBinding.settlement_price_property)
  return _internal_mutable_settlement_price_property();
}
inline const std::string& OracleSpecToFutureBinding::_internal_settlement_price_property() const {
  return settlement_price_property_.Get();
}
inline void OracleSpecToFutureBinding::_internal_set_settlement_price_property(const std::string& value) {

  settlement_price_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void OracleSpecToFutureBinding::set_settlement_price_property(std::string&& value) {

  settlement_price_property_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.OracleSpecToFutureBinding.settlement_price_property)
}
inline void OracleSpecToFutureBinding::set_settlement_price_property(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  settlement_price_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.OracleSpecToFutureBinding.settlement_price_property)
}
inline void OracleSpecToFutureBinding::set_settlement_price_property(const char* value,
    size_t size) {

  settlement_price_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.OracleSpecToFutureBinding.settlement_price_property)
}
inline std::string* OracleSpecToFutureBinding::_internal_mutable_settlement_price_property() {

  return settlement_price_property_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* OracleSpecToFutureBinding::release_settlement_price_property() {
  // @@protoc_insertion_point(field_release:vega.OracleSpecToFutureBinding.settlement_price_property)
  return settlement_price_property_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OracleSpecToFutureBinding::set_allocated_settlement_price_property(std::string* settlement_price_property) {
  if (settlement_price_property != nullptr) {

  } else {

  }
  settlement_price_property_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), settlement_price_property,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.OracleSpecToFutureBinding.settlement_price_property)
}

// -------------------------------------------------------------------

// InstrumentMetadata

// repeated string tags = 1 [json_name = "tags"];
inline int InstrumentMetadata::_internal_tags_size() const {
  return tags_.size();
}
inline int InstrumentMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void InstrumentMetadata::clear_tags() {
  tags_.Clear();
}
inline std::string* InstrumentMetadata::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:vega.InstrumentMetadata.tags)
  return _internal_add_tags();
}
inline const std::string& InstrumentMetadata::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& InstrumentMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:vega.InstrumentMetadata.tags)
  return _internal_tags(index);
}
inline std::string* InstrumentMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:vega.InstrumentMetadata.tags)
  return tags_.Mutable(index);
}
inline void InstrumentMetadata::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(value);
}
inline void InstrumentMetadata::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vega.InstrumentMetadata.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void InstrumentMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vega.InstrumentMetadata.tags)
}
inline std::string* InstrumentMetadata::_internal_add_tags() {
  return tags_.Add();
}
inline void InstrumentMetadata::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vega.InstrumentMetadata.tags)
}
inline void InstrumentMetadata::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vega.InstrumentMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InstrumentMetadata::tags() const {
  // @@protoc_insertion_point(field_list:vega.InstrumentMetadata.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InstrumentMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:vega.InstrumentMetadata.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// Instrument

// string id = 1 [json_name = "id"];
inline void Instrument::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Instrument::id() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.id)
  return _internal_id();
}
inline void Instrument::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.id)
}
inline std::string* Instrument::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.id)
  return _internal_mutable_id();
}
inline const std::string& Instrument::_internal_id() const {
  return id_.Get();
}
inline void Instrument::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.id)
}
inline void Instrument::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.id)
}
inline void Instrument::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.id)
}
inline std::string* Instrument::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_id() {
  // @@protoc_insertion_point(field_release:vega.Instrument.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.id)
}

// string code = 2 [json_name = "code"];
inline void Instrument::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Instrument::code() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.code)
  return _internal_code();
}
inline void Instrument::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.code)
}
inline std::string* Instrument::mutable_code() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.code)
  return _internal_mutable_code();
}
inline const std::string& Instrument::_internal_code() const {
  return code_.Get();
}
inline void Instrument::_internal_set_code(const std::string& value) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_code(std::string&& value) {

  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.code)
}
inline void Instrument::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.code)
}
inline void Instrument::set_code(const char* value,
    size_t size) {

  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.code)
}
inline std::string* Instrument::_internal_mutable_code() {

  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_code() {
  // @@protoc_insertion_point(field_release:vega.Instrument.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_code(std::string* code) {
  if (code != nullptr) {

  } else {

  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.code)
}

// string name = 3 [json_name = "name"];
inline void Instrument::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Instrument::name() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.name)
  return _internal_name();
}
inline void Instrument::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:vega.Instrument.name)
}
inline std::string* Instrument::mutable_name() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.name)
  return _internal_mutable_name();
}
inline const std::string& Instrument::_internal_name() const {
  return name_.Get();
}
inline void Instrument::_internal_set_name(const std::string& value) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Instrument::set_name(std::string&& value) {

  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Instrument.name)
}
inline void Instrument::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Instrument.name)
}
inline void Instrument::set_name(const char* value,
    size_t size) {

  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Instrument.name)
}
inline std::string* Instrument::_internal_mutable_name() {

  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Instrument::release_name() {
  // @@protoc_insertion_point(field_release:vega.Instrument.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Instrument::set_allocated_name(std::string* name) {
  if (name != nullptr) {

  } else {

  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.name)
}

// .vega.InstrumentMetadata metadata = 4 [json_name = "metadata"];
inline bool Instrument::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Instrument::has_metadata() const {
  return _internal_has_metadata();
}
inline void Instrument::clear_metadata() {
  if (GetArena() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::vega::InstrumentMetadata& Instrument::_internal_metadata() const {
  const ::vega::InstrumentMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::InstrumentMetadata&>(
      ::vega::_InstrumentMetadata_default_instance_);
}
inline const ::vega::InstrumentMetadata& Instrument::metadata() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.metadata)
  return _internal_metadata();
}
inline void Instrument::unsafe_arena_set_allocated_metadata(
    ::vega::InstrumentMetadata* metadata) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Instrument.metadata)
}
inline ::vega::InstrumentMetadata* Instrument::release_metadata() {

  ::vega::InstrumentMetadata* temp = metadata_;
  metadata_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::InstrumentMetadata* Instrument::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:vega.Instrument.metadata)

  ::vega::InstrumentMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::vega::InstrumentMetadata* Instrument::_internal_mutable_metadata() {

  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::InstrumentMetadata>(GetArena());
    metadata_ = p;
  }
  return metadata_;
}
inline ::vega::InstrumentMetadata* Instrument::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.metadata)
  return _internal_mutable_metadata();
}
inline void Instrument::set_allocated_metadata(::vega::InstrumentMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }

  } else {

  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:vega.Instrument.metadata)
}

// .vega.Future future = 100 [json_name = "future"];
inline bool Instrument::_internal_has_future() const {
  return product_case() == kFuture;
}
inline bool Instrument::has_future() const {
  return _internal_has_future();
}
inline void Instrument::set_has_future() {
  _oneof_case_[0] = kFuture;
}
inline void Instrument::clear_future() {
  if (_internal_has_future()) {
    if (GetArena() == nullptr) {
      delete product_.future_;
    }
    clear_has_product();
  }
}
inline ::vega::Future* Instrument::release_future() {
  // @@protoc_insertion_point(field_release:vega.Instrument.future)
  if (_internal_has_future()) {
    clear_has_product();
      ::vega::Future* temp = product_.future_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::Future& Instrument::_internal_future() const {
  return _internal_has_future()
      ? *product_.future_
      : reinterpret_cast< ::vega::Future&>(::vega::_Future_default_instance_);
}
inline const ::vega::Future& Instrument::future() const {
  // @@protoc_insertion_point(field_get:vega.Instrument.future)
  return _internal_future();
}
inline ::vega::Future* Instrument::unsafe_arena_release_future() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Instrument.future)
  if (_internal_has_future()) {
    clear_has_product();
    ::vega::Future* temp = product_.future_;
    product_.future_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Instrument::unsafe_arena_set_allocated_future(::vega::Future* future) {
  clear_product();
  if (future) {
    set_has_future();
    product_.future_ = future;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Instrument.future)
}
inline ::vega::Future* Instrument::_internal_mutable_future() {
  if (!_internal_has_future()) {
    clear_product();
    set_has_future();
    product_.future_ = CreateMaybeMessage< ::vega::Future >(GetArena());
  }
  return product_.future_;
}
inline ::vega::Future* Instrument::mutable_future() {
  // @@protoc_insertion_point(field_mutable:vega.Instrument.future)
  return _internal_mutable_future();
}

inline bool Instrument::has_product() const {
  return product_case() != PRODUCT_NOT_SET;
}
inline void Instrument::clear_has_product() {
  _oneof_case_[0] = PRODUCT_NOT_SET;
}
inline Instrument::ProductCase Instrument::product_case() const {
  return Instrument::ProductCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LogNormalRiskModel

// double risk_aversion_parameter = 1 [json_name = "riskAversionParameter"];
inline void LogNormalRiskModel::clear_risk_aversion_parameter() {
  risk_aversion_parameter_ = 0;
}
inline double LogNormalRiskModel::_internal_risk_aversion_parameter() const {
  return risk_aversion_parameter_;
}
inline double LogNormalRiskModel::risk_aversion_parameter() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.risk_aversion_parameter)
  return _internal_risk_aversion_parameter();
}
inline void LogNormalRiskModel::_internal_set_risk_aversion_parameter(double value) {

  risk_aversion_parameter_ = value;
}
inline void LogNormalRiskModel::set_risk_aversion_parameter(double value) {
  _internal_set_risk_aversion_parameter(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.risk_aversion_parameter)
}

// double tau = 2 [json_name = "tau"];
inline void LogNormalRiskModel::clear_tau() {
  tau_ = 0;
}
inline double LogNormalRiskModel::_internal_tau() const {
  return tau_;
}
inline double LogNormalRiskModel::tau() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.tau)
  return _internal_tau();
}
inline void LogNormalRiskModel::_internal_set_tau(double value) {

  tau_ = value;
}
inline void LogNormalRiskModel::set_tau(double value) {
  _internal_set_tau(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalRiskModel.tau)
}

// .vega.LogNormalModelParams params = 3 [json_name = "params"];
inline bool LogNormalRiskModel::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool LogNormalRiskModel::has_params() const {
  return _internal_has_params();
}
inline void LogNormalRiskModel::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::LogNormalModelParams& LogNormalRiskModel::_internal_params() const {
  const ::vega::LogNormalModelParams* p = params_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::LogNormalModelParams&>(
      ::vega::_LogNormalModelParams_default_instance_);
}
inline const ::vega::LogNormalModelParams& LogNormalRiskModel::params() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalRiskModel.params)
  return _internal_params();
}
inline void LogNormalRiskModel::unsafe_arena_set_allocated_params(
    ::vega::LogNormalModelParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.LogNormalRiskModel.params)
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::release_params() {

  ::vega::LogNormalModelParams* temp = params_;
  params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:vega.LogNormalRiskModel.params)

  ::vega::LogNormalModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::_internal_mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::LogNormalModelParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::vega::LogNormalModelParams* LogNormalRiskModel::mutable_params() {
  // @@protoc_insertion_point(field_mutable:vega.LogNormalRiskModel.params)
  return _internal_mutable_params();
}
inline void LogNormalRiskModel::set_allocated_params(::vega::LogNormalModelParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.LogNormalRiskModel.params)
}

// -------------------------------------------------------------------

// LogNormalModelParams

// double mu = 1 [json_name = "mu"];
inline void LogNormalModelParams::clear_mu() {
  mu_ = 0;
}
inline double LogNormalModelParams::_internal_mu() const {
  return mu_;
}
inline double LogNormalModelParams::mu() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.mu)
  return _internal_mu();
}
inline void LogNormalModelParams::_internal_set_mu(double value) {

  mu_ = value;
}
inline void LogNormalModelParams::set_mu(double value) {
  _internal_set_mu(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.mu)
}

// double r = 2 [json_name = "r"];
inline void LogNormalModelParams::clear_r() {
  r_ = 0;
}
inline double LogNormalModelParams::_internal_r() const {
  return r_;
}
inline double LogNormalModelParams::r() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.r)
  return _internal_r();
}
inline void LogNormalModelParams::_internal_set_r(double value) {

  r_ = value;
}
inline void LogNormalModelParams::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.r)
}

// double sigma = 3 [json_name = "sigma"];
inline void LogNormalModelParams::clear_sigma() {
  sigma_ = 0;
}
inline double LogNormalModelParams::_internal_sigma() const {
  return sigma_;
}
inline double LogNormalModelParams::sigma() const {
  // @@protoc_insertion_point(field_get:vega.LogNormalModelParams.sigma)
  return _internal_sigma();
}
inline void LogNormalModelParams::_internal_set_sigma(double value) {

  sigma_ = value;
}
inline void LogNormalModelParams::set_sigma(double value) {
  _internal_set_sigma(value);
  // @@protoc_insertion_point(field_set:vega.LogNormalModelParams.sigma)
}

// -------------------------------------------------------------------

// SimpleRiskModel

// .vega.SimpleModelParams params = 1 [json_name = "params"];
inline bool SimpleRiskModel::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool SimpleRiskModel::has_params() const {
  return _internal_has_params();
}
inline void SimpleRiskModel::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::vega::SimpleModelParams& SimpleRiskModel::_internal_params() const {
  const ::vega::SimpleModelParams* p = params_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::SimpleModelParams&>(
      ::vega::_SimpleModelParams_default_instance_);
}
inline const ::vega::SimpleModelParams& SimpleRiskModel::params() const {
  // @@protoc_insertion_point(field_get:vega.SimpleRiskModel.params)
  return _internal_params();
}
inline void SimpleRiskModel::unsafe_arena_set_allocated_params(
    ::vega::SimpleModelParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.SimpleRiskModel.params)
}
inline ::vega::SimpleModelParams* SimpleRiskModel::release_params() {

  ::vega::SimpleModelParams* temp = params_;
  params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:vega.SimpleRiskModel.params)

  ::vega::SimpleModelParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::_internal_mutable_params() {

  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::SimpleModelParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::vega::SimpleModelParams* SimpleRiskModel::mutable_params() {
  // @@protoc_insertion_point(field_mutable:vega.SimpleRiskModel.params)
  return _internal_mutable_params();
}
inline void SimpleRiskModel::set_allocated_params(::vega::SimpleModelParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }

  } else {

  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:vega.SimpleRiskModel.params)
}

// -------------------------------------------------------------------

// SimpleModelParams

// double factor_long = 1 [json_name = "factorLong"];
inline void SimpleModelParams::clear_factor_long() {
  factor_long_ = 0;
}
inline double SimpleModelParams::_internal_factor_long() const {
  return factor_long_;
}
inline double SimpleModelParams::factor_long() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factor_long)
  return _internal_factor_long();
}
inline void SimpleModelParams::_internal_set_factor_long(double value) {

  factor_long_ = value;
}
inline void SimpleModelParams::set_factor_long(double value) {
  _internal_set_factor_long(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factor_long)
}

// double factor_short = 2 [json_name = "factorShort"];
inline void SimpleModelParams::clear_factor_short() {
  factor_short_ = 0;
}
inline double SimpleModelParams::_internal_factor_short() const {
  return factor_short_;
}
inline double SimpleModelParams::factor_short() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.factor_short)
  return _internal_factor_short();
}
inline void SimpleModelParams::_internal_set_factor_short(double value) {

  factor_short_ = value;
}
inline void SimpleModelParams::set_factor_short(double value) {
  _internal_set_factor_short(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.factor_short)
}

// double max_move_up = 3 [json_name = "maxMoveUp", (.validator.field) = {
inline void SimpleModelParams::clear_max_move_up() {
  max_move_up_ = 0;
}
inline double SimpleModelParams::_internal_max_move_up() const {
  return max_move_up_;
}
inline double SimpleModelParams::max_move_up() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.max_move_up)
  return _internal_max_move_up();
}
inline void SimpleModelParams::_internal_set_max_move_up(double value) {

  max_move_up_ = value;
}
inline void SimpleModelParams::set_max_move_up(double value) {
  _internal_set_max_move_up(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.max_move_up)
}

// double min_move_down = 4 [json_name = "minMoveDown", (.validator.field) = {
inline void SimpleModelParams::clear_min_move_down() {
  min_move_down_ = 0;
}
inline double SimpleModelParams::_internal_min_move_down() const {
  return min_move_down_;
}
inline double SimpleModelParams::min_move_down() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.min_move_down)
  return _internal_min_move_down();
}
inline void SimpleModelParams::_internal_set_min_move_down(double value) {

  min_move_down_ = value;
}
inline void SimpleModelParams::set_min_move_down(double value) {
  _internal_set_min_move_down(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.min_move_down)
}

// double probability_of_trading = 5 [json_name = "probabilityOfTrading", (.validator.field) = {
inline void SimpleModelParams::clear_probability_of_trading() {
  probability_of_trading_ = 0;
}
inline double SimpleModelParams::_internal_probability_of_trading() const {
  return probability_of_trading_;
}
inline double SimpleModelParams::probability_of_trading() const {
  // @@protoc_insertion_point(field_get:vega.SimpleModelParams.probability_of_trading)
  return _internal_probability_of_trading();
}
inline void SimpleModelParams::_internal_set_probability_of_trading(double value) {

  probability_of_trading_ = value;
}
inline void SimpleModelParams::set_probability_of_trading(double value) {
  _internal_set_probability_of_trading(value);
  // @@protoc_insertion_point(field_set:vega.SimpleModelParams.probability_of_trading)
}

// -------------------------------------------------------------------

// ScalingFactors

// double search_level = 1 [json_name = "searchLevel"];
inline void ScalingFactors::clear_search_level() {
  search_level_ = 0;
}
inline double ScalingFactors::_internal_search_level() const {
  return search_level_;
}
inline double ScalingFactors::search_level() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.search_level)
  return _internal_search_level();
}
inline void ScalingFactors::_internal_set_search_level(double value) {

  search_level_ = value;
}
inline void ScalingFactors::set_search_level(double value) {
  _internal_set_search_level(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.search_level)
}

// double initial_margin = 2 [json_name = "initialMargin"];
inline void ScalingFactors::clear_initial_margin() {
  initial_margin_ = 0;
}
inline double ScalingFactors::_internal_initial_margin() const {
  return initial_margin_;
}
inline double ScalingFactors::initial_margin() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.initial_margin)
  return _internal_initial_margin();
}
inline void ScalingFactors::_internal_set_initial_margin(double value) {

  initial_margin_ = value;
}
inline void ScalingFactors::set_initial_margin(double value) {
  _internal_set_initial_margin(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.initial_margin)
}

// double collateral_release = 3 [json_name = "collateralRelease"];
inline void ScalingFactors::clear_collateral_release() {
  collateral_release_ = 0;
}
inline double ScalingFactors::_internal_collateral_release() const {
  return collateral_release_;
}
inline double ScalingFactors::collateral_release() const {
  // @@protoc_insertion_point(field_get:vega.ScalingFactors.collateral_release)
  return _internal_collateral_release();
}
inline void ScalingFactors::_internal_set_collateral_release(double value) {

  collateral_release_ = value;
}
inline void ScalingFactors::set_collateral_release(double value) {
  _internal_set_collateral_release(value);
  // @@protoc_insertion_point(field_set:vega.ScalingFactors.collateral_release)
}

// -------------------------------------------------------------------

// MarginCalculator

// .vega.ScalingFactors scaling_factors = 1 [json_name = "scalingFactors"];
inline bool MarginCalculator::_internal_has_scaling_factors() const {
  return this != internal_default_instance() && scaling_factors_ != nullptr;
}
inline bool MarginCalculator::has_scaling_factors() const {
  return _internal_has_scaling_factors();
}
inline void MarginCalculator::clear_scaling_factors() {
  if (GetArena() == nullptr && scaling_factors_ != nullptr) {
    delete scaling_factors_;
  }
  scaling_factors_ = nullptr;
}
inline const ::vega::ScalingFactors& MarginCalculator::_internal_scaling_factors() const {
  const ::vega::ScalingFactors* p = scaling_factors_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::ScalingFactors&>(
      ::vega::_ScalingFactors_default_instance_);
}
inline const ::vega::ScalingFactors& MarginCalculator::scaling_factors() const {
  // @@protoc_insertion_point(field_get:vega.MarginCalculator.scaling_factors)
  return _internal_scaling_factors();
}
inline void MarginCalculator::unsafe_arena_set_allocated_scaling_factors(
    ::vega::ScalingFactors* scaling_factors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scaling_factors_);
  }
  scaling_factors_ = scaling_factors;
  if (scaling_factors) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.MarginCalculator.scaling_factors)
}
inline ::vega::ScalingFactors* MarginCalculator::release_scaling_factors() {

  ::vega::ScalingFactors* temp = scaling_factors_;
  scaling_factors_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::ScalingFactors* MarginCalculator::unsafe_arena_release_scaling_factors() {
  // @@protoc_insertion_point(field_release:vega.MarginCalculator.scaling_factors)

  ::vega::ScalingFactors* temp = scaling_factors_;
  scaling_factors_ = nullptr;
  return temp;
}
inline ::vega::ScalingFactors* MarginCalculator::_internal_mutable_scaling_factors() {

  if (scaling_factors_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::ScalingFactors>(GetArena());
    scaling_factors_ = p;
  }
  return scaling_factors_;
}
inline ::vega::ScalingFactors* MarginCalculator::mutable_scaling_factors() {
  // @@protoc_insertion_point(field_mutable:vega.MarginCalculator.scaling_factors)
  return _internal_mutable_scaling_factors();
}
inline void MarginCalculator::set_allocated_scaling_factors(::vega::ScalingFactors* scaling_factors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scaling_factors_;
  }
  if (scaling_factors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scaling_factors);
    if (message_arena != submessage_arena) {
      scaling_factors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scaling_factors, submessage_arena);
    }

  } else {

  }
  scaling_factors_ = scaling_factors;
  // @@protoc_insertion_point(field_set_allocated:vega.MarginCalculator.scaling_factors)
}

// -------------------------------------------------------------------

// TradableInstrument

// .vega.Instrument instrument = 1 [json_name = "instrument"];
inline bool TradableInstrument::_internal_has_instrument() const {
  return this != internal_default_instance() && instrument_ != nullptr;
}
inline bool TradableInstrument::has_instrument() const {
  return _internal_has_instrument();
}
inline void TradableInstrument::clear_instrument() {
  if (GetArena() == nullptr && instrument_ != nullptr) {
    delete instrument_;
  }
  instrument_ = nullptr;
}
inline const ::vega::Instrument& TradableInstrument::_internal_instrument() const {
  const ::vega::Instrument* p = instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Instrument&>(
      ::vega::_Instrument_default_instance_);
}
inline const ::vega::Instrument& TradableInstrument::instrument() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.instrument)
  return _internal_instrument();
}
inline void TradableInstrument::unsafe_arena_set_allocated_instrument(
    ::vega::Instrument* instrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instrument_);
  }
  instrument_ = instrument;
  if (instrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.instrument)
}
inline ::vega::Instrument* TradableInstrument::release_instrument() {

  ::vega::Instrument* temp = instrument_;
  instrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Instrument* TradableInstrument::unsafe_arena_release_instrument() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.instrument)

  ::vega::Instrument* temp = instrument_;
  instrument_ = nullptr;
  return temp;
}
inline ::vega::Instrument* TradableInstrument::_internal_mutable_instrument() {

  if (instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Instrument>(GetArena());
    instrument_ = p;
  }
  return instrument_;
}
inline ::vega::Instrument* TradableInstrument::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.instrument)
  return _internal_mutable_instrument();
}
inline void TradableInstrument::set_allocated_instrument(::vega::Instrument* instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instrument_;
  }
  if (instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instrument);
    if (message_arena != submessage_arena) {
      instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrument, submessage_arena);
    }

  } else {

  }
  instrument_ = instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.instrument)
}

// .vega.MarginCalculator margin_calculator = 2 [json_name = "marginCalculator"];
inline bool TradableInstrument::_internal_has_margin_calculator() const {
  return this != internal_default_instance() && margin_calculator_ != nullptr;
}
inline bool TradableInstrument::has_margin_calculator() const {
  return _internal_has_margin_calculator();
}
inline void TradableInstrument::clear_margin_calculator() {
  if (GetArena() == nullptr && margin_calculator_ != nullptr) {
    delete margin_calculator_;
  }
  margin_calculator_ = nullptr;
}
inline const ::vega::MarginCalculator& TradableInstrument::_internal_margin_calculator() const {
  const ::vega::MarginCalculator* p = margin_calculator_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::MarginCalculator&>(
      ::vega::_MarginCalculator_default_instance_);
}
inline const ::vega::MarginCalculator& TradableInstrument::margin_calculator() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.margin_calculator)
  return _internal_margin_calculator();
}
inline void TradableInstrument::unsafe_arena_set_allocated_margin_calculator(
    ::vega::MarginCalculator* margin_calculator) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(margin_calculator_);
  }
  margin_calculator_ = margin_calculator;
  if (margin_calculator) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.margin_calculator)
}
inline ::vega::MarginCalculator* TradableInstrument::release_margin_calculator() {

  ::vega::MarginCalculator* temp = margin_calculator_;
  margin_calculator_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::MarginCalculator* TradableInstrument::unsafe_arena_release_margin_calculator() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.margin_calculator)

  ::vega::MarginCalculator* temp = margin_calculator_;
  margin_calculator_ = nullptr;
  return temp;
}
inline ::vega::MarginCalculator* TradableInstrument::_internal_mutable_margin_calculator() {

  if (margin_calculator_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::MarginCalculator>(GetArena());
    margin_calculator_ = p;
  }
  return margin_calculator_;
}
inline ::vega::MarginCalculator* TradableInstrument::mutable_margin_calculator() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.margin_calculator)
  return _internal_mutable_margin_calculator();
}
inline void TradableInstrument::set_allocated_margin_calculator(::vega::MarginCalculator* margin_calculator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete margin_calculator_;
  }
  if (margin_calculator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(margin_calculator);
    if (message_arena != submessage_arena) {
      margin_calculator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, margin_calculator, submessage_arena);
    }

  } else {

  }
  margin_calculator_ = margin_calculator;
  // @@protoc_insertion_point(field_set_allocated:vega.TradableInstrument.margin_calculator)
}

// .vega.LogNormalRiskModel log_normal_risk_model = 100 [json_name = "logNormalRiskModel"];
inline bool TradableInstrument::_internal_has_log_normal_risk_model() const {
  return risk_model_case() == kLogNormalRiskModel;
}
inline bool TradableInstrument::has_log_normal_risk_model() const {
  return _internal_has_log_normal_risk_model();
}
inline void TradableInstrument::set_has_log_normal_risk_model() {
  _oneof_case_[0] = kLogNormalRiskModel;
}
inline void TradableInstrument::clear_log_normal_risk_model() {
  if (_internal_has_log_normal_risk_model()) {
    if (GetArena() == nullptr) {
      delete risk_model_.log_normal_risk_model_;
    }
    clear_has_risk_model();
  }
}
inline ::vega::LogNormalRiskModel* TradableInstrument::release_log_normal_risk_model() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.log_normal_risk_model)
  if (_internal_has_log_normal_risk_model()) {
    clear_has_risk_model();
      ::vega::LogNormalRiskModel* temp = risk_model_.log_normal_risk_model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    risk_model_.log_normal_risk_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::LogNormalRiskModel& TradableInstrument::_internal_log_normal_risk_model() const {
  return _internal_has_log_normal_risk_model()
      ? *risk_model_.log_normal_risk_model_
      : reinterpret_cast< ::vega::LogNormalRiskModel&>(::vega::_LogNormalRiskModel_default_instance_);
}
inline const ::vega::LogNormalRiskModel& TradableInstrument::log_normal_risk_model() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.log_normal_risk_model)
  return _internal_log_normal_risk_model();
}
inline ::vega::LogNormalRiskModel* TradableInstrument::unsafe_arena_release_log_normal_risk_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.TradableInstrument.log_normal_risk_model)
  if (_internal_has_log_normal_risk_model()) {
    clear_has_risk_model();
    ::vega::LogNormalRiskModel* temp = risk_model_.log_normal_risk_model_;
    risk_model_.log_normal_risk_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TradableInstrument::unsafe_arena_set_allocated_log_normal_risk_model(::vega::LogNormalRiskModel* log_normal_risk_model) {
  clear_risk_model();
  if (log_normal_risk_model) {
    set_has_log_normal_risk_model();
    risk_model_.log_normal_risk_model_ = log_normal_risk_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.log_normal_risk_model)
}
inline ::vega::LogNormalRiskModel* TradableInstrument::_internal_mutable_log_normal_risk_model() {
  if (!_internal_has_log_normal_risk_model()) {
    clear_risk_model();
    set_has_log_normal_risk_model();
    risk_model_.log_normal_risk_model_ = CreateMaybeMessage< ::vega::LogNormalRiskModel >(GetArena());
  }
  return risk_model_.log_normal_risk_model_;
}
inline ::vega::LogNormalRiskModel* TradableInstrument::mutable_log_normal_risk_model() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.log_normal_risk_model)
  return _internal_mutable_log_normal_risk_model();
}

// .vega.SimpleRiskModel simple_risk_model = 101 [json_name = "simpleRiskModel"];
inline bool TradableInstrument::_internal_has_simple_risk_model() const {
  return risk_model_case() == kSimpleRiskModel;
}
inline bool TradableInstrument::has_simple_risk_model() const {
  return _internal_has_simple_risk_model();
}
inline void TradableInstrument::set_has_simple_risk_model() {
  _oneof_case_[0] = kSimpleRiskModel;
}
inline void TradableInstrument::clear_simple_risk_model() {
  if (_internal_has_simple_risk_model()) {
    if (GetArena() == nullptr) {
      delete risk_model_.simple_risk_model_;
    }
    clear_has_risk_model();
  }
}
inline ::vega::SimpleRiskModel* TradableInstrument::release_simple_risk_model() {
  // @@protoc_insertion_point(field_release:vega.TradableInstrument.simple_risk_model)
  if (_internal_has_simple_risk_model()) {
    clear_has_risk_model();
      ::vega::SimpleRiskModel* temp = risk_model_.simple_risk_model_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    risk_model_.simple_risk_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::SimpleRiskModel& TradableInstrument::_internal_simple_risk_model() const {
  return _internal_has_simple_risk_model()
      ? *risk_model_.simple_risk_model_
      : reinterpret_cast< ::vega::SimpleRiskModel&>(::vega::_SimpleRiskModel_default_instance_);
}
inline const ::vega::SimpleRiskModel& TradableInstrument::simple_risk_model() const {
  // @@protoc_insertion_point(field_get:vega.TradableInstrument.simple_risk_model)
  return _internal_simple_risk_model();
}
inline ::vega::SimpleRiskModel* TradableInstrument::unsafe_arena_release_simple_risk_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.TradableInstrument.simple_risk_model)
  if (_internal_has_simple_risk_model()) {
    clear_has_risk_model();
    ::vega::SimpleRiskModel* temp = risk_model_.simple_risk_model_;
    risk_model_.simple_risk_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TradableInstrument::unsafe_arena_set_allocated_simple_risk_model(::vega::SimpleRiskModel* simple_risk_model) {
  clear_risk_model();
  if (simple_risk_model) {
    set_has_simple_risk_model();
    risk_model_.simple_risk_model_ = simple_risk_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.TradableInstrument.simple_risk_model)
}
inline ::vega::SimpleRiskModel* TradableInstrument::_internal_mutable_simple_risk_model() {
  if (!_internal_has_simple_risk_model()) {
    clear_risk_model();
    set_has_simple_risk_model();
    risk_model_.simple_risk_model_ = CreateMaybeMessage< ::vega::SimpleRiskModel >(GetArena());
  }
  return risk_model_.simple_risk_model_;
}
inline ::vega::SimpleRiskModel* TradableInstrument::mutable_simple_risk_model() {
  // @@protoc_insertion_point(field_mutable:vega.TradableInstrument.simple_risk_model)
  return _internal_mutable_simple_risk_model();
}

inline bool TradableInstrument::has_risk_model() const {
  return risk_model_case() != RISK_MODEL_NOT_SET;
}
inline void TradableInstrument::clear_has_risk_model() {
  _oneof_case_[0] = RISK_MODEL_NOT_SET;
}
inline TradableInstrument::RiskModelCase TradableInstrument::risk_model_case() const {
  return TradableInstrument::RiskModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeeFactors

// string maker_fee = 1 [json_name = "makerFee"];
inline void FeeFactors::clear_maker_fee() {
  maker_fee_.ClearToEmpty();
}
inline const std::string& FeeFactors::maker_fee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.maker_fee)
  return _internal_maker_fee();
}
inline void FeeFactors::set_maker_fee(const std::string& value) {
  _internal_set_maker_fee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.maker_fee)
}
inline std::string* FeeFactors::mutable_maker_fee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.maker_fee)
  return _internal_mutable_maker_fee();
}
inline const std::string& FeeFactors::_internal_maker_fee() const {
  return maker_fee_.Get();
}
inline void FeeFactors::_internal_set_maker_fee(const std::string& value) {

  maker_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_maker_fee(std::string&& value) {

  maker_fee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.maker_fee)
}
inline void FeeFactors::set_maker_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  maker_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.maker_fee)
}
inline void FeeFactors::set_maker_fee(const char* value,
    size_t size) {

  maker_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.maker_fee)
}
inline std::string* FeeFactors::_internal_mutable_maker_fee() {

  return maker_fee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_maker_fee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.maker_fee)
  return maker_fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_maker_fee(std::string* maker_fee) {
  if (maker_fee != nullptr) {

  } else {

  }
  maker_fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), maker_fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.maker_fee)
}

// string infrastructure_fee = 2 [json_name = "infrastructureFee"];
inline void FeeFactors::clear_infrastructure_fee() {
  infrastructure_fee_.ClearToEmpty();
}
inline const std::string& FeeFactors::infrastructure_fee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.infrastructure_fee)
  return _internal_infrastructure_fee();
}
inline void FeeFactors::set_infrastructure_fee(const std::string& value) {
  _internal_set_infrastructure_fee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.infrastructure_fee)
}
inline std::string* FeeFactors::mutable_infrastructure_fee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.infrastructure_fee)
  return _internal_mutable_infrastructure_fee();
}
inline const std::string& FeeFactors::_internal_infrastructure_fee() const {
  return infrastructure_fee_.Get();
}
inline void FeeFactors::_internal_set_infrastructure_fee(const std::string& value) {

  infrastructure_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_infrastructure_fee(std::string&& value) {

  infrastructure_fee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.infrastructure_fee)
}
inline void FeeFactors::set_infrastructure_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  infrastructure_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.infrastructure_fee)
}
inline void FeeFactors::set_infrastructure_fee(const char* value,
    size_t size) {

  infrastructure_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.infrastructure_fee)
}
inline std::string* FeeFactors::_internal_mutable_infrastructure_fee() {

  return infrastructure_fee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_infrastructure_fee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.infrastructure_fee)
  return infrastructure_fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_infrastructure_fee(std::string* infrastructure_fee) {
  if (infrastructure_fee != nullptr) {

  } else {

  }
  infrastructure_fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), infrastructure_fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.infrastructure_fee)
}

// string liquidity_fee = 3 [json_name = "liquidityFee"];
inline void FeeFactors::clear_liquidity_fee() {
  liquidity_fee_.ClearToEmpty();
}
inline const std::string& FeeFactors::liquidity_fee() const {
  // @@protoc_insertion_point(field_get:vega.FeeFactors.liquidity_fee)
  return _internal_liquidity_fee();
}
inline void FeeFactors::set_liquidity_fee(const std::string& value) {
  _internal_set_liquidity_fee(value);
  // @@protoc_insertion_point(field_set:vega.FeeFactors.liquidity_fee)
}
inline std::string* FeeFactors::mutable_liquidity_fee() {
  // @@protoc_insertion_point(field_mutable:vega.FeeFactors.liquidity_fee)
  return _internal_mutable_liquidity_fee();
}
inline const std::string& FeeFactors::_internal_liquidity_fee() const {
  return liquidity_fee_.Get();
}
inline void FeeFactors::_internal_set_liquidity_fee(const std::string& value) {

  liquidity_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FeeFactors::set_liquidity_fee(std::string&& value) {

  liquidity_fee_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.FeeFactors.liquidity_fee)
}
inline void FeeFactors::set_liquidity_fee(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  liquidity_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.FeeFactors.liquidity_fee)
}
inline void FeeFactors::set_liquidity_fee(const char* value,
    size_t size) {

  liquidity_fee_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.FeeFactors.liquidity_fee)
}
inline std::string* FeeFactors::_internal_mutable_liquidity_fee() {

  return liquidity_fee_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FeeFactors::release_liquidity_fee() {
  // @@protoc_insertion_point(field_release:vega.FeeFactors.liquidity_fee)
  return liquidity_fee_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FeeFactors::set_allocated_liquidity_fee(std::string* liquidity_fee) {
  if (liquidity_fee != nullptr) {

  } else {

  }
  liquidity_fee_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), liquidity_fee,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.FeeFactors.liquidity_fee)
}

// -------------------------------------------------------------------

// Fees

// .vega.FeeFactors factors = 1 [json_name = "factors"];
inline bool Fees::_internal_has_factors() const {
  return this != internal_default_instance() && factors_ != nullptr;
}
inline bool Fees::has_factors() const {
  return _internal_has_factors();
}
inline void Fees::clear_factors() {
  if (GetArena() == nullptr && factors_ != nullptr) {
    delete factors_;
  }
  factors_ = nullptr;
}
inline const ::vega::FeeFactors& Fees::_internal_factors() const {
  const ::vega::FeeFactors* p = factors_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::FeeFactors&>(
      ::vega::_FeeFactors_default_instance_);
}
inline const ::vega::FeeFactors& Fees::factors() const {
  // @@protoc_insertion_point(field_get:vega.Fees.factors)
  return _internal_factors();
}
inline void Fees::unsafe_arena_set_allocated_factors(
    ::vega::FeeFactors* factors) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(factors_);
  }
  factors_ = factors;
  if (factors) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Fees.factors)
}
inline ::vega::FeeFactors* Fees::release_factors() {

  ::vega::FeeFactors* temp = factors_;
  factors_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::FeeFactors* Fees::unsafe_arena_release_factors() {
  // @@protoc_insertion_point(field_release:vega.Fees.factors)

  ::vega::FeeFactors* temp = factors_;
  factors_ = nullptr;
  return temp;
}
inline ::vega::FeeFactors* Fees::_internal_mutable_factors() {

  if (factors_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::FeeFactors>(GetArena());
    factors_ = p;
  }
  return factors_;
}
inline ::vega::FeeFactors* Fees::mutable_factors() {
  // @@protoc_insertion_point(field_mutable:vega.Fees.factors)
  return _internal_mutable_factors();
}
inline void Fees::set_allocated_factors(::vega::FeeFactors* factors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete factors_;
  }
  if (factors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(factors);
    if (message_arena != submessage_arena) {
      factors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, factors, submessage_arena);
    }

  } else {

  }
  factors_ = factors;
  // @@protoc_insertion_point(field_set_allocated:vega.Fees.factors)
}

// -------------------------------------------------------------------

// PriceMonitoringTrigger

// int64 horizon = 1 [json_name = "horizon", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_horizon() {
  horizon_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::_internal_horizon() const {
  return horizon_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::horizon() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.horizon)
  return _internal_horizon();
}
inline void PriceMonitoringTrigger::_internal_set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value) {

  horizon_ = value;
}
inline void PriceMonitoringTrigger::set_horizon(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_horizon(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.horizon)
}

// double probability = 2 [json_name = "probability", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_probability() {
  probability_ = 0;
}
inline double PriceMonitoringTrigger::_internal_probability() const {
  return probability_;
}
inline double PriceMonitoringTrigger::probability() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.probability)
  return _internal_probability();
}
inline void PriceMonitoringTrigger::_internal_set_probability(double value) {

  probability_ = value;
}
inline void PriceMonitoringTrigger::set_probability(double value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.probability)
}

// int64 auction_extension = 3 [json_name = "auctionExtension", (.validator.field) = {
inline void PriceMonitoringTrigger::clear_auction_extension() {
  auction_extension_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::_internal_auction_extension() const {
  return auction_extension_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringTrigger::auction_extension() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringTrigger.auction_extension)
  return _internal_auction_extension();
}
inline void PriceMonitoringTrigger::_internal_set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value) {

  auction_extension_ = value;
}
inline void PriceMonitoringTrigger::set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_auction_extension(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringTrigger.auction_extension)
}

// -------------------------------------------------------------------

// PriceMonitoringParameters

// repeated .vega.PriceMonitoringTrigger triggers = 1 [json_name = "triggers"];
inline int PriceMonitoringParameters::_internal_triggers_size() const {
  return triggers_.size();
}
inline int PriceMonitoringParameters::triggers_size() const {
  return _internal_triggers_size();
}
inline void PriceMonitoringParameters::clear_triggers() {
  triggers_.Clear();
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:vega.PriceMonitoringParameters.triggers)
  return triggers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >*
PriceMonitoringParameters::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:vega.PriceMonitoringParameters.triggers)
  return &triggers_;
}
inline const ::vega::PriceMonitoringTrigger& PriceMonitoringParameters::_internal_triggers(int index) const {
  return triggers_.Get(index);
}
inline const ::vega::PriceMonitoringTrigger& PriceMonitoringParameters::triggers(int index) const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringParameters.triggers)
  return _internal_triggers(index);
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::_internal_add_triggers() {
  return triggers_.Add();
}
inline ::vega::PriceMonitoringTrigger* PriceMonitoringParameters::add_triggers() {
  // @@protoc_insertion_point(field_add:vega.PriceMonitoringParameters.triggers)
  return _internal_add_triggers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vega::PriceMonitoringTrigger >&
PriceMonitoringParameters::triggers() const {
  // @@protoc_insertion_point(field_list:vega.PriceMonitoringParameters.triggers)
  return triggers_;
}

// -------------------------------------------------------------------

// PriceMonitoringSettings

// .vega.PriceMonitoringParameters parameters = 1 [json_name = "parameters"];
inline bool PriceMonitoringSettings::_internal_has_parameters() const {
  return this != internal_default_instance() && parameters_ != nullptr;
}
inline bool PriceMonitoringSettings::has_parameters() const {
  return _internal_has_parameters();
}
inline void PriceMonitoringSettings::clear_parameters() {
  if (GetArena() == nullptr && parameters_ != nullptr) {
    delete parameters_;
  }
  parameters_ = nullptr;
}
inline const ::vega::PriceMonitoringParameters& PriceMonitoringSettings::_internal_parameters() const {
  const ::vega::PriceMonitoringParameters* p = parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringParameters&>(
      ::vega::_PriceMonitoringParameters_default_instance_);
}
inline const ::vega::PriceMonitoringParameters& PriceMonitoringSettings::parameters() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringSettings.parameters)
  return _internal_parameters();
}
inline void PriceMonitoringSettings::unsafe_arena_set_allocated_parameters(
    ::vega::PriceMonitoringParameters* parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameters_);
  }
  parameters_ = parameters;
  if (parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.PriceMonitoringSettings.parameters)
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::release_parameters() {

  ::vega::PriceMonitoringParameters* temp = parameters_;
  parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:vega.PriceMonitoringSettings.parameters)

  ::vega::PriceMonitoringParameters* temp = parameters_;
  parameters_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::_internal_mutable_parameters() {

  if (parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringParameters>(GetArena());
    parameters_ = p;
  }
  return parameters_;
}
inline ::vega::PriceMonitoringParameters* PriceMonitoringSettings::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.PriceMonitoringSettings.parameters)
  return _internal_mutable_parameters();
}
inline void PriceMonitoringSettings::set_allocated_parameters(::vega::PriceMonitoringParameters* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }

  } else {

  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.PriceMonitoringSettings.parameters)
}

// int64 update_frequency = 2 [json_name = "updateFrequency"];
inline void PriceMonitoringSettings::clear_update_frequency() {
  update_frequency_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringSettings::_internal_update_frequency() const {
  return update_frequency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PriceMonitoringSettings::update_frequency() const {
  // @@protoc_insertion_point(field_get:vega.PriceMonitoringSettings.update_frequency)
  return _internal_update_frequency();
}
inline void PriceMonitoringSettings::_internal_set_update_frequency(::PROTOBUF_NAMESPACE_ID::int64 value) {

  update_frequency_ = value;
}
inline void PriceMonitoringSettings::set_update_frequency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_update_frequency(value);
  // @@protoc_insertion_point(field_set:vega.PriceMonitoringSettings.update_frequency)
}

// -------------------------------------------------------------------

// LiquidityMonitoringParameters

// .vega.TargetStakeParameters target_stake_parameters = 1 [json_name = "targetStakeParameters"];
inline bool LiquidityMonitoringParameters::_internal_has_target_stake_parameters() const {
  return this != internal_default_instance() && target_stake_parameters_ != nullptr;
}
inline bool LiquidityMonitoringParameters::has_target_stake_parameters() const {
  return _internal_has_target_stake_parameters();
}
inline void LiquidityMonitoringParameters::clear_target_stake_parameters() {
  if (GetArena() == nullptr && target_stake_parameters_ != nullptr) {
    delete target_stake_parameters_;
  }
  target_stake_parameters_ = nullptr;
}
inline const ::vega::TargetStakeParameters& LiquidityMonitoringParameters::_internal_target_stake_parameters() const {
  const ::vega::TargetStakeParameters* p = target_stake_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::TargetStakeParameters&>(
      ::vega::_TargetStakeParameters_default_instance_);
}
inline const ::vega::TargetStakeParameters& LiquidityMonitoringParameters::target_stake_parameters() const {
  // @@protoc_insertion_point(field_get:vega.LiquidityMonitoringParameters.target_stake_parameters)
  return _internal_target_stake_parameters();
}
inline void LiquidityMonitoringParameters::unsafe_arena_set_allocated_target_stake_parameters(
    ::vega::TargetStakeParameters* target_stake_parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_stake_parameters_);
  }
  target_stake_parameters_ = target_stake_parameters;
  if (target_stake_parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.LiquidityMonitoringParameters.target_stake_parameters)
}
inline ::vega::TargetStakeParameters* LiquidityMonitoringParameters::release_target_stake_parameters() {

  ::vega::TargetStakeParameters* temp = target_stake_parameters_;
  target_stake_parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::TargetStakeParameters* LiquidityMonitoringParameters::unsafe_arena_release_target_stake_parameters() {
  // @@protoc_insertion_point(field_release:vega.LiquidityMonitoringParameters.target_stake_parameters)

  ::vega::TargetStakeParameters* temp = target_stake_parameters_;
  target_stake_parameters_ = nullptr;
  return temp;
}
inline ::vega::TargetStakeParameters* LiquidityMonitoringParameters::_internal_mutable_target_stake_parameters() {

  if (target_stake_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::TargetStakeParameters>(GetArena());
    target_stake_parameters_ = p;
  }
  return target_stake_parameters_;
}
inline ::vega::TargetStakeParameters* LiquidityMonitoringParameters::mutable_target_stake_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.LiquidityMonitoringParameters.target_stake_parameters)
  return _internal_mutable_target_stake_parameters();
}
inline void LiquidityMonitoringParameters::set_allocated_target_stake_parameters(::vega::TargetStakeParameters* target_stake_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_stake_parameters_;
  }
  if (target_stake_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target_stake_parameters);
    if (message_arena != submessage_arena) {
      target_stake_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_stake_parameters, submessage_arena);
    }

  } else {

  }
  target_stake_parameters_ = target_stake_parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.LiquidityMonitoringParameters.target_stake_parameters)
}

// double triggering_ratio = 2 [json_name = "triggeringRatio", (.validator.field) = {
inline void LiquidityMonitoringParameters::clear_triggering_ratio() {
  triggering_ratio_ = 0;
}
inline double LiquidityMonitoringParameters::_internal_triggering_ratio() const {
  return triggering_ratio_;
}
inline double LiquidityMonitoringParameters::triggering_ratio() const {
  // @@protoc_insertion_point(field_get:vega.LiquidityMonitoringParameters.triggering_ratio)
  return _internal_triggering_ratio();
}
inline void LiquidityMonitoringParameters::_internal_set_triggering_ratio(double value) {

  triggering_ratio_ = value;
}
inline void LiquidityMonitoringParameters::set_triggering_ratio(double value) {
  _internal_set_triggering_ratio(value);
  // @@protoc_insertion_point(field_set:vega.LiquidityMonitoringParameters.triggering_ratio)
}

// int64 auction_extension = 3 [json_name = "auctionExtension"];
inline void LiquidityMonitoringParameters::clear_auction_extension() {
  auction_extension_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LiquidityMonitoringParameters::_internal_auction_extension() const {
  return auction_extension_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LiquidityMonitoringParameters::auction_extension() const {
  // @@protoc_insertion_point(field_get:vega.LiquidityMonitoringParameters.auction_extension)
  return _internal_auction_extension();
}
inline void LiquidityMonitoringParameters::_internal_set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value) {

  auction_extension_ = value;
}
inline void LiquidityMonitoringParameters::set_auction_extension(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_auction_extension(value);
  // @@protoc_insertion_point(field_set:vega.LiquidityMonitoringParameters.auction_extension)
}

// -------------------------------------------------------------------

// TargetStakeParameters

// int64 time_window = 1 [json_name = "timeWindow", (.validator.field) = {
inline void TargetStakeParameters::clear_time_window() {
  time_window_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TargetStakeParameters::_internal_time_window() const {
  return time_window_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TargetStakeParameters::time_window() const {
  // @@protoc_insertion_point(field_get:vega.TargetStakeParameters.time_window)
  return _internal_time_window();
}
inline void TargetStakeParameters::_internal_set_time_window(::PROTOBUF_NAMESPACE_ID::int64 value) {

  time_window_ = value;
}
inline void TargetStakeParameters::set_time_window(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_window(value);
  // @@protoc_insertion_point(field_set:vega.TargetStakeParameters.time_window)
}

// double scaling_factor = 2 [json_name = "scalingFactor", (.validator.field) = {
inline void TargetStakeParameters::clear_scaling_factor() {
  scaling_factor_ = 0;
}
inline double TargetStakeParameters::_internal_scaling_factor() const {
  return scaling_factor_;
}
inline double TargetStakeParameters::scaling_factor() const {
  // @@protoc_insertion_point(field_get:vega.TargetStakeParameters.scaling_factor)
  return _internal_scaling_factor();
}
inline void TargetStakeParameters::_internal_set_scaling_factor(double value) {

  scaling_factor_ = value;
}
inline void TargetStakeParameters::set_scaling_factor(double value) {
  _internal_set_scaling_factor(value);
  // @@protoc_insertion_point(field_set:vega.TargetStakeParameters.scaling_factor)
}

// -------------------------------------------------------------------

// Market

// string id = 1 [json_name = "id"];
inline void Market::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Market::id() const {
  // @@protoc_insertion_point(field_get:vega.Market.id)
  return _internal_id();
}
inline void Market::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vega.Market.id)
}
inline std::string* Market::mutable_id() {
  // @@protoc_insertion_point(field_mutable:vega.Market.id)
  return _internal_mutable_id();
}
inline const std::string& Market::_internal_id() const {
  return id_.Get();
}
inline void Market::_internal_set_id(const std::string& value) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Market::set_id(std::string&& value) {

  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:vega.Market.id)
}
inline void Market::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:vega.Market.id)
}
inline void Market::set_id(const char* value,
    size_t size) {

  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:vega.Market.id)
}
inline std::string* Market::_internal_mutable_id() {

  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Market::release_id() {
  // @@protoc_insertion_point(field_release:vega.Market.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Market::set_allocated_id(std::string* id) {
  if (id != nullptr) {

  } else {

  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:vega.Market.id)
}

// .vega.TradableInstrument tradable_instrument = 2 [json_name = "tradableInstrument"];
inline bool Market::_internal_has_tradable_instrument() const {
  return this != internal_default_instance() && tradable_instrument_ != nullptr;
}
inline bool Market::has_tradable_instrument() const {
  return _internal_has_tradable_instrument();
}
inline void Market::clear_tradable_instrument() {
  if (GetArena() == nullptr && tradable_instrument_ != nullptr) {
    delete tradable_instrument_;
  }
  tradable_instrument_ = nullptr;
}
inline const ::vega::TradableInstrument& Market::_internal_tradable_instrument() const {
  const ::vega::TradableInstrument* p = tradable_instrument_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::TradableInstrument&>(
      ::vega::_TradableInstrument_default_instance_);
}
inline const ::vega::TradableInstrument& Market::tradable_instrument() const {
  // @@protoc_insertion_point(field_get:vega.Market.tradable_instrument)
  return _internal_tradable_instrument();
}
inline void Market::unsafe_arena_set_allocated_tradable_instrument(
    ::vega::TradableInstrument* tradable_instrument) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tradable_instrument_);
  }
  tradable_instrument_ = tradable_instrument;
  if (tradable_instrument) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.tradable_instrument)
}
inline ::vega::TradableInstrument* Market::release_tradable_instrument() {

  ::vega::TradableInstrument* temp = tradable_instrument_;
  tradable_instrument_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::TradableInstrument* Market::unsafe_arena_release_tradable_instrument() {
  // @@protoc_insertion_point(field_release:vega.Market.tradable_instrument)

  ::vega::TradableInstrument* temp = tradable_instrument_;
  tradable_instrument_ = nullptr;
  return temp;
}
inline ::vega::TradableInstrument* Market::_internal_mutable_tradable_instrument() {

  if (tradable_instrument_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::TradableInstrument>(GetArena());
    tradable_instrument_ = p;
  }
  return tradable_instrument_;
}
inline ::vega::TradableInstrument* Market::mutable_tradable_instrument() {
  // @@protoc_insertion_point(field_mutable:vega.Market.tradable_instrument)
  return _internal_mutable_tradable_instrument();
}
inline void Market::set_allocated_tradable_instrument(::vega::TradableInstrument* tradable_instrument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tradable_instrument_;
  }
  if (tradable_instrument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tradable_instrument);
    if (message_arena != submessage_arena) {
      tradable_instrument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tradable_instrument, submessage_arena);
    }

  } else {

  }
  tradable_instrument_ = tradable_instrument;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.tradable_instrument)
}

// uint64 decimal_places = 3 [json_name = "decimalPlaces"];
inline void Market::clear_decimal_places() {
  decimal_places_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Market::_internal_decimal_places() const {
  return decimal_places_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Market::decimal_places() const {
  // @@protoc_insertion_point(field_get:vega.Market.decimal_places)
  return _internal_decimal_places();
}
inline void Market::_internal_set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value) {

  decimal_places_ = value;
}
inline void Market::set_decimal_places(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_decimal_places(value);
  // @@protoc_insertion_point(field_set:vega.Market.decimal_places)
}

// .vega.Fees fees = 4 [json_name = "fees"];
inline bool Market::_internal_has_fees() const {
  return this != internal_default_instance() && fees_ != nullptr;
}
inline bool Market::has_fees() const {
  return _internal_has_fees();
}
inline void Market::clear_fees() {
  if (GetArena() == nullptr && fees_ != nullptr) {
    delete fees_;
  }
  fees_ = nullptr;
}
inline const ::vega::Fees& Market::_internal_fees() const {
  const ::vega::Fees* p = fees_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::Fees&>(
      ::vega::_Fees_default_instance_);
}
inline const ::vega::Fees& Market::fees() const {
  // @@protoc_insertion_point(field_get:vega.Market.fees)
  return _internal_fees();
}
inline void Market::unsafe_arena_set_allocated_fees(
    ::vega::Fees* fees) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fees_);
  }
  fees_ = fees;
  if (fees) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.fees)
}
inline ::vega::Fees* Market::release_fees() {

  ::vega::Fees* temp = fees_;
  fees_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::Fees* Market::unsafe_arena_release_fees() {
  // @@protoc_insertion_point(field_release:vega.Market.fees)

  ::vega::Fees* temp = fees_;
  fees_ = nullptr;
  return temp;
}
inline ::vega::Fees* Market::_internal_mutable_fees() {

  if (fees_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::Fees>(GetArena());
    fees_ = p;
  }
  return fees_;
}
inline ::vega::Fees* Market::mutable_fees() {
  // @@protoc_insertion_point(field_mutable:vega.Market.fees)
  return _internal_mutable_fees();
}
inline void Market::set_allocated_fees(::vega::Fees* fees) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fees_;
  }
  if (fees) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fees);
    if (message_arena != submessage_arena) {
      fees = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fees, submessage_arena);
    }

  } else {

  }
  fees_ = fees;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.fees)
}

// .vega.AuctionDuration opening_auction = 5 [json_name = "openingAuction"];
inline bool Market::_internal_has_opening_auction() const {
  return this != internal_default_instance() && opening_auction_ != nullptr;
}
inline bool Market::has_opening_auction() const {
  return _internal_has_opening_auction();
}
inline void Market::clear_opening_auction() {
  if (GetArena() == nullptr && opening_auction_ != nullptr) {
    delete opening_auction_;
  }
  opening_auction_ = nullptr;
}
inline const ::vega::AuctionDuration& Market::_internal_opening_auction() const {
  const ::vega::AuctionDuration* p = opening_auction_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::AuctionDuration&>(
      ::vega::_AuctionDuration_default_instance_);
}
inline const ::vega::AuctionDuration& Market::opening_auction() const {
  // @@protoc_insertion_point(field_get:vega.Market.opening_auction)
  return _internal_opening_auction();
}
inline void Market::unsafe_arena_set_allocated_opening_auction(
    ::vega::AuctionDuration* opening_auction) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opening_auction_);
  }
  opening_auction_ = opening_auction;
  if (opening_auction) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.opening_auction)
}
inline ::vega::AuctionDuration* Market::release_opening_auction() {

  ::vega::AuctionDuration* temp = opening_auction_;
  opening_auction_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::AuctionDuration* Market::unsafe_arena_release_opening_auction() {
  // @@protoc_insertion_point(field_release:vega.Market.opening_auction)

  ::vega::AuctionDuration* temp = opening_auction_;
  opening_auction_ = nullptr;
  return temp;
}
inline ::vega::AuctionDuration* Market::_internal_mutable_opening_auction() {

  if (opening_auction_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::AuctionDuration>(GetArena());
    opening_auction_ = p;
  }
  return opening_auction_;
}
inline ::vega::AuctionDuration* Market::mutable_opening_auction() {
  // @@protoc_insertion_point(field_mutable:vega.Market.opening_auction)
  return _internal_mutable_opening_auction();
}
inline void Market::set_allocated_opening_auction(::vega::AuctionDuration* opening_auction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opening_auction_;
  }
  if (opening_auction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opening_auction);
    if (message_arena != submessage_arena) {
      opening_auction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opening_auction, submessage_arena);
    }

  } else {

  }
  opening_auction_ = opening_auction;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.opening_auction)
}

// .vega.ContinuousTrading continuous = 100 [json_name = "continuous"];
inline bool Market::_internal_has_continuous() const {
  return trading_mode_config_case() == kContinuous;
}
inline bool Market::has_continuous() const {
  return _internal_has_continuous();
}
inline void Market::set_has_continuous() {
  _oneof_case_[0] = kContinuous;
}
inline void Market::clear_continuous() {
  if (_internal_has_continuous()) {
    if (GetArena() == nullptr) {
      delete trading_mode_config_.continuous_;
    }
    clear_has_trading_mode_config();
  }
}
inline ::vega::ContinuousTrading* Market::release_continuous() {
  // @@protoc_insertion_point(field_release:vega.Market.continuous)
  if (_internal_has_continuous()) {
    clear_has_trading_mode_config();
      ::vega::ContinuousTrading* temp = trading_mode_config_.continuous_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    trading_mode_config_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::ContinuousTrading& Market::_internal_continuous() const {
  return _internal_has_continuous()
      ? *trading_mode_config_.continuous_
      : reinterpret_cast< ::vega::ContinuousTrading&>(::vega::_ContinuousTrading_default_instance_);
}
inline const ::vega::ContinuousTrading& Market::continuous() const {
  // @@protoc_insertion_point(field_get:vega.Market.continuous)
  return _internal_continuous();
}
inline ::vega::ContinuousTrading* Market::unsafe_arena_release_continuous() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Market.continuous)
  if (_internal_has_continuous()) {
    clear_has_trading_mode_config();
    ::vega::ContinuousTrading* temp = trading_mode_config_.continuous_;
    trading_mode_config_.continuous_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Market::unsafe_arena_set_allocated_continuous(::vega::ContinuousTrading* continuous) {
  clear_trading_mode_config();
  if (continuous) {
    set_has_continuous();
    trading_mode_config_.continuous_ = continuous;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.continuous)
}
inline ::vega::ContinuousTrading* Market::_internal_mutable_continuous() {
  if (!_internal_has_continuous()) {
    clear_trading_mode_config();
    set_has_continuous();
    trading_mode_config_.continuous_ = CreateMaybeMessage< ::vega::ContinuousTrading >(GetArena());
  }
  return trading_mode_config_.continuous_;
}
inline ::vega::ContinuousTrading* Market::mutable_continuous() {
  // @@protoc_insertion_point(field_mutable:vega.Market.continuous)
  return _internal_mutable_continuous();
}

// .vega.DiscreteTrading discrete = 101 [json_name = "discrete"];
inline bool Market::_internal_has_discrete() const {
  return trading_mode_config_case() == kDiscrete;
}
inline bool Market::has_discrete() const {
  return _internal_has_discrete();
}
inline void Market::set_has_discrete() {
  _oneof_case_[0] = kDiscrete;
}
inline void Market::clear_discrete() {
  if (_internal_has_discrete()) {
    if (GetArena() == nullptr) {
      delete trading_mode_config_.discrete_;
    }
    clear_has_trading_mode_config();
  }
}
inline ::vega::DiscreteTrading* Market::release_discrete() {
  // @@protoc_insertion_point(field_release:vega.Market.discrete)
  if (_internal_has_discrete()) {
    clear_has_trading_mode_config();
      ::vega::DiscreteTrading* temp = trading_mode_config_.discrete_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    trading_mode_config_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vega::DiscreteTrading& Market::_internal_discrete() const {
  return _internal_has_discrete()
      ? *trading_mode_config_.discrete_
      : reinterpret_cast< ::vega::DiscreteTrading&>(::vega::_DiscreteTrading_default_instance_);
}
inline const ::vega::DiscreteTrading& Market::discrete() const {
  // @@protoc_insertion_point(field_get:vega.Market.discrete)
  return _internal_discrete();
}
inline ::vega::DiscreteTrading* Market::unsafe_arena_release_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vega.Market.discrete)
  if (_internal_has_discrete()) {
    clear_has_trading_mode_config();
    ::vega::DiscreteTrading* temp = trading_mode_config_.discrete_;
    trading_mode_config_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Market::unsafe_arena_set_allocated_discrete(::vega::DiscreteTrading* discrete) {
  clear_trading_mode_config();
  if (discrete) {
    set_has_discrete();
    trading_mode_config_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.discrete)
}
inline ::vega::DiscreteTrading* Market::_internal_mutable_discrete() {
  if (!_internal_has_discrete()) {
    clear_trading_mode_config();
    set_has_discrete();
    trading_mode_config_.discrete_ = CreateMaybeMessage< ::vega::DiscreteTrading >(GetArena());
  }
  return trading_mode_config_.discrete_;
}
inline ::vega::DiscreteTrading* Market::mutable_discrete() {
  // @@protoc_insertion_point(field_mutable:vega.Market.discrete)
  return _internal_mutable_discrete();
}

// .vega.PriceMonitoringSettings price_monitoring_settings = 6 [json_name = "priceMonitoringSettings"];
inline bool Market::_internal_has_price_monitoring_settings() const {
  return this != internal_default_instance() && price_monitoring_settings_ != nullptr;
}
inline bool Market::has_price_monitoring_settings() const {
  return _internal_has_price_monitoring_settings();
}
inline void Market::clear_price_monitoring_settings() {
  if (GetArena() == nullptr && price_monitoring_settings_ != nullptr) {
    delete price_monitoring_settings_;
  }
  price_monitoring_settings_ = nullptr;
}
inline const ::vega::PriceMonitoringSettings& Market::_internal_price_monitoring_settings() const {
  const ::vega::PriceMonitoringSettings* p = price_monitoring_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::PriceMonitoringSettings&>(
      ::vega::_PriceMonitoringSettings_default_instance_);
}
inline const ::vega::PriceMonitoringSettings& Market::price_monitoring_settings() const {
  // @@protoc_insertion_point(field_get:vega.Market.price_monitoring_settings)
  return _internal_price_monitoring_settings();
}
inline void Market::unsafe_arena_set_allocated_price_monitoring_settings(
    ::vega::PriceMonitoringSettings* price_monitoring_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(price_monitoring_settings_);
  }
  price_monitoring_settings_ = price_monitoring_settings;
  if (price_monitoring_settings) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.price_monitoring_settings)
}
inline ::vega::PriceMonitoringSettings* Market::release_price_monitoring_settings() {

  ::vega::PriceMonitoringSettings* temp = price_monitoring_settings_;
  price_monitoring_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::PriceMonitoringSettings* Market::unsafe_arena_release_price_monitoring_settings() {
  // @@protoc_insertion_point(field_release:vega.Market.price_monitoring_settings)

  ::vega::PriceMonitoringSettings* temp = price_monitoring_settings_;
  price_monitoring_settings_ = nullptr;
  return temp;
}
inline ::vega::PriceMonitoringSettings* Market::_internal_mutable_price_monitoring_settings() {

  if (price_monitoring_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::PriceMonitoringSettings>(GetArena());
    price_monitoring_settings_ = p;
  }
  return price_monitoring_settings_;
}
inline ::vega::PriceMonitoringSettings* Market::mutable_price_monitoring_settings() {
  // @@protoc_insertion_point(field_mutable:vega.Market.price_monitoring_settings)
  return _internal_mutable_price_monitoring_settings();
}
inline void Market::set_allocated_price_monitoring_settings(::vega::PriceMonitoringSettings* price_monitoring_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete price_monitoring_settings_;
  }
  if (price_monitoring_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(price_monitoring_settings);
    if (message_arena != submessage_arena) {
      price_monitoring_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, price_monitoring_settings, submessage_arena);
    }

  } else {

  }
  price_monitoring_settings_ = price_monitoring_settings;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.price_monitoring_settings)
}

// .vega.LiquidityMonitoringParameters liquidity_monitoring_parameters = 7 [json_name = "liquidityMonitoringParameters"];
inline bool Market::_internal_has_liquidity_monitoring_parameters() const {
  return this != internal_default_instance() && liquidity_monitoring_parameters_ != nullptr;
}
inline bool Market::has_liquidity_monitoring_parameters() const {
  return _internal_has_liquidity_monitoring_parameters();
}
inline void Market::clear_liquidity_monitoring_parameters() {
  if (GetArena() == nullptr && liquidity_monitoring_parameters_ != nullptr) {
    delete liquidity_monitoring_parameters_;
  }
  liquidity_monitoring_parameters_ = nullptr;
}
inline const ::vega::LiquidityMonitoringParameters& Market::_internal_liquidity_monitoring_parameters() const {
  const ::vega::LiquidityMonitoringParameters* p = liquidity_monitoring_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::LiquidityMonitoringParameters&>(
      ::vega::_LiquidityMonitoringParameters_default_instance_);
}
inline const ::vega::LiquidityMonitoringParameters& Market::liquidity_monitoring_parameters() const {
  // @@protoc_insertion_point(field_get:vega.Market.liquidity_monitoring_parameters)
  return _internal_liquidity_monitoring_parameters();
}
inline void Market::unsafe_arena_set_allocated_liquidity_monitoring_parameters(
    ::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(liquidity_monitoring_parameters_);
  }
  liquidity_monitoring_parameters_ = liquidity_monitoring_parameters;
  if (liquidity_monitoring_parameters) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.liquidity_monitoring_parameters)
}
inline ::vega::LiquidityMonitoringParameters* Market::release_liquidity_monitoring_parameters() {

  ::vega::LiquidityMonitoringParameters* temp = liquidity_monitoring_parameters_;
  liquidity_monitoring_parameters_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::LiquidityMonitoringParameters* Market::unsafe_arena_release_liquidity_monitoring_parameters() {
  // @@protoc_insertion_point(field_release:vega.Market.liquidity_monitoring_parameters)

  ::vega::LiquidityMonitoringParameters* temp = liquidity_monitoring_parameters_;
  liquidity_monitoring_parameters_ = nullptr;
  return temp;
}
inline ::vega::LiquidityMonitoringParameters* Market::_internal_mutable_liquidity_monitoring_parameters() {

  if (liquidity_monitoring_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::LiquidityMonitoringParameters>(GetArena());
    liquidity_monitoring_parameters_ = p;
  }
  return liquidity_monitoring_parameters_;
}
inline ::vega::LiquidityMonitoringParameters* Market::mutable_liquidity_monitoring_parameters() {
  // @@protoc_insertion_point(field_mutable:vega.Market.liquidity_monitoring_parameters)
  return _internal_mutable_liquidity_monitoring_parameters();
}
inline void Market::set_allocated_liquidity_monitoring_parameters(::vega::LiquidityMonitoringParameters* liquidity_monitoring_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete liquidity_monitoring_parameters_;
  }
  if (liquidity_monitoring_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(liquidity_monitoring_parameters);
    if (message_arena != submessage_arena) {
      liquidity_monitoring_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, liquidity_monitoring_parameters, submessage_arena);
    }

  } else {

  }
  liquidity_monitoring_parameters_ = liquidity_monitoring_parameters;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.liquidity_monitoring_parameters)
}

// .vega.Market.TradingMode trading_mode = 8 [json_name = "tradingMode"];
inline void Market::clear_trading_mode() {
  trading_mode_ = 0;
}
inline ::vega::Market_TradingMode Market::_internal_trading_mode() const {
  return static_cast< ::vega::Market_TradingMode >(trading_mode_);
}
inline ::vega::Market_TradingMode Market::trading_mode() const {
  // @@protoc_insertion_point(field_get:vega.Market.trading_mode)
  return _internal_trading_mode();
}
inline void Market::_internal_set_trading_mode(::vega::Market_TradingMode value) {

  trading_mode_ = value;
}
inline void Market::set_trading_mode(::vega::Market_TradingMode value) {
  _internal_set_trading_mode(value);
  // @@protoc_insertion_point(field_set:vega.Market.trading_mode)
}

// .vega.Market.State state = 9 [json_name = "state"];
inline void Market::clear_state() {
  state_ = 0;
}
inline ::vega::Market_State Market::_internal_state() const {
  return static_cast< ::vega::Market_State >(state_);
}
inline ::vega::Market_State Market::state() const {
  // @@protoc_insertion_point(field_get:vega.Market.state)
  return _internal_state();
}
inline void Market::_internal_set_state(::vega::Market_State value) {

  state_ = value;
}
inline void Market::set_state(::vega::Market_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:vega.Market.state)
}

// .vega.MarketTimestamps market_timestamps = 10 [json_name = "marketTimestamps"];
inline bool Market::_internal_has_market_timestamps() const {
  return this != internal_default_instance() && market_timestamps_ != nullptr;
}
inline bool Market::has_market_timestamps() const {
  return _internal_has_market_timestamps();
}
inline void Market::clear_market_timestamps() {
  if (GetArena() == nullptr && market_timestamps_ != nullptr) {
    delete market_timestamps_;
  }
  market_timestamps_ = nullptr;
}
inline const ::vega::MarketTimestamps& Market::_internal_market_timestamps() const {
  const ::vega::MarketTimestamps* p = market_timestamps_;
  return p != nullptr ? *p : reinterpret_cast<const ::vega::MarketTimestamps&>(
      ::vega::_MarketTimestamps_default_instance_);
}
inline const ::vega::MarketTimestamps& Market::market_timestamps() const {
  // @@protoc_insertion_point(field_get:vega.Market.market_timestamps)
  return _internal_market_timestamps();
}
inline void Market::unsafe_arena_set_allocated_market_timestamps(
    ::vega::MarketTimestamps* market_timestamps) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(market_timestamps_);
  }
  market_timestamps_ = market_timestamps;
  if (market_timestamps) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vega.Market.market_timestamps)
}
inline ::vega::MarketTimestamps* Market::release_market_timestamps() {

  ::vega::MarketTimestamps* temp = market_timestamps_;
  market_timestamps_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::vega::MarketTimestamps* Market::unsafe_arena_release_market_timestamps() {
  // @@protoc_insertion_point(field_release:vega.Market.market_timestamps)

  ::vega::MarketTimestamps* temp = market_timestamps_;
  market_timestamps_ = nullptr;
  return temp;
}
inline ::vega::MarketTimestamps* Market::_internal_mutable_market_timestamps() {

  if (market_timestamps_ == nullptr) {
    auto* p = CreateMaybeMessage<::vega::MarketTimestamps>(GetArena());
    market_timestamps_ = p;
  }
  return market_timestamps_;
}
inline ::vega::MarketTimestamps* Market::mutable_market_timestamps() {
  // @@protoc_insertion_point(field_mutable:vega.Market.market_timestamps)
  return _internal_mutable_market_timestamps();
}
inline void Market::set_allocated_market_timestamps(::vega::MarketTimestamps* market_timestamps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete market_timestamps_;
  }
  if (market_timestamps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(market_timestamps);
    if (message_arena != submessage_arena) {
      market_timestamps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, market_timestamps, submessage_arena);
    }

  } else {

  }
  market_timestamps_ = market_timestamps;
  // @@protoc_insertion_point(field_set_allocated:vega.Market.market_timestamps)
}

inline bool Market::has_trading_mode_config() const {
  return trading_mode_config_case() != TRADING_MODE_CONFIG_NOT_SET;
}
inline void Market::clear_has_trading_mode_config() {
  _oneof_case_[0] = TRADING_MODE_CONFIG_NOT_SET;
}
inline Market::TradingModeConfigCase Market::trading_mode_config_case() const {
  return Market::TradingModeConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MarketTimestamps

// int64 proposed = 1 [json_name = "proposed"];
inline void MarketTimestamps::clear_proposed() {
  proposed_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::_internal_proposed() const {
  return proposed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::proposed() const {
  // @@protoc_insertion_point(field_get:vega.MarketTimestamps.proposed)
  return _internal_proposed();
}
inline void MarketTimestamps::_internal_set_proposed(::PROTOBUF_NAMESPACE_ID::int64 value) {

  proposed_ = value;
}
inline void MarketTimestamps::set_proposed(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_proposed(value);
  // @@protoc_insertion_point(field_set:vega.MarketTimestamps.proposed)
}

// int64 pending = 2 [json_name = "pending"];
inline void MarketTimestamps::clear_pending() {
  pending_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::_internal_pending() const {
  return pending_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::pending() const {
  // @@protoc_insertion_point(field_get:vega.MarketTimestamps.pending)
  return _internal_pending();
}
inline void MarketTimestamps::_internal_set_pending(::PROTOBUF_NAMESPACE_ID::int64 value) {

  pending_ = value;
}
inline void MarketTimestamps::set_pending(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pending(value);
  // @@protoc_insertion_point(field_set:vega.MarketTimestamps.pending)
}

// int64 open = 3 [json_name = "open"];
inline void MarketTimestamps::clear_open() {
  open_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::_internal_open() const {
  return open_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::open() const {
  // @@protoc_insertion_point(field_get:vega.MarketTimestamps.open)
  return _internal_open();
}
inline void MarketTimestamps::_internal_set_open(::PROTOBUF_NAMESPACE_ID::int64 value) {

  open_ = value;
}
inline void MarketTimestamps::set_open(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:vega.MarketTimestamps.open)
}

// int64 close = 4 [json_name = "close"];
inline void MarketTimestamps::clear_close() {
  close_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::_internal_close() const {
  return close_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MarketTimestamps::close() const {
  // @@protoc_insertion_point(field_get:vega.MarketTimestamps.close)
  return _internal_close();
}
inline void MarketTimestamps::_internal_set_close(::PROTOBUF_NAMESPACE_ID::int64 value) {

  close_ = value;
}
inline void MarketTimestamps::set_close(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_close(value);
  // @@protoc_insertion_point(field_set:vega.MarketTimestamps.close)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vega

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vega::Market_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Market_State>() {
  return ::vega::Market_State_descriptor();
}
template <> struct is_proto_enum< ::vega::Market_TradingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vega::Market_TradingMode>() {
  return ::vega::Market_TradingMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_markets_2eproto
